(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*global fetch*/
'use strict';

function fetchJSON(url, options) {
	return fetch(url, options).then(function (response) {
		return response.text();
	}).then(function (string) {
		return JSON.parse(string);
	});
}

module.exports = fetchJSON;

},{}],2:[function(require,module,exports){
/*global THREE*/
'use strict';

module.exports.parse = function (sceneIn) {
	var loader = new THREE.ObjectLoader();
	var scene = loader.parse(sceneIn);
	return scene;
};

// used for populating cannon
module.exports.getGeomFromScene = function (scene) {
	var geoms = [];
	scene.children.forEach(function (mesh) {
		if (mesh.type !== 'Mesh') return;
		var geometry = mesh.geometry.clone();
		mesh.updateMatrix();
		mesh.updateMatrixWorld();
		var posMat = new THREE.Matrix4();
		mesh.matrixWorld.copyPosition(posMat);
		var center = [0, 0, 0];
		posMat.applyToVector3Array(center);
		geometry.vertices.map(function (v) {
			return v.applyMatrix4(mesh.matrixWorld);
		});
		geoms.push({ geometry: geometry, center: center });
	});
	return geoms;
};

},{}],3:[function(require,module,exports){
/*jshint worker:true*/

'use strict';

importScripts('./three.min.js'); // loaded from vendor dir
var Cannon = require('cannon');
var fetchJSON = require('./lib/fetchJSON.js');
var fixGeometry = require('./lib/fixGeometry');

var world = new Cannon.World();
var customObjects = [];

world.gravity.set(0, -10, 0);
world.broadphase = new Cannon.NaiveBroadphase();
world.solver.iterations = 8;

var oldT = 0;
function animate() {

	var t = Date.now();
	var dT = (t - oldT) / 1000;

	world.step(dT);
	oldT = t;
}

// swap y,z
function swapYZ(v) {
	return {
		x: v.x,
		y: v.y,
		z: v.z
	};
}

function getObject(_ref) {
	var id = _ref.id;
	var mass = _ref.mass;

	if (!mass) mass = 0;
	return fetchJSON('../models/' + id + '.json').then(function (scene) {

		var modelBody = new Cannon.Body({ mass: mass });

		var newScene = fixGeometry.parse(scene);

		fixGeometry.getGeomFromScene(newScene).forEach(function (_ref2) {
			var geometry = _ref2.geometry;
			var center = _ref2.center;

			// Construct polyhedron
			var modelPart = new Cannon.ConvexPolyhedron(geometry.vertices.map(function (v) {
				return new Cannon.Vec3(v.x - center[0], v.y - center[1], v.z - center[2]);
			}), geometry.faces.map(function (f) {
				return [f.a, f.b, f.c];
			}));

			modelPart.transformAllPoints(new Cannon.Vec3(center[0], center[1], center[2]));

			// Add to compound
			modelBody.addShape(modelPart);
		});

		// Create body
		// modelBody.quaternion.setFromAxisAngle(new Cannon.Vec3(1, 0, 0), Math.PI / 2);
		return modelBody;
	});
}

// Recieve messages from the client and reply back onthe same port
self.addEventListener('message', function (event) {
	Promise.resolve().then(function () {

		switch (event.data.action) {
			case 'init':

				world.defaultContactMaterial.contactEquationStiffness = 5e7;
				world.defaultContactMaterial.contactEquationRelaxation = 4;
				return;

			case 'getModelData':
				animate();
				event.data.modelData = customObjects.map(function (p) {
					return {

						// swap y,z for exporting
						position: swapYZ(p.position),
						quaternion: p.quaternion,
						meta: p.meta,
						id: p.id
					};
				});
				return;

			case 'addObject':
				return getObject({
					id: event.data.options.id,
					mass: event.data.options.mass || 0
				}).then(function (body2) {
					var p = swapYZ(event.data.options.position);
					body2.position.set(p.x, p.y, p.z);
					event.data.id = body2.id;
					customObjects.push(body2);
					body2.meta = event.data.options.meta || {};
					body2.meta.type = 'genericObject';
					world.addBody(body2);
					body2.addEventListener("collide", function () {
						// console.log("Contact between bodies:",e.contact);
					});
				});

			case 'addPoint':
				var body1 = new Cannon.Body({
					mass: event.data.pointOptions.mass,
					velocity: swapYZ(event.data.pointOptions.velocity),
					position: swapYZ(event.data.pointOptions.position)
				});
				body1.addShape(new Cannon.Sphere(event.data.pointOptions.radius));
				world.addBody(body1);
				customObjects.push(body1);
				body1.meta = event.data.pointOptions.meta || {};
				body1.meta.type = 'point';
				body1.meta.radius = event.data.pointOptions.radius;

				body1.linearDamping = 0.01;
				return;

			default:
				throw Error('Invalid Action');
		}
	}).then(function () {
		event.data.success = true;
	}, function (err) {
		console.error(err);
		event.data.success = false;
		if (err) {
			event.data.message = err.message ? err.message : err;
		}
	}).then(function () {
		event.ports[0].postMessage(event.data);
	});
});

},{"./lib/fetchJSON.js":1,"./lib/fixGeometry":2,"cannon":5}],4:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "cannon@github:schteppe/cannon.js",
      "/home/ada/gitWorkingDir/cardboard2"
    ]
  ],
  "_from": "schteppe/cannon.js",
  "_id": "cannon@0.6.2",
  "_inCache": true,
  "_location": "/cannon",
  "_phantomChildren": {},
  "_requested": {
    "hosted": {
      "directUrl": "https://raw.githubusercontent.com/schteppe/cannon.js/master/package.json",
      "gitUrl": "git://github.com/schteppe/cannon.js.git",
      "httpsUrl": "git+https://github.com/schteppe/cannon.js.git",
      "shortcut": "github:schteppe/cannon.js",
      "ssh": "git@github.com:schteppe/cannon.js.git",
      "sshUrl": "git+ssh://git@github.com/schteppe/cannon.js.git",
      "type": "github"
    },
    "name": "cannon",
    "raw": "cannon@github:schteppe/cannon.js",
    "rawSpec": "github:schteppe/cannon.js",
    "scope": null,
    "spec": "github:schteppe/cannon.js",
    "type": "hosted"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git://github.com/schteppe/cannon.js.git#679102a485c7dd4366abd7a2b0ccc1c7aeb26bd1",
  "_shasum": "6b6cbed66a3da03b64d2db40f86e1a6b8f8c6747",
  "_shrinkwrap": null,
  "_spec": "cannon@github:schteppe/cannon.js",
  "_where": "/home/ada/gitWorkingDir/cardboard2",
  "author": {
    "email": "schteppe@gmail.com",
    "name": "Stefan Hedman",
    "url": "http://steffe.se"
  },
  "bugs": {
    "url": "https://github.com/schteppe/cannon.js/issues"
  },
  "dependencies": {},
  "description": "A lightweight 3D physics engine written in JavaScript.",
  "devDependencies": {
    "browserify": "*",
    "grunt": "~0.4.0",
    "grunt-browserify": "^2.1.4",
    "grunt-contrib-concat": "~0.1.3",
    "grunt-contrib-jshint": "~0.1.1",
    "grunt-contrib-nodeunit": "^0.4.1",
    "grunt-contrib-uglify": "^0.5.1",
    "grunt-contrib-yuidoc": "^0.5.2",
    "jshint": "latest",
    "nodeunit": "^0.9.0",
    "uglify-js": "latest"
  },
  "engines": {
    "node": "*"
  },
  "gitHead": "679102a485c7dd4366abd7a2b0ccc1c7aeb26bd1",
  "homepage": "https://github.com/schteppe/cannon.js",
  "installable": true,
  "keywords": [
    "3d",
    "cannon",
    "cannon.js",
    "engine",
    "physics"
  ],
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "main": "./src/Cannon.js",
  "name": "cannon",
  "optionalDependencies": {},
  "readme": "# cannon.js\n\n### Lightweight 3D physics for the web\nInspired by [three.js](https://github.com/mrdoob/three.js) and [ammo.js](https://github.com/kripken/ammo.js), and driven by the fact that the web lacks a physics engine, here comes cannon.js.\nThe rigid body physics engine includes simple collision detection, various body shapes, contacts, friction and constraints.\n\n[Demos](http://schteppe.github.com/cannon.js) - [Documentation](http://schteppe.github.com/cannon.js/docs) - [Rendering hints](https://github.com/schteppe/cannon.js/tree/master/examples) - [NPM package](https://npmjs.org/package/cannon) - [CDN](https://cdnjs.com/libraries/cannon.js)\n\n### Browser install\n\nJust include [cannon.js](https://github.com/schteppe/cannon.js/releases/download/v0.6.2/cannon.js) or [cannon.min.js](https://github.com/schteppe/cannon.js/releases/download/v0.6.2/cannon.min.js) in your html and you're done:\n\n```html\n<script src=\"cannon.min.js\"></script>\n```\n\n### Node.js install\n\nInstall the cannon package via NPM:\n\n```bash\nnpm install --save cannon\n```\n\nAlternatively, point to the Github repo directly to get the very latest version:\n\n```bash\nnpm install --save schteppe/cannon.js\n```\n\n### Example\n\nThe sample code below creates a sphere on a plane, steps the simulation, and prints the sphere simulation to the console. Note that Cannon.js uses [SI units](http://en.wikipedia.org/wiki/International_System_of_Units) (metre, kilogram, second, etc.).\n\n```javascript\n// Setup our world\nvar world = new CANNON.World();\nworld.gravity.set(0, 0, -9.82); // m/sÂ²\n\n// Create a sphere\nvar radius = 1; // m\nvar sphereBody = new CANNON.Body({\n   mass: 5, // kg\n   position: new CANNON.Vec3(0, 0, 10), // m\n   shape: new CANNON.Sphere(radius)\n});\nworld.addBody(sphereBody);\n\n// Create a plane\nvar groundBody = new CANNON.Body({\n    mass: 0 // mass == 0 makes the body static\n});\nvar groundShape = new CANNON.Plane();\ngroundBody.addShape(groundShape);\nworld.addBody(groundBody);\n\nvar fixedTimeStep = 1.0 / 60.0; // seconds\nvar maxSubSteps = 3;\n\n// Start the simulation loop\nvar lastTime;\n(function simloop(time){\n  requestAnimationFrame(simloop);\n  if(lastTime !== undefined){\n     var dt = (time - lastTime) / 1000;\n     world.step(fixedTimeStep, dt, maxSubSteps);\n  }\n  console.log(\"Sphere z position: \" + sphereBody.position.z);\n  lastTime = time;\n})();\n```\n\nIf you want to know how to use cannon.js with a rendering engine, for example Three.js, see the [Examples](examples).\n\n### Features\n* Rigid body dynamics\n* Discrete collision detection\n* Contacts, friction and restitution\n* Constraints\n   * PointToPoint (a.k.a. ball/socket joint)\n   * Distance\n   * Hinge (with optional motor)\n   * Lock\n   * ConeTwist\n* Gauss-Seidel constraint solver and an island split algorithm\n* Collision filters\n* Body sleeping\n* Experimental SPH / fluid support\n* Various shapes and collision algorithms (see table below)\n\n|             | [Sphere](http://schteppe.github.io/cannon.js/docs/classes/Sphere.html) | [Plane](http://schteppe.github.io/cannon.js/docs/classes/Plane.html) | [Box](http://schteppe.github.io/cannon.js/docs/classes/Box.html) | [Convex](http://schteppe.github.io/cannon.js/docs/classes/ConvexPolyhedron.html) | [Particle](http://schteppe.github.io/cannon.js/docs/classes/Particle.html) | [Heightfield](http://schteppe.github.io/cannon.js/docs/classes/Heightfield.html) | [Trimesh](http://schteppe.github.io/cannon.js/docs/classes/Trimesh.html) |\n| :-----------|:------:|:-----:|:---:|:------:|:--------:|:-----------:|:-------:|\n| Sphere      | Yes    | Yes   | Yes | Yes    | Yes      | Yes         | Yes     |\n| Plane       | -      | -     | Yes | Yes    | Yes      | -           | Yes     |\n| Box         | -      | -     | Yes | Yes    | Yes      | Yes         | (todo)  |\n| Cylinder    | -      | -     | Yes | Yes    | Yes      | Yes         | (todo)  |\n| Convex      | -      | -     | -   | Yes    | Yes      | Yes         | (todo)  |\n| Particle    | -      | -     | -   | -      | -        | (todo)      | (todo)  |\n| Heightfield | -      | -     | -   | -      | -        | -           | (todo)  |\n| Trimesh     | -      | -     | -   | -      | -        | -           | -       |\n\n### Todo\nThe simpler todos are marked with ```@todo``` in the code. Github Issues can and should also be used for todos.\n\n### Help\nCreate an [issue](https://github.com/schteppe/cannon.js/issues) if you need help.\n",
  "readmeFilename": "README.markdown",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/schteppe/cannon.js.git"
  },
  "version": "0.6.2"
}

},{}],5:[function(require,module,exports){
// Export classes
module.exports = {
    version :                       require('../package.json').version,

    AABB :                          require('./collision/AABB'),
    ArrayCollisionMatrix :          require('./collision/ArrayCollisionMatrix'),
    Body :                          require('./objects/Body'),
    Box :                           require('./shapes/Box'),
    Broadphase :                    require('./collision/Broadphase'),
    Constraint :                    require('./constraints/Constraint'),
    ContactEquation :               require('./equations/ContactEquation'),
    Narrowphase :                   require('./world/Narrowphase'),
    ConeTwistConstraint :           require('./constraints/ConeTwistConstraint'),
    ContactMaterial :               require('./material/ContactMaterial'),
    ConvexPolyhedron :              require('./shapes/ConvexPolyhedron'),
    Cylinder :                      require('./shapes/Cylinder'),
    DistanceConstraint :            require('./constraints/DistanceConstraint'),
    Equation :                      require('./equations/Equation'),
    EventTarget :                   require('./utils/EventTarget'),
    FrictionEquation :              require('./equations/FrictionEquation'),
    GSSolver :                      require('./solver/GSSolver'),
    GridBroadphase :                require('./collision/GridBroadphase'),
    Heightfield :                   require('./shapes/Heightfield'),
    HingeConstraint :               require('./constraints/HingeConstraint'),
    LockConstraint :                require('./constraints/LockConstraint'),
    Mat3 :                          require('./math/Mat3'),
    Material :                      require('./material/Material'),
    NaiveBroadphase :               require('./collision/NaiveBroadphase'),
    ObjectCollisionMatrix :         require('./collision/ObjectCollisionMatrix'),
    Pool :                          require('./utils/Pool'),
    Particle :                      require('./shapes/Particle'),
    Plane :                         require('./shapes/Plane'),
    PointToPointConstraint :        require('./constraints/PointToPointConstraint'),
    Quaternion :                    require('./math/Quaternion'),
    Ray :                           require('./collision/Ray'),
    RaycastVehicle :                require('./objects/RaycastVehicle'),
    RaycastResult :                 require('./collision/RaycastResult'),
    RigidVehicle :                  require('./objects/RigidVehicle'),
    RotationalEquation :            require('./equations/RotationalEquation'),
    RotationalMotorEquation :       require('./equations/RotationalMotorEquation'),
    SAPBroadphase :                 require('./collision/SAPBroadphase'),
    SPHSystem :                     require('./objects/SPHSystem'),
    Shape :                         require('./shapes/Shape'),
    Solver :                        require('./solver/Solver'),
    Sphere :                        require('./shapes/Sphere'),
    SplitSolver :                   require('./solver/SplitSolver'),
    Spring :                        require('./objects/Spring'),
    Transform :                     require('./math/Transform'),
    Trimesh :                       require('./shapes/Trimesh'),
    Vec3 :                          require('./math/Vec3'),
    Vec3Pool :                      require('./utils/Vec3Pool'),
    World :                         require('./world/World'),
};

},{"../package.json":4,"./collision/AABB":6,"./collision/ArrayCollisionMatrix":7,"./collision/Broadphase":8,"./collision/GridBroadphase":9,"./collision/NaiveBroadphase":10,"./collision/ObjectCollisionMatrix":11,"./collision/Ray":12,"./collision/RaycastResult":13,"./collision/SAPBroadphase":14,"./constraints/ConeTwistConstraint":15,"./constraints/Constraint":16,"./constraints/DistanceConstraint":17,"./constraints/HingeConstraint":18,"./constraints/LockConstraint":19,"./constraints/PointToPointConstraint":20,"./equations/ContactEquation":22,"./equations/Equation":23,"./equations/FrictionEquation":24,"./equations/RotationalEquation":25,"./equations/RotationalMotorEquation":26,"./material/ContactMaterial":27,"./material/Material":28,"./math/Mat3":30,"./math/Quaternion":31,"./math/Transform":32,"./math/Vec3":33,"./objects/Body":34,"./objects/RaycastVehicle":35,"./objects/RigidVehicle":36,"./objects/SPHSystem":37,"./objects/Spring":38,"./shapes/Box":40,"./shapes/ConvexPolyhedron":41,"./shapes/Cylinder":42,"./shapes/Heightfield":43,"./shapes/Particle":44,"./shapes/Plane":45,"./shapes/Shape":46,"./shapes/Sphere":47,"./shapes/Trimesh":48,"./solver/GSSolver":49,"./solver/Solver":50,"./solver/SplitSolver":51,"./utils/EventTarget":52,"./utils/Pool":54,"./utils/Vec3Pool":57,"./world/Narrowphase":58,"./world/World":59}],6:[function(require,module,exports){
var Vec3 = require('../math/Vec3');
var Utils = require('../utils/Utils');

module.exports = AABB;

/**
 * Axis aligned bounding box class.
 * @class AABB
 * @constructor
 * @param {Object} [options]
 * @param {Vec3}   [options.upperBound]
 * @param {Vec3}   [options.lowerBound]
 */
function AABB(options){
    options = options || {};

    /**
     * The lower bound of the bounding box.
     * @property lowerBound
     * @type {Vec3}
     */
    this.lowerBound = new Vec3();
    if(options.lowerBound){
        this.lowerBound.copy(options.lowerBound);
    }

    /**
     * The upper bound of the bounding box.
     * @property upperBound
     * @type {Vec3}
     */
    this.upperBound = new Vec3();
    if(options.upperBound){
        this.upperBound.copy(options.upperBound);
    }
}

var tmp = new Vec3();

/**
 * Set the AABB bounds from a set of points.
 * @method setFromPoints
 * @param {Array} points An array of Vec3's.
 * @param {Vec3} position
 * @param {Quaternion} quaternion
 * @param {number} skinSize
 * @return {AABB} The self object
 */
AABB.prototype.setFromPoints = function(points, position, quaternion, skinSize){
    var l = this.lowerBound,
        u = this.upperBound,
        q = quaternion;

    // Set to the first point
    l.copy(points[0]);
    if(q){
        q.vmult(l, l);
    }
    u.copy(l);

    for(var i = 1; i<points.length; i++){
        var p = points[i];

        if(q){
            q.vmult(p, tmp);
            p = tmp;
        }

        if(p.x > u.x){ u.x = p.x; }
        if(p.x < l.x){ l.x = p.x; }
        if(p.y > u.y){ u.y = p.y; }
        if(p.y < l.y){ l.y = p.y; }
        if(p.z > u.z){ u.z = p.z; }
        if(p.z < l.z){ l.z = p.z; }
    }

    // Add offset
    if (position) {
        position.vadd(l, l);
        position.vadd(u, u);
    }

    if(skinSize){
        l.x -= skinSize;
        l.y -= skinSize;
        l.z -= skinSize;
        u.x += skinSize;
        u.y += skinSize;
        u.z += skinSize;
    }

    return this;
};

/**
 * Copy bounds from an AABB to this AABB
 * @method copy
 * @param  {AABB} aabb Source to copy from
 * @return {AABB} The this object, for chainability
 */
AABB.prototype.copy = function(aabb){
    this.lowerBound.copy(aabb.lowerBound);
    this.upperBound.copy(aabb.upperBound);
    return this;
};

/**
 * Clone an AABB
 * @method clone
 */
AABB.prototype.clone = function(){
    return new AABB().copy(this);
};

/**
 * Extend this AABB so that it covers the given AABB too.
 * @method extend
 * @param  {AABB} aabb
 */
AABB.prototype.extend = function(aabb){
    this.lowerBound.x = Math.min(this.lowerBound.x, aabb.lowerBound.x);
    this.upperBound.x = Math.max(this.upperBound.x, aabb.upperBound.x);
    this.lowerBound.y = Math.min(this.lowerBound.y, aabb.lowerBound.y);
    this.upperBound.y = Math.max(this.upperBound.y, aabb.upperBound.y);
    this.lowerBound.z = Math.min(this.lowerBound.z, aabb.lowerBound.z);
    this.upperBound.z = Math.max(this.upperBound.z, aabb.upperBound.z);
};

/**
 * Returns true if the given AABB overlaps this AABB.
 * @method overlaps
 * @param  {AABB} aabb
 * @return {Boolean}
 */
AABB.prototype.overlaps = function(aabb){
    var l1 = this.lowerBound,
        u1 = this.upperBound,
        l2 = aabb.lowerBound,
        u2 = aabb.upperBound;

    //      l2        u2
    //      |---------|
    // |--------|
    // l1       u1

    var overlapsX = ((l2.x <= u1.x && u1.x <= u2.x) || (l1.x <= u2.x && u2.x <= u1.x));
    var overlapsY = ((l2.y <= u1.y && u1.y <= u2.y) || (l1.y <= u2.y && u2.y <= u1.y));
    var overlapsZ = ((l2.z <= u1.z && u1.z <= u2.z) || (l1.z <= u2.z && u2.z <= u1.z));

    return overlapsX && overlapsY && overlapsZ;
};

// Mostly for debugging
AABB.prototype.volume = function(){
    var l = this.lowerBound,
        u = this.upperBound;
    return (u.x - l.x) * (u.y - l.y) * (u.z - l.z);
};


/**
 * Returns true if the given AABB is fully contained in this AABB.
 * @method contains
 * @param {AABB} aabb
 * @return {Boolean}
 */
AABB.prototype.contains = function(aabb){
    var l1 = this.lowerBound,
        u1 = this.upperBound,
        l2 = aabb.lowerBound,
        u2 = aabb.upperBound;

    //      l2        u2
    //      |---------|
    // |---------------|
    // l1              u1

    return (
        (l1.x <= l2.x && u1.x >= u2.x) &&
        (l1.y <= l2.y && u1.y >= u2.y) &&
        (l1.z <= l2.z && u1.z >= u2.z)
    );
};

/**
 * @method getCorners
 * @param {Vec3} a
 * @param {Vec3} b
 * @param {Vec3} c
 * @param {Vec3} d
 * @param {Vec3} e
 * @param {Vec3} f
 * @param {Vec3} g
 * @param {Vec3} h
 */
AABB.prototype.getCorners = function(a, b, c, d, e, f, g, h){
    var l = this.lowerBound,
        u = this.upperBound;

    a.copy(l);
    b.set( u.x, l.y, l.z );
    c.set( u.x, u.y, l.z );
    d.set( l.x, u.y, u.z );
    e.set( u.x, l.y, l.z );
    f.set( l.x, u.y, l.z );
    g.set( l.x, l.y, u.z );
    h.copy(u);
};

var transformIntoFrame_corners = [
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3()
];

/**
 * Get the representation of an AABB in another frame.
 * @method toLocalFrame
 * @param  {Transform} frame
 * @param  {AABB} target
 * @return {AABB} The "target" AABB object.
 */
AABB.prototype.toLocalFrame = function(frame, target){

    var corners = transformIntoFrame_corners;
    var a = corners[0];
    var b = corners[1];
    var c = corners[2];
    var d = corners[3];
    var e = corners[4];
    var f = corners[5];
    var g = corners[6];
    var h = corners[7];

    // Get corners in current frame
    this.getCorners(a, b, c, d, e, f, g, h);

    // Transform them to new local frame
    for(var i=0; i !== 8; i++){
        var corner = corners[i];
        frame.pointToLocal(corner, corner);
    }

    return target.setFromPoints(corners);
};

/**
 * Get the representation of an AABB in the global frame.
 * @method toWorldFrame
 * @param  {Transform} frame
 * @param  {AABB} target
 * @return {AABB} The "target" AABB object.
 */
AABB.prototype.toWorldFrame = function(frame, target){

    var corners = transformIntoFrame_corners;
    var a = corners[0];
    var b = corners[1];
    var c = corners[2];
    var d = corners[3];
    var e = corners[4];
    var f = corners[5];
    var g = corners[6];
    var h = corners[7];

    // Get corners in current frame
    this.getCorners(a, b, c, d, e, f, g, h);

    // Transform them to new local frame
    for(var i=0; i !== 8; i++){
        var corner = corners[i];
        frame.pointToWorld(corner, corner);
    }

    return target.setFromPoints(corners);
};

/**
 * Check if the AABB is hit by a ray.
 * @param  {Ray} ray
 * @return {number}
 */
AABB.prototype.overlapsRay = function(ray){
    var t = 0;

    // ray.direction is unit direction vector of ray
    var dirFracX = 1 / ray._direction.x;
    var dirFracY = 1 / ray._direction.y;
    var dirFracZ = 1 / ray._direction.z;

    // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner
    var t1 = (this.lowerBound.x - ray.from.x) * dirFracX;
    var t2 = (this.upperBound.x - ray.from.x) * dirFracX;
    var t3 = (this.lowerBound.y - ray.from.y) * dirFracY;
    var t4 = (this.upperBound.y - ray.from.y) * dirFracY;
    var t5 = (this.lowerBound.z - ray.from.z) * dirFracZ;
    var t6 = (this.upperBound.z - ray.from.z) * dirFracZ;

    // var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
    // var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));
    var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
    var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

    // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us
    if (tmax < 0){
        //t = tmax;
        return false;
    }

    // if tmin > tmax, ray doesn't intersect AABB
    if (tmin > tmax){
        //t = tmax;
        return false;
    }

    return true;
};
},{"../math/Vec3":33,"../utils/Utils":56}],7:[function(require,module,exports){
module.exports = ArrayCollisionMatrix;

/**
 * Collision "matrix". It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
 * @class ArrayCollisionMatrix
 * @constructor
 */
function ArrayCollisionMatrix() {

    /**
     * The matrix storage
     * @property matrix
     * @type {Array}
     */
	this.matrix = [];
}

/**
 * Get an element
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
ArrayCollisionMatrix.prototype.get = function(i, j) {
	i = i.index;
	j = j.index;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
    }
	return this.matrix[(i*(i + 1)>>1) + j-1];
};

/**
 * Set an element
 * @method set
 * @param {Number} i
 * @param {Number} j
 * @param {Number} value
 */
ArrayCollisionMatrix.prototype.set = function(i, j, value) {
	i = i.index;
	j = j.index;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
    }
	this.matrix[(i*(i + 1)>>1) + j-1] = value ? 1 : 0;
};

/**
 * Sets all elements to zero
 * @method reset
 */
ArrayCollisionMatrix.prototype.reset = function() {
	for (var i=0, l=this.matrix.length; i!==l; i++) {
		this.matrix[i]=0;
	}
};

/**
 * Sets the max number of objects
 * @method setNumObjects
 * @param {Number} n
 */
ArrayCollisionMatrix.prototype.setNumObjects = function(n) {
	this.matrix.length = n*(n-1)>>1;
};

},{}],8:[function(require,module,exports){
var Body = require('../objects/Body');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Shape = require('../shapes/Shape');
var Plane = require('../shapes/Plane');

module.exports = Broadphase;

/**
 * Base class for broadphase implementations
 * @class Broadphase
 * @constructor
 * @author schteppe
 */
function Broadphase(){
    /**
    * The world to search for collisions in.
    * @property world
    * @type {World}
    */
    this.world = null;

    /**
     * If set to true, the broadphase uses bounding boxes for intersection test, else it uses bounding spheres.
     * @property useBoundingBoxes
     * @type {Boolean}
     */
    this.useBoundingBoxes = false;

    /**
     * Set to true if the objects in the world moved.
     * @property {Boolean} dirty
     */
    this.dirty = true;
}

/**
 * Get the collision pairs from the world
 * @method collisionPairs
 * @param {World} world The world to search in
 * @param {Array} p1 Empty array to be filled with body objects
 * @param {Array} p2 Empty array to be filled with body objects
 */
Broadphase.prototype.collisionPairs = function(world,p1,p2){
    throw new Error("collisionPairs not implemented for this BroadPhase class!");
};

/**
 * Check if a body pair needs to be intersection tested at all.
 * @method needBroadphaseCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @return {bool}
 */
var Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC = Body.STATIC | Body.KINEMATIC;
Broadphase.prototype.needBroadphaseCollision = function(bodyA,bodyB){

    // Check collision filter masks
    if( (bodyA.collisionFilterGroup & bodyB.collisionFilterMask)===0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask)===0){
        return false;
    }

    // Check types
    if(((bodyA.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC)!==0 || bodyA.sleepState === Body.SLEEPING) &&
       ((bodyB.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC)!==0 || bodyB.sleepState === Body.SLEEPING)) {
        // Both bodies are static, kinematic or sleeping. Skip.
        return false;
    }

    return true;
};

/**
 * Check if the bounding volumes of two bodies intersect.
 * @method intersectionTest
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {array} pairs1
 * @param {array} pairs2
  */
Broadphase.prototype.intersectionTest = function(bodyA, bodyB, pairs1, pairs2){
    if(this.useBoundingBoxes){
        this.doBoundingBoxBroadphase(bodyA,bodyB,pairs1,pairs2);
    } else {
        this.doBoundingSphereBroadphase(bodyA,bodyB,pairs1,pairs2);
    }
};

/**
 * Check if the bounding spheres of two bodies are intersecting.
 * @method doBoundingSphereBroadphase
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Array} pairs1 bodyA is appended to this array if intersection
 * @param {Array} pairs2 bodyB is appended to this array if intersection
 */
var Broadphase_collisionPairs_r = new Vec3(), // Temp objects
    Broadphase_collisionPairs_normal =  new Vec3(),
    Broadphase_collisionPairs_quat =  new Quaternion(),
    Broadphase_collisionPairs_relpos  =  new Vec3();
Broadphase.prototype.doBoundingSphereBroadphase = function(bodyA,bodyB,pairs1,pairs2){
    var r = Broadphase_collisionPairs_r;
    bodyB.position.vsub(bodyA.position,r);
    var boundingRadiusSum2 = Math.pow(bodyA.boundingRadius + bodyB.boundingRadius, 2);
    var norm2 = r.norm2();
    if(norm2 < boundingRadiusSum2){
        pairs1.push(bodyA);
        pairs2.push(bodyB);
    }
};

/**
 * Check if the bounding boxes of two bodies are intersecting.
 * @method doBoundingBoxBroadphase
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
Broadphase.prototype.doBoundingBoxBroadphase = function(bodyA,bodyB,pairs1,pairs2){
    if(bodyA.aabbNeedsUpdate){
        bodyA.computeAABB();
    }
    if(bodyB.aabbNeedsUpdate){
        bodyB.computeAABB();
    }

    // Check AABB / AABB
    if(bodyA.aabb.overlaps(bodyB.aabb)){
        pairs1.push(bodyA);
        pairs2.push(bodyB);
    }
};

/**
 * Removes duplicate pairs from the pair arrays.
 * @method makePairsUnique
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
var Broadphase_makePairsUnique_temp = { keys:[] },
    Broadphase_makePairsUnique_p1 = [],
    Broadphase_makePairsUnique_p2 = [];
Broadphase.prototype.makePairsUnique = function(pairs1,pairs2){
    var t = Broadphase_makePairsUnique_temp,
        p1 = Broadphase_makePairsUnique_p1,
        p2 = Broadphase_makePairsUnique_p2,
        N = pairs1.length;

    for(var i=0; i!==N; i++){
        p1[i] = pairs1[i];
        p2[i] = pairs2[i];
    }

    pairs1.length = 0;
    pairs2.length = 0;

    for(var i=0; i!==N; i++){
        var id1 = p1[i].id,
            id2 = p2[i].id;
        var key = id1 < id2 ? id1+","+id2 :  id2+","+id1;
        t[key] = i;
        t.keys.push(key);
    }

    for(var i=0; i!==t.keys.length; i++){
        var key = t.keys.pop(),
            pairIndex = t[key];
        pairs1.push(p1[pairIndex]);
        pairs2.push(p2[pairIndex]);
        delete t[key];
    }
};

/**
 * To be implemented by subcasses
 * @method setWorld
 * @param {World} world
 */
Broadphase.prototype.setWorld = function(world){
};

/**
 * Check if the bounding spheres of two bodies overlap.
 * @method boundingSphereCheck
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @return {boolean}
 */
var bsc_dist = new Vec3();
Broadphase.boundingSphereCheck = function(bodyA,bodyB){
    var dist = bsc_dist;
    bodyA.position.vsub(bodyB.position,dist);
    return Math.pow(bodyA.shape.boundingSphereRadius + bodyB.shape.boundingSphereRadius,2) > dist.norm2();
};

/**
 * Returns all the bodies within the AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param  {array} result An array to store resulting bodies in.
 * @return {array}
 */
Broadphase.prototype.aabbQuery = function(world, aabb, result){
    console.warn('.aabbQuery is not implemented in this Broadphase subclass.');
    return [];
};
},{"../math/Quaternion":31,"../math/Vec3":33,"../objects/Body":34,"../shapes/Plane":45,"../shapes/Shape":46}],9:[function(require,module,exports){
module.exports = GridBroadphase;

var Broadphase = require('./Broadphase');
var Vec3 = require('../math/Vec3');
var Shape = require('../shapes/Shape');

/**
 * Axis aligned uniform grid broadphase.
 * @class GridBroadphase
 * @constructor
 * @extends Broadphase
 * @todo Needs support for more than just planes and spheres.
 * @param {Vec3} aabbMin
 * @param {Vec3} aabbMax
 * @param {Number} nx Number of boxes along x
 * @param {Number} ny Number of boxes along y
 * @param {Number} nz Number of boxes along z
 */
function GridBroadphase(aabbMin,aabbMax,nx,ny,nz){
    Broadphase.apply(this);
    this.nx = nx || 10;
    this.ny = ny || 10;
    this.nz = nz || 10;
    this.aabbMin = aabbMin || new Vec3(100,100,100);
    this.aabbMax = aabbMax || new Vec3(-100,-100,-100);
	var nbins = this.nx * this.ny * this.nz;
	if (nbins <= 0) {
		throw "GridBroadphase: Each dimension's n must be >0";
	}
    this.bins = [];
	this.binLengths = []; //Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow
	this.bins.length = nbins;
	this.binLengths.length = nbins;
	for (var i=0;i<nbins;i++) {
		this.bins[i]=[];
		this.binLengths[i]=0;
	}
}
GridBroadphase.prototype = new Broadphase();
GridBroadphase.prototype.constructor = GridBroadphase;

/**
 * Get all the collision pairs in the physics world
 * @method collisionPairs
 * @param {World} world
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
var GridBroadphase_collisionPairs_d = new Vec3();
var GridBroadphase_collisionPairs_binPos = new Vec3();
GridBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){
    var N = world.numObjects(),
        bodies = world.bodies;

    var max = this.aabbMax,
        min = this.aabbMin,
        nx = this.nx,
        ny = this.ny,
        nz = this.nz;

	var xstep = ny*nz;
	var ystep = nz;
	var zstep = 1;

    var xmax = max.x,
        ymax = max.y,
        zmax = max.z,
        xmin = min.x,
        ymin = min.y,
        zmin = min.z;

    var xmult = nx / (xmax-xmin),
        ymult = ny / (ymax-ymin),
        zmult = nz / (zmax-zmin);

    var binsizeX = (xmax - xmin) / nx,
        binsizeY = (ymax - ymin) / ny,
        binsizeZ = (zmax - zmin) / nz;

	var binRadius = Math.sqrt(binsizeX*binsizeX + binsizeY*binsizeY + binsizeZ*binsizeZ) * 0.5;

    var types = Shape.types;
    var SPHERE =            types.SPHERE,
        PLANE =             types.PLANE,
        BOX =               types.BOX,
        COMPOUND =          types.COMPOUND,
        CONVEXPOLYHEDRON =  types.CONVEXPOLYHEDRON;

    var bins=this.bins,
		binLengths=this.binLengths,
        Nbins=this.bins.length;

    // Reset bins
    for(var i=0; i!==Nbins; i++){
        binLengths[i] = 0;
    }

    var ceil = Math.ceil;
	var min = Math.min;
	var max = Math.max;

	function addBoxToBins(x0,y0,z0,x1,y1,z1,bi) {
		var xoff0 = ((x0 - xmin) * xmult)|0,
			yoff0 = ((y0 - ymin) * ymult)|0,
			zoff0 = ((z0 - zmin) * zmult)|0,
			xoff1 = ceil((x1 - xmin) * xmult),
			yoff1 = ceil((y1 - ymin) * ymult),
			zoff1 = ceil((z1 - zmin) * zmult);

		if (xoff0 < 0) { xoff0 = 0; } else if (xoff0 >= nx) { xoff0 = nx - 1; }
		if (yoff0 < 0) { yoff0 = 0; } else if (yoff0 >= ny) { yoff0 = ny - 1; }
		if (zoff0 < 0) { zoff0 = 0; } else if (zoff0 >= nz) { zoff0 = nz - 1; }
		if (xoff1 < 0) { xoff1 = 0; } else if (xoff1 >= nx) { xoff1 = nx - 1; }
		if (yoff1 < 0) { yoff1 = 0; } else if (yoff1 >= ny) { yoff1 = ny - 1; }
		if (zoff1 < 0) { zoff1 = 0; } else if (zoff1 >= nz) { zoff1 = nz - 1; }

		xoff0 *= xstep;
		yoff0 *= ystep;
		zoff0 *= zstep;
		xoff1 *= xstep;
		yoff1 *= ystep;
		zoff1 *= zstep;

		for (var xoff = xoff0; xoff <= xoff1; xoff += xstep) {
			for (var yoff = yoff0; yoff <= yoff1; yoff += ystep) {
				for (var zoff = zoff0; zoff <= zoff1; zoff += zstep) {
					var idx = xoff+yoff+zoff;
					bins[idx][binLengths[idx]++] = bi;
				}
			}
		}
	}

    // Put all bodies into the bins
    for(var i=0; i!==N; i++){
        var bi = bodies[i];
        var si = bi.shape;

        switch(si.type){
        case SPHERE:
            // Put in bin
            // check if overlap with other bins
            var x = bi.position.x,
                y = bi.position.y,
                z = bi.position.z;
            var r = si.radius;

			addBoxToBins(x-r, y-r, z-r, x+r, y+r, z+r, bi);
            break;

        case PLANE:
            if(si.worldNormalNeedsUpdate){
                si.computeWorldNormal(bi.quaternion);
            }
            var planeNormal = si.worldNormal;

			//Relative position from origin of plane object to the first bin
			//Incremented as we iterate through the bins
			var xreset = xmin + binsizeX*0.5 - bi.position.x,
				yreset = ymin + binsizeY*0.5 - bi.position.y,
				zreset = zmin + binsizeZ*0.5 - bi.position.z;

            var d = GridBroadphase_collisionPairs_d;
			d.set(xreset, yreset, zreset);

			for (var xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {
				for (var yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {
					for (var zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {
						if (d.dot(planeNormal) < binRadius) {
							var idx = xoff + yoff + zoff;
							bins[idx][binLengths[idx]++] = bi;
						}
					}
				}
			}
            break;

        default:
			if (bi.aabbNeedsUpdate) {
				bi.computeAABB();
			}

			addBoxToBins(
				bi.aabb.lowerBound.x,
				bi.aabb.lowerBound.y,
				bi.aabb.lowerBound.z,
				bi.aabb.upperBound.x,
				bi.aabb.upperBound.y,
				bi.aabb.upperBound.z,
				bi);
            break;
        }
    }

    // Check each bin
    for(var i=0; i!==Nbins; i++){
		var binLength = binLengths[i];
		//Skip bins with no potential collisions
		if (binLength > 1) {
			var bin = bins[i];

			// Do N^2 broadphase inside
			for(var xi=0; xi!==binLength; xi++){
				var bi = bin[xi];
				for(var yi=0; yi!==xi; yi++){
					var bj = bin[yi];
					if(this.needBroadphaseCollision(bi,bj)){
						this.intersectionTest(bi,bj,pairs1,pairs2);
					}
				}
			}
		}
    }

//	for (var zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {
//		console.log("layer "+zi);
//		for (var yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {
//			var row = '';
//			for (var xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {
//				var idx = xoff + yoff + zoff;
//				row += ' ' + binLengths[idx];
//			}
//			console.log(row);
//		}
//	}

    this.makePairsUnique(pairs1,pairs2);
};

},{"../math/Vec3":33,"../shapes/Shape":46,"./Broadphase":8}],10:[function(require,module,exports){
module.exports = NaiveBroadphase;

var Broadphase = require('./Broadphase');
var AABB = require('./AABB');

/**
 * Naive broadphase implementation, used in lack of better ones.
 * @class NaiveBroadphase
 * @constructor
 * @description The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)
 * @extends Broadphase
 */
function NaiveBroadphase(){
    Broadphase.apply(this);
}
NaiveBroadphase.prototype = new Broadphase();
NaiveBroadphase.prototype.constructor = NaiveBroadphase;

/**
 * Get all the collision pairs in the physics world
 * @method collisionPairs
 * @param {World} world
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
NaiveBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){
    var bodies = world.bodies,
        n = bodies.length,
        i,j,bi,bj;

    // Naive N^2 ftw!
    for(i=0; i!==n; i++){
        for(j=0; j!==i; j++){

            bi = bodies[i];
            bj = bodies[j];

            if(!this.needBroadphaseCollision(bi,bj)){
                continue;
            }

            this.intersectionTest(bi,bj,pairs1,pairs2);
        }
    }
};

var tmpAABB = new AABB();

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    for(var i = 0; i < world.bodies.length; i++){
        var b = world.bodies[i];

        if(b.aabbNeedsUpdate){
            b.computeAABB();
        }

        // Ugly hack until Body gets aabb
        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"./AABB":6,"./Broadphase":8}],11:[function(require,module,exports){
module.exports = ObjectCollisionMatrix;

/**
 * Records what objects are colliding with each other
 * @class ObjectCollisionMatrix
 * @constructor
 */
function ObjectCollisionMatrix() {

    /**
     * The matrix storage
     * @property matrix
     * @type {Object}
     */
	this.matrix = {};
}

/**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
ObjectCollisionMatrix.prototype.get = function(i, j) {
	i = i.id;
	j = j.id;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
    }
	return i+'-'+j in this.matrix;
};

/**
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */
ObjectCollisionMatrix.prototype.set = function(i, j, value) {
	i = i.id;
	j = j.id;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
	}
	if (value) {
		this.matrix[i+'-'+j] = true;
	}
	else {
		delete this.matrix[i+'-'+j];
	}
};

/**
 * Empty the matrix
 * @method reset
 */
ObjectCollisionMatrix.prototype.reset = function() {
	this.matrix = {};
};

/**
 * Set max number of objects
 * @method setNumObjects
 * @param {Number} n
 */
ObjectCollisionMatrix.prototype.setNumObjects = function(n) {
};

},{}],12:[function(require,module,exports){
module.exports = Ray;

var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Transform = require('../math/Transform');
var ConvexPolyhedron = require('../shapes/ConvexPolyhedron');
var Box = require('../shapes/Box');
var RaycastResult = require('../collision/RaycastResult');
var Shape = require('../shapes/Shape');
var AABB = require('../collision/AABB');

/**
 * A line in 3D space that intersects bodies and return points.
 * @class Ray
 * @constructor
 * @param {Vec3} from
 * @param {Vec3} to
 */
function Ray(from, to){
    /**
     * @property {Vec3} from
     */
    this.from = from ? from.clone() : new Vec3();

    /**
     * @property {Vec3} to
     */
    this.to = to ? to.clone() : new Vec3();

    /**
     * @private
     * @property {Vec3} _direction
     */
    this._direction = new Vec3();

    /**
     * The precision of the ray. Used when checking parallelity etc.
     * @property {Number} precision
     */
    this.precision = 0.0001;

    /**
     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
     * @property {Boolean} checkCollisionResponse
     */
    this.checkCollisionResponse = true;

    /**
     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
     * @property {Boolean} skipBackfaces
     */
    this.skipBackfaces = false;

    /**
     * @property {number} collisionFilterMask
     * @default -1
     */
    this.collisionFilterMask = -1;

    /**
     * @property {number} collisionFilterGroup
     * @default -1
     */
    this.collisionFilterGroup = -1;

    /**
     * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
     * @property {number} mode
     */
    this.mode = Ray.ANY;

    /**
     * Current result object.
     * @property {RaycastResult} result
     */
    this.result = new RaycastResult();

    /**
     * Will be set to true during intersectWorld() if the ray hit anything.
     * @property {Boolean} hasHit
     */
    this.hasHit = false;

    /**
     * Current, user-provided result callback. Will be used if mode is Ray.ALL.
     * @property {Function} callback
     */
    this.callback = function(result){};
}
Ray.prototype.constructor = Ray;

Ray.CLOSEST = 1;
Ray.ANY = 2;
Ray.ALL = 4;

var tmpAABB = new AABB();
var tmpArray = [];

/**
 * Do itersection against all bodies in the given World.
 * @method intersectWorld
 * @param  {World} world
 * @param  {object} options
 * @return {Boolean} True if the ray hit anything, otherwise false.
 */
Ray.prototype.intersectWorld = function (world, options) {
    this.mode = options.mode || Ray.ANY;
    this.result = options.result || new RaycastResult();
    this.skipBackfaces = !!options.skipBackfaces;
    this.collisionFilterMask = typeof(options.collisionFilterMask) !== 'undefined' ? options.collisionFilterMask : -1;
    this.collisionFilterGroup = typeof(options.collisionFilterGroup) !== 'undefined' ? options.collisionFilterGroup : -1;
    if(options.from){
        this.from.copy(options.from);
    }
    if(options.to){
        this.to.copy(options.to);
    }
    this.callback = options.callback || function(){};
    this.hasHit = false;

    this.result.reset();
    this._updateDirection();

    this.getAABB(tmpAABB);
    tmpArray.length = 0;
    world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
    this.intersectBodies(tmpArray);

    return this.hasHit;
};

var v1 = new Vec3(),
    v2 = new Vec3();

/*
 * As per "Barycentric Technique" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division
 */
Ray.pointInTriangle = pointInTriangle;
function pointInTriangle(p, a, b, c) {
    c.vsub(a,v0);
    b.vsub(a,v1);
    p.vsub(a,v2);

    var dot00 = v0.dot( v0 );
    var dot01 = v0.dot( v1 );
    var dot02 = v0.dot( v2 );
    var dot11 = v1.dot( v1 );
    var dot12 = v1.dot( v2 );

    var u,v;

    return  ( (u = dot11 * dot02 - dot01 * dot12) >= 0 ) &&
            ( (v = dot00 * dot12 - dot01 * dot02) >= 0 ) &&
            ( u + v < ( dot00 * dot11 - dot01 * dot01 ) );
}

/**
 * Shoot a ray at a body, get back information about the hit.
 * @method intersectBody
 * @private
 * @param {Body} body
 * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.
 */
var intersectBody_xi = new Vec3();
var intersectBody_qi = new Quaternion();
Ray.prototype.intersectBody = function (body, result) {
    if(result){
        this.result = result;
        this._updateDirection();
    }
    var checkCollisionResponse = this.checkCollisionResponse;

    if(checkCollisionResponse && !body.collisionResponse){
        return;
    }

    if((this.collisionFilterGroup & body.collisionFilterMask)===0 || (body.collisionFilterGroup & this.collisionFilterMask)===0){
        return;
    }

    var xi = intersectBody_xi;
    var qi = intersectBody_qi;

    for (var i = 0, N = body.shapes.length; i < N; i++) {
        var shape = body.shapes[i];

        if(checkCollisionResponse && !shape.collisionResponse){
            continue; // Skip
        }

        body.quaternion.mult(body.shapeOrientations[i], qi);
        body.quaternion.vmult(body.shapeOffsets[i], xi);
        xi.vadd(body.position, xi);

        this.intersectShape(
            shape,
            qi,
            xi,
            body
        );

        if(this.result._shouldStop){
            break;
        }
    }
};

/**
 * @method intersectBodies
 * @param {Array} bodies An array of Body objects.
 * @param {RaycastResult} [result] Deprecated
 */
Ray.prototype.intersectBodies = function (bodies, result) {
    if(result){
        this.result = result;
        this._updateDirection();
    }

    for ( var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i ++ ) {
        this.intersectBody(bodies[i]);
    }
};

/**
 * Updates the _direction vector.
 * @private
 * @method _updateDirection
 */
Ray.prototype._updateDirection = function(){
    this.to.vsub(this.from, this._direction);
    this._direction.normalize();
};

/**
 * @method intersectShape
 * @private
 * @param {Shape} shape
 * @param {Quaternion} quat
 * @param {Vec3} position
 * @param {Body} body
 */
Ray.prototype.intersectShape = function(shape, quat, position, body){
    var from = this.from;


    // Checking boundingSphere
    var distance = distanceFromIntersection(from, this._direction, position);
    if ( distance > shape.boundingSphereRadius ) {
        return;
    }

    var intersectMethod = this[shape.type];
    if(intersectMethod){
        intersectMethod.call(this, shape, quat, position, body, shape);
    }
};

var vector = new Vec3();
var normal = new Vec3();
var intersectPoint = new Vec3();

var a = new Vec3();
var b = new Vec3();
var c = new Vec3();
var d = new Vec3();

var tmpRaycastResult = new RaycastResult();

/**
 * @method intersectBox
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectBox = function(shape, quat, position, body, reportedShape){
    return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body, reportedShape);
};
Ray.prototype[Shape.types.BOX] = Ray.prototype.intersectBox;

/**
 * @method intersectPlane
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectPlane = function(shape, quat, position, body, reportedShape){
    var from = this.from;
    var to = this.to;
    var direction = this._direction;

    // Get plane normal
    var worldNormal = new Vec3(0, 0, 1);
    quat.vmult(worldNormal, worldNormal);

    var len = new Vec3();
    from.vsub(position, len);
    var planeToFrom = len.dot(worldNormal);
    to.vsub(position, len);
    var planeToTo = len.dot(worldNormal);

    if(planeToFrom * planeToTo > 0){
        // "from" and "to" are on the same side of the plane... bail out
        return;
    }

    if(from.distanceTo(to) < planeToFrom){
        return;
    }

    var n_dot_dir = worldNormal.dot(direction);

    if (Math.abs(n_dot_dir) < this.precision) {
        // No intersection
        return;
    }

    var planePointToFrom = new Vec3();
    var dir_scaled_with_t = new Vec3();
    var hitPointWorld = new Vec3();

    from.vsub(position, planePointToFrom);
    var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
    direction.scale(t, dir_scaled_with_t);
    from.vadd(dir_scaled_with_t, hitPointWorld);

    this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);
};
Ray.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane;

/**
 * Get the world AABB of the ray.
 * @method getAABB
 * @param  {AABB} aabb
 */
Ray.prototype.getAABB = function(result){
    var to = this.to;
    var from = this.from;
    result.lowerBound.x = Math.min(to.x, from.x);
    result.lowerBound.y = Math.min(to.y, from.y);
    result.lowerBound.z = Math.min(to.z, from.z);
    result.upperBound.x = Math.max(to.x, from.x);
    result.upperBound.y = Math.max(to.y, from.y);
    result.upperBound.z = Math.max(to.z, from.z);
};

var intersectConvexOptions = {
    faceList: [0]
};
var worldPillarOffset = new Vec3();
var intersectHeightfield_localRay = new Ray();
var intersectHeightfield_index = [];
var intersectHeightfield_minMax = [];

/**
 * @method intersectHeightfield
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectHeightfield = function(shape, quat, position, body, reportedShape){
    var data = shape.data,
        w = shape.elementSize;

    // Convert the ray to local heightfield coordinates
    var localRay = intersectHeightfield_localRay; //new Ray(this.from, this.to);
    localRay.from.copy(this.from);
    localRay.to.copy(this.to);
    Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
    Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);
    localRay._updateDirection();

    // Get the index of the data points to test against
    var index = intersectHeightfield_index;
    var iMinX, iMinY, iMaxX, iMaxY;

    // Set to max
    iMinX = iMinY = 0;
    iMaxX = iMaxY = shape.data.length - 1;

    var aabb = new AABB();
    localRay.getAABB(aabb);

    shape.getIndexOfPosition(aabb.lowerBound.x, aabb.lowerBound.y, index, true);
    iMinX = Math.max(iMinX, index[0]);
    iMinY = Math.max(iMinY, index[1]);
    shape.getIndexOfPosition(aabb.upperBound.x, aabb.upperBound.y, index, true);
    iMaxX = Math.min(iMaxX, index[0] + 1);
    iMaxY = Math.min(iMaxY, index[1] + 1);

    for(var i = iMinX; i < iMaxX; i++){
        for(var j = iMinY; j < iMaxY; j++){

            if(this.result._shouldStop){
                return;
            }

            shape.getAabbAtIndex(i, j, aabb);
            if(!aabb.overlapsRay(localRay)){
                continue;
            }

            // Lower triangle
            shape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);

            if(this.result._shouldStop){
                return;
            }

            // Upper triangle
            shape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);
        }
    }
};
Ray.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;

var Ray_intersectSphere_intersectionPoint = new Vec3();
var Ray_intersectSphere_normal = new Vec3();

/**
 * @method intersectSphere
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectSphere = function(shape, quat, position, body, reportedShape){
    var from = this.from,
        to = this.to,
        r = shape.radius;

    var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);
    var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
    var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);

    var delta = Math.pow(b, 2) - 4 * a * c;

    var intersectionPoint = Ray_intersectSphere_intersectionPoint;
    var normal = Ray_intersectSphere_normal;

    if(delta < 0){
        // No intersection
        return;

    } else if(delta === 0){
        // single intersection point
        from.lerp(to, delta, intersectionPoint);

        intersectionPoint.vsub(position, normal);
        normal.normalize();

        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);

    } else {
        var d1 = (- b - Math.sqrt(delta)) / (2 * a);
        var d2 = (- b + Math.sqrt(delta)) / (2 * a);

        if(d1 >= 0 && d1 <= 1){
            from.lerp(to, d1, intersectionPoint);
            intersectionPoint.vsub(position, normal);
            normal.normalize();
            this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
        }

        if(this.result._shouldStop){
            return;
        }

        if(d2 >= 0 && d2 <= 1){
            from.lerp(to, d2, intersectionPoint);
            intersectionPoint.vsub(position, normal);
            normal.normalize();
            this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
        }
    }
};
Ray.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;


var intersectConvex_normal = new Vec3();
var intersectConvex_minDistNormal = new Vec3();
var intersectConvex_minDistIntersect = new Vec3();
var intersectConvex_vector = new Vec3();

/**
 * @method intersectConvex
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 * @param {object} [options]
 * @param {array} [options.faceList]
 */
Ray.prototype.intersectConvex = function intersectConvex(
    shape,
    quat,
    position,
    body,
    reportedShape,
    options
){
    var minDistNormal = intersectConvex_minDistNormal;
    var normal = intersectConvex_normal;
    var vector = intersectConvex_vector;
    var minDistIntersect = intersectConvex_minDistIntersect;
    var faceList = (options && options.faceList) || null;

    // Checking faces
    var faces = shape.faces,
        vertices = shape.vertices,
        normals = shape.faceNormals;
    var direction = this._direction;

    var from = this.from;
    var to = this.to;
    var fromToDistance = from.distanceTo(to);

    var minDist = -1;
    var Nfaces = faceList ? faceList.length : faces.length;
    var result = this.result;

    for (var j = 0; !result._shouldStop && j < Nfaces; j++) {
        var fi = faceList ? faceList[j] : j;

        var face = faces[fi];
        var faceNormal = normals[fi];
        var q = quat;
        var x = position;

        // determine if ray intersects the plane of the face
        // note: this works regardless of the direction of the face normal

        // Get plane point in world coordinates...
        vector.copy(vertices[face[0]]);
        q.vmult(vector,vector);
        vector.vadd(x,vector);

        // ...but make it relative to the ray from. We'll fix this later.
        vector.vsub(from,vector);

        // Get plane normal
        q.vmult(faceNormal,normal);

        // If this dot product is negative, we have something interesting
        var dot = direction.dot(normal);

        // Bail out if ray and plane are parallel
        if ( Math.abs( dot ) < this.precision ){
            continue;
        }

        // calc distance to plane
        var scalar = normal.dot(vector) / dot;

        // if negative distance, then plane is behind ray
        if (scalar < 0){
            continue;
        }

        // if (dot < 0) {

        // Intersection point is from + direction * scalar
        direction.mult(scalar,intersectPoint);
        intersectPoint.vadd(from,intersectPoint);

        // a is the point we compare points b and c with.
        a.copy(vertices[face[0]]);
        q.vmult(a,a);
        x.vadd(a,a);

        for(var i = 1; !result._shouldStop && i < face.length - 1; i++){
            // Transform 3 vertices to world coords
            b.copy(vertices[face[i]]);
            c.copy(vertices[face[i+1]]);
            q.vmult(b,b);
            q.vmult(c,c);
            x.vadd(b,b);
            x.vadd(c,c);

            var distance = intersectPoint.distanceTo(from);

            if(!(pointInTriangle(intersectPoint, a, b, c) || pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance){
                continue;
            }

            this.reportIntersection(normal, intersectPoint, reportedShape, body, fi);
        }
        // }
    }
};
Ray.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;

var intersectTrimesh_normal = new Vec3();
var intersectTrimesh_localDirection = new Vec3();
var intersectTrimesh_localFrom = new Vec3();
var intersectTrimesh_localTo = new Vec3();
var intersectTrimesh_worldNormal = new Vec3();
var intersectTrimesh_worldIntersectPoint = new Vec3();
var intersectTrimesh_localAABB = new AABB();
var intersectTrimesh_triangles = [];
var intersectTrimesh_treeTransform = new Transform();

/**
 * @method intersectTrimesh
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 * @param {object} [options]
 * @todo Optimize by transforming the world to local space first.
 * @todo Use Octree lookup
 */
Ray.prototype.intersectTrimesh = function intersectTrimesh(
    mesh,
    quat,
    position,
    body,
    reportedShape,
    options
){
    var normal = intersectTrimesh_normal;
    var triangles = intersectTrimesh_triangles;
    var treeTransform = intersectTrimesh_treeTransform;
    var minDistNormal = intersectConvex_minDistNormal;
    var vector = intersectConvex_vector;
    var minDistIntersect = intersectConvex_minDistIntersect;
    var localAABB = intersectTrimesh_localAABB;
    var localDirection = intersectTrimesh_localDirection;
    var localFrom = intersectTrimesh_localFrom;
    var localTo = intersectTrimesh_localTo;
    var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
    var worldNormal = intersectTrimesh_worldNormal;
    var faceList = (options && options.faceList) || null;

    // Checking faces
    var indices = mesh.indices,
        vertices = mesh.vertices,
        normals = mesh.faceNormals;

    var from = this.from;
    var to = this.to;
    var direction = this._direction;

    var minDist = -1;
    treeTransform.position.copy(position);
    treeTransform.quaternion.copy(quat);

    // Transform ray to local space!
    Transform.vectorToLocalFrame(position, quat, direction, localDirection);
    Transform.pointToLocalFrame(position, quat, from, localFrom);
    Transform.pointToLocalFrame(position, quat, to, localTo);

    localTo.x *= mesh.scale.x;
    localTo.y *= mesh.scale.y;
    localTo.z *= mesh.scale.z;
    localFrom.x *= mesh.scale.x;
    localFrom.y *= mesh.scale.y;
    localFrom.z *= mesh.scale.z;

    localTo.vsub(localFrom, localDirection);
    localDirection.normalize();

    var fromToDistanceSquared = localFrom.distanceSquared(localTo);

    mesh.tree.rayQuery(this, treeTransform, triangles);

    for (var i = 0, N = triangles.length; !this.result._shouldStop && i !== N; i++) {
        var trianglesIndex = triangles[i];

        mesh.getNormal(trianglesIndex, normal);

        // determine if ray intersects the plane of the face
        // note: this works regardless of the direction of the face normal

        // Get plane point in world coordinates...
        mesh.getVertex(indices[trianglesIndex * 3], a);

        // ...but make it relative to the ray from. We'll fix this later.
        a.vsub(localFrom,vector);

        // If this dot product is negative, we have something interesting
        var dot = localDirection.dot(normal);

        // Bail out if ray and plane are parallel
        // if (Math.abs( dot ) < this.precision){
        //     continue;
        // }

        // calc distance to plane
        var scalar = normal.dot(vector) / dot;

        // if negative distance, then plane is behind ray
        if (scalar < 0){
            continue;
        }

        // Intersection point is from + direction * scalar
        localDirection.scale(scalar,intersectPoint);
        intersectPoint.vadd(localFrom,intersectPoint);

        // Get triangle vertices
        mesh.getVertex(indices[trianglesIndex * 3 + 1], b);
        mesh.getVertex(indices[trianglesIndex * 3 + 2], c);

        var squaredDistance = intersectPoint.distanceSquared(localFrom);

        if(!(pointInTriangle(intersectPoint, b, a, c) || pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared){
            continue;
        }

        // transform intersectpoint and normal to world
        Transform.vectorToWorldFrame(quat, normal, worldNormal);
        Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
        this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);
    }
    triangles.length = 0;
};
Ray.prototype[Shape.types.TRIMESH] = Ray.prototype.intersectTrimesh;


/**
 * @method reportIntersection
 * @private
 * @param  {Vec3} normal
 * @param  {Vec3} hitPointWorld
 * @param  {Shape} shape
 * @param  {Body} body
 * @return {boolean} True if the intersections should continue
 */
Ray.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, hitFaceIndex){
    var from = this.from;
    var to = this.to;
    var distance = from.distanceTo(hitPointWorld);
    var result = this.result;

    // Skip back faces?
    if(this.skipBackfaces && normal.dot(this._direction) > 0){
        return;
    }

    result.hitFaceIndex = typeof(hitFaceIndex) !== 'undefined' ? hitFaceIndex : -1;

    switch(this.mode){
    case Ray.ALL:
        this.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result.hasHit = true;
        this.callback(result);
        break;

    case Ray.CLOSEST:

        // Store if closer than current closest
        if(distance < result.distance || !result.hasHit){
            this.hasHit = true;
            result.hasHit = true;
            result.set(
                from,
                to,
                normal,
                hitPointWorld,
                shape,
                body,
                distance
            );
        }
        break;

    case Ray.ANY:

        // Report and stop.
        this.hasHit = true;
        result.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result._shouldStop = true;
        break;
    }
};

var v0 = new Vec3(),
    intersect = new Vec3();
function distanceFromIntersection(from, direction, position) {

    // v0 is vector from from to position
    position.vsub(from,v0);
    var dot = v0.dot(direction);

    // intersect = direction*dot + from
    direction.mult(dot,intersect);
    intersect.vadd(from,intersect);

    var distance = position.distanceTo(intersect);

    return distance;
}


},{"../collision/AABB":6,"../collision/RaycastResult":13,"../math/Quaternion":31,"../math/Transform":32,"../math/Vec3":33,"../shapes/Box":40,"../shapes/ConvexPolyhedron":41,"../shapes/Shape":46}],13:[function(require,module,exports){
var Vec3 = require('../math/Vec3');

module.exports = RaycastResult;

/**
 * Storage for Ray casting data.
 * @class RaycastResult
 * @constructor
 */
function RaycastResult(){

	/**
	 * @property {Vec3} rayFromWorld
	 */
	this.rayFromWorld = new Vec3();

	/**
	 * @property {Vec3} rayToWorld
	 */
	this.rayToWorld = new Vec3();

	/**
	 * @property {Vec3} hitNormalWorld
	 */
	this.hitNormalWorld = new Vec3();

	/**
	 * @property {Vec3} hitPointWorld
	 */
	this.hitPointWorld = new Vec3();

	/**
	 * @property {boolean} hasHit
	 */
	this.hasHit = false;

	/**
	 * The hit shape, or null.
	 * @property {Shape} shape
	 */
	this.shape = null;

	/**
	 * The hit body, or null.
	 * @property {Body} body
	 */
	this.body = null;

	/**
	 * The index of the hit triangle, if the hit shape was a trimesh.
	 * @property {number} hitFaceIndex
	 * @default -1
	 */
	this.hitFaceIndex = -1;

	/**
	 * Distance to the hit. Will be set to -1 if there was no hit.
	 * @property {number} distance
	 * @default -1
	 */
	this.distance = -1;

	/**
	 * If the ray should stop traversing the bodies.
	 * @private
	 * @property {Boolean} _shouldStop
	 * @default false
	 */
	this._shouldStop = false;
}

/**
 * Reset all result data.
 * @method reset
 */
RaycastResult.prototype.reset = function () {
	this.rayFromWorld.setZero();
	this.rayToWorld.setZero();
	this.hitNormalWorld.setZero();
	this.hitPointWorld.setZero();
	this.hasHit = false;
	this.shape = null;
	this.body = null;
	this.hitFaceIndex = -1;
	this.distance = -1;
	this._shouldStop = false;
};

/**
 * @method abort
 */
RaycastResult.prototype.abort = function(){
	this._shouldStop = true;
};

/**
 * @method set
 * @param {Vec3} rayFromWorld
 * @param {Vec3} rayToWorld
 * @param {Vec3} hitNormalWorld
 * @param {Vec3} hitPointWorld
 * @param {Shape} shape
 * @param {Body} body
 * @param {number} distance
 */
RaycastResult.prototype.set = function(
	rayFromWorld,
	rayToWorld,
	hitNormalWorld,
	hitPointWorld,
	shape,
	body,
	distance
){
	this.rayFromWorld.copy(rayFromWorld);
	this.rayToWorld.copy(rayToWorld);
	this.hitNormalWorld.copy(hitNormalWorld);
	this.hitPointWorld.copy(hitPointWorld);
	this.shape = shape;
	this.body = body;
	this.distance = distance;
};
},{"../math/Vec3":33}],14:[function(require,module,exports){
var Shape = require('../shapes/Shape');
var Broadphase = require('../collision/Broadphase');

module.exports = SAPBroadphase;

/**
 * Sweep and prune broadphase along one axis.
 *
 * @class SAPBroadphase
 * @constructor
 * @param {World} [world]
 * @extends Broadphase
 */
function SAPBroadphase(world){
    Broadphase.apply(this);

    /**
     * List of bodies currently in the broadphase.
     * @property axisList
     * @type {Array}
     */
    this.axisList = [];

    /**
     * The world to search in.
     * @property world
     * @type {World}
     */
    this.world = null;

    /**
     * Axis to sort the bodies along. Set to 0 for x axis, and 1 for y axis. For best performance, choose an axis that the bodies are spread out more on.
     * @property axisIndex
     * @type {Number}
     */
    this.axisIndex = 0;

    var axisList = this.axisList;

    this._addBodyHandler = function(e){
        axisList.push(e.body);
    };

    this._removeBodyHandler = function(e){
        var idx = axisList.indexOf(e.body);
        if(idx !== -1){
            axisList.splice(idx,1);
        }
    };

    if(world){
        this.setWorld(world);
    }
}
SAPBroadphase.prototype = new Broadphase();

/**
 * Change the world
 * @method setWorld
 * @param  {World} world
 */
SAPBroadphase.prototype.setWorld = function(world){
    // Clear the old axis array
    this.axisList.length = 0;

    // Add all bodies from the new world
    for(var i=0; i<world.bodies.length; i++){
        this.axisList.push(world.bodies[i]);
    }

    // Remove old handlers, if any
    world.removeEventListener("addBody", this._addBodyHandler);
    world.removeEventListener("removeBody", this._removeBodyHandler);

    // Add handlers to update the list of bodies.
    world.addEventListener("addBody", this._addBodyHandler);
    world.addEventListener("removeBody", this._removeBodyHandler);

    this.world = world;
    this.dirty = true;
};

/**
 * @static
 * @method insertionSortX
 * @param  {Array} a
 * @return {Array}
 */
SAPBroadphase.insertionSortX = function(a) {
    for(var i=1,l=a.length;i<l;i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

/**
 * @static
 * @method insertionSortY
 * @param  {Array} a
 * @return {Array}
 */
SAPBroadphase.insertionSortY = function(a) {
    for(var i=1,l=a.length;i<l;i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

/**
 * @static
 * @method insertionSortZ
 * @param  {Array} a
 * @return {Array}
 */
SAPBroadphase.insertionSortZ = function(a) {
    for(var i=1,l=a.length;i<l;i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

/**
 * Collect all collision pairs
 * @method collisionPairs
 * @param  {World} world
 * @param  {Array} p1
 * @param  {Array} p2
 */
SAPBroadphase.prototype.collisionPairs = function(world,p1,p2){
    var bodies = this.axisList,
        N = bodies.length,
        axisIndex = this.axisIndex,
        i, j;

    if(this.dirty){
        this.sortList();
        this.dirty = false;
    }

    // Look through the list
    for(i=0; i !== N; i++){
        var bi = bodies[i];

        for(j=i+1; j < N; j++){
            var bj = bodies[j];

            if(!this.needBroadphaseCollision(bi,bj)){
                continue;
            }

            if(!SAPBroadphase.checkBounds(bi,bj,axisIndex)){
                break;
            }

            this.intersectionTest(bi,bj,p1,p2);
        }
    }
};

SAPBroadphase.prototype.sortList = function(){
    var axisList = this.axisList;
    var axisIndex = this.axisIndex;
    var N = axisList.length;

    // Update AABBs
    for(var i = 0; i!==N; i++){
        var bi = axisList[i];
        if(bi.aabbNeedsUpdate){
            bi.computeAABB();
        }
    }

    // Sort the list
    if(axisIndex === 0){
        SAPBroadphase.insertionSortX(axisList);
    } else if(axisIndex === 1){
        SAPBroadphase.insertionSortY(axisList);
    } else if(axisIndex === 2){
        SAPBroadphase.insertionSortZ(axisList);
    }
};

/**
 * Check if the bounds of two bodies overlap, along the given SAP axis.
 * @static
 * @method checkBounds
 * @param  {Body} bi
 * @param  {Body} bj
 * @param  {Number} axisIndex
 * @return {Boolean}
 */
SAPBroadphase.checkBounds = function(bi, bj, axisIndex){
    var biPos;
    var bjPos;

    if(axisIndex === 0){
        biPos = bi.position.x;
        bjPos = bj.position.x;
    } else if(axisIndex === 1){
        biPos = bi.position.y;
        bjPos = bj.position.y;
    } else if(axisIndex === 2){
        biPos = bi.position.z;
        bjPos = bj.position.z;
    }

    var ri = bi.boundingRadius,
        rj = bj.boundingRadius,
        boundA1 = biPos - ri,
        boundA2 = biPos + ri,
        boundB1 = bjPos - rj,
        boundB2 = bjPos + rj;

    return boundB1 < boundA2;
};

/**
 * Computes the variance of the body positions and estimates the best
 * axis to use. Will automatically set property .axisIndex.
 * @method autoDetectAxis
 */
SAPBroadphase.prototype.autoDetectAxis = function(){
    var sumX=0,
        sumX2=0,
        sumY=0,
        sumY2=0,
        sumZ=0,
        sumZ2=0,
        bodies = this.axisList,
        N = bodies.length,
        invN=1/N;

    for(var i=0; i!==N; i++){
        var b = bodies[i];

        var centerX = b.position.x;
        sumX += centerX;
        sumX2 += centerX*centerX;

        var centerY = b.position.y;
        sumY += centerY;
        sumY2 += centerY*centerY;

        var centerZ = b.position.z;
        sumZ += centerZ;
        sumZ2 += centerZ*centerZ;
    }

    var varianceX = sumX2 - sumX*sumX*invN,
        varianceY = sumY2 - sumY*sumY*invN,
        varianceZ = sumZ2 - sumZ*sumZ*invN;

    if(varianceX > varianceY){
        if(varianceX > varianceZ){
            this.axisIndex = 0;
        } else{
            this.axisIndex = 2;
        }
    } else if(varianceY > varianceZ){
        this.axisIndex = 1;
    } else{
        this.axisIndex = 2;
    }
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
SAPBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    if(this.dirty){
        this.sortList();
        this.dirty = false;
    }

    var axisIndex = this.axisIndex, axis = 'x';
    if(axisIndex === 1){ axis = 'y'; }
    if(axisIndex === 2){ axis = 'z'; }

    var axisList = this.axisList;
    var lower = aabb.lowerBound[axis];
    var upper = aabb.upperBound[axis];
    for(var i = 0; i < axisList.length; i++){
        var b = axisList[i];

        if(b.aabbNeedsUpdate){
            b.computeAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":8,"../shapes/Shape":46}],15:[function(require,module,exports){
module.exports = ConeTwistConstraint;

var Constraint = require('./Constraint');
var PointToPointConstraint = require('./PointToPointConstraint');
var ConeEquation = require('../equations/ConeEquation');
var RotationalEquation = require('../equations/RotationalEquation');
var ContactEquation = require('../equations/ContactEquation');
var Vec3 = require('../math/Vec3');

/**
 * @class ConeTwistConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Vec3} [options.pivotA]
 * @param {Vec3} [options.pivotB]
 * @param {Vec3} [options.axisA]
 * @param {Vec3} [options.axisB]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
function ConeTwistConstraint(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    // Set pivot point in between
    var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
    var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
    this.axisA = options.axisA ? options.axisA.clone() : new Vec3();
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3();

    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

    this.collideConnected = !!options.collideConnected;

    this.angle = typeof(options.angle) !== 'undefined' ? options.angle : 0;

    /**
     * @property {ConeEquation} coneEquation
     */
    var c = this.coneEquation = new ConeEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} twistEquation
     */
    var t = this.twistEquation = new RotationalEquation(bodyA,bodyB,options);
    this.twistAngle = typeof(options.twistAngle) !== 'undefined' ? options.twistAngle : 0;

    // Make the cone equation push the bodies toward the cone axis, not outward
    c.maxForce = 0;
    c.minForce = -maxForce;

    // Make the twist equation add torque toward the initial position
    t.maxForce = 0;
    t.minForce = -maxForce;

    this.equations.push(c, t);
}
ConeTwistConstraint.prototype = new PointToPointConstraint();
ConeTwistConstraint.constructor = ConeTwistConstraint;

var ConeTwistConstraint_update_tmpVec1 = new Vec3();
var ConeTwistConstraint_update_tmpVec2 = new Vec3();

ConeTwistConstraint.prototype.update = function(){
    var bodyA = this.bodyA,
        bodyB = this.bodyB,
        cone = this.coneEquation,
        twist = this.twistEquation;

    PointToPointConstraint.prototype.update.call(this);

    // Update the axes to the cone constraint
    bodyA.vectorToWorldFrame(this.axisA, cone.axisA);
    bodyB.vectorToWorldFrame(this.axisB, cone.axisB);

    // Update the world axes in the twist constraint
    this.axisA.tangents(twist.axisA, twist.axisA);
    bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);

    this.axisB.tangents(twist.axisB, twist.axisB);
    bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);

    cone.angle = this.angle;
    twist.maxAngle = this.twistAngle;
};


},{"../equations/ConeEquation":21,"../equations/ContactEquation":22,"../equations/RotationalEquation":25,"../math/Vec3":33,"./Constraint":16,"./PointToPointConstraint":20}],16:[function(require,module,exports){
module.exports = Constraint;

var Utils = require('../utils/Utils');

/**
 * Constraint base class
 * @class Constraint
 * @author schteppe
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {boolean} [options.collideConnected=true]
 * @param {boolean} [options.wakeUpBodies=true]
 */
function Constraint(bodyA, bodyB, options){
    options = Utils.defaults(options,{
        collideConnected : true,
        wakeUpBodies : true,
    });

    /**
     * Equations to be solved in this constraint
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * @property {Body} bodyA
     */
    this.bodyA = bodyA;

    /**
     * @property {Body} bodyB
     */
    this.bodyB = bodyB;

    /**
     * @property {Number} id
     */
    this.id = Constraint.idCounter++;

    /**
     * Set to true if you want the bodies to collide when they are connected.
     * @property collideConnected
     * @type {boolean}
     */
    this.collideConnected = options.collideConnected;

    if(options.wakeUpBodies){
        if(bodyA){
            bodyA.wakeUp();
        }
        if(bodyB){
            bodyB.wakeUp();
        }
    }
}

/**
 * Update all the equations with data.
 * @method update
 */
Constraint.prototype.update = function(){
    throw new Error("method update() not implmemented in this Constraint subclass!");
};

/**
 * Enables all equations in the constraint.
 * @method enable
 */
Constraint.prototype.enable = function(){
    var eqs = this.equations;
    for(var i=0; i<eqs.length; i++){
        eqs[i].enabled = true;
    }
};

/**
 * Disables all equations in the constraint.
 * @method disable
 */
Constraint.prototype.disable = function(){
    var eqs = this.equations;
    for(var i=0; i<eqs.length; i++){
        eqs[i].enabled = false;
    }
};

Constraint.idCounter = 0;

},{"../utils/Utils":56}],17:[function(require,module,exports){
module.exports = DistanceConstraint;

var Constraint = require('./Constraint');
var ContactEquation = require('../equations/ContactEquation');

/**
 * Constrains two bodies to be at a constant distance from each others center of mass.
 * @class DistanceConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} [distance] The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
 * @param {Number} [maxForce=1e6]
 * @extends Constraint
 */
function DistanceConstraint(bodyA,bodyB,distance,maxForce){
    Constraint.call(this,bodyA,bodyB);

    if(typeof(distance)==="undefined") {
        distance = bodyA.position.distanceTo(bodyB.position);
    }

    if(typeof(maxForce)==="undefined") {
        maxForce = 1e6;
    }

    /**
     * @property {number} distance
     */
    this.distance = distance;

    /**
     * @property {ContactEquation} distanceEquation
     */
    var eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);
    this.equations.push(eq);

    // Make it bidirectional
    eq.minForce = -maxForce;
    eq.maxForce =  maxForce;
}
DistanceConstraint.prototype = new Constraint();

DistanceConstraint.prototype.update = function(){
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;
    var eq = this.distanceEquation;
    var halfDist = this.distance * 0.5;
    var normal = eq.ni;

    bodyB.position.vsub(bodyA.position, normal);
    normal.normalize();
    normal.mult(halfDist, eq.ri);
    normal.mult(-halfDist, eq.rj);
};
},{"../equations/ContactEquation":22,"./Constraint":16}],18:[function(require,module,exports){
module.exports = HingeConstraint;

var Constraint = require('./Constraint');
var PointToPointConstraint = require('./PointToPointConstraint');
var RotationalEquation = require('../equations/RotationalEquation');
var RotationalMotorEquation = require('../equations/RotationalMotorEquation');
var ContactEquation = require('../equations/ContactEquation');
var Vec3 = require('../math/Vec3');

/**
 * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
 * @class HingeConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Vec3} [options.pivotA] A point defined locally in bodyA. This defines the offset of axisA.
 * @param {Vec3} [options.axisA] An axis that bodyA can rotate around, defined locally in bodyA.
 * @param {Vec3} [options.pivotB]
 * @param {Vec3} [options.axisB]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
function HingeConstraint(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;
    var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
    var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();

    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

    /**
     * Rotation axis, defined locally in bodyA.
     * @property {Vec3} axisA
     */
    var axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1,0,0);
    axisA.normalize();

    /**
     * Rotation axis, defined locally in bodyB.
     * @property {Vec3} axisB
     */
    var axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1,0,0);
    axisB.normalize();

    /**
     * @property {RotationalEquation} rotationalEquation1
     */
    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} rotationalEquation2
     */
    var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalMotorEquation} motorEquation
     */
    var motor = this.motorEquation = new RotationalMotorEquation(bodyA,bodyB,maxForce);
    motor.enabled = false; // Not enabled by default

    // Equations to be fed to the solver
    this.equations.push(
        r1, // rotational1
        r2, // rotational2
        motor
    );
}
HingeConstraint.prototype = new PointToPointConstraint();
HingeConstraint.constructor = HingeConstraint;

/**
 * @method enableMotor
 */
HingeConstraint.prototype.enableMotor = function(){
    this.motorEquation.enabled = true;
};

/**
 * @method disableMotor
 */
HingeConstraint.prototype.disableMotor = function(){
    this.motorEquation.enabled = false;
};

/**
 * @method setMotorSpeed
 * @param {number} speed
 */
HingeConstraint.prototype.setMotorSpeed = function(speed){
    this.motorEquation.targetVelocity = speed;
};

/**
 * @method setMotorMaxForce
 * @param {number} maxForce
 */
HingeConstraint.prototype.setMotorMaxForce = function(maxForce){
    this.motorEquation.maxForce = maxForce;
    this.motorEquation.minForce = -maxForce;
};

var HingeConstraint_update_tmpVec1 = new Vec3();
var HingeConstraint_update_tmpVec2 = new Vec3();

HingeConstraint.prototype.update = function(){
    var bodyA = this.bodyA,
        bodyB = this.bodyB,
        motor = this.motorEquation,
        r1 = this.rotationalEquation1,
        r2 = this.rotationalEquation2,
        worldAxisA = HingeConstraint_update_tmpVec1,
        worldAxisB = HingeConstraint_update_tmpVec2;

    var axisA = this.axisA;
    var axisB = this.axisB;

    PointToPointConstraint.prototype.update.call(this);

    // Get world axes
    bodyA.quaternion.vmult(axisA, worldAxisA);
    bodyB.quaternion.vmult(axisB, worldAxisB);

    worldAxisA.tangents(r1.axisA, r2.axisA);
    r1.axisB.copy(worldAxisB);
    r2.axisB.copy(worldAxisB);

    if(this.motorEquation.enabled){
        bodyA.quaternion.vmult(this.axisA, motor.axisA);
        bodyB.quaternion.vmult(this.axisB, motor.axisB);
    }
};


},{"../equations/ContactEquation":22,"../equations/RotationalEquation":25,"../equations/RotationalMotorEquation":26,"../math/Vec3":33,"./Constraint":16,"./PointToPointConstraint":20}],19:[function(require,module,exports){
module.exports = LockConstraint;

var Constraint = require('./Constraint');
var PointToPointConstraint = require('./PointToPointConstraint');
var RotationalEquation = require('../equations/RotationalEquation');
var RotationalMotorEquation = require('../equations/RotationalMotorEquation');
var ContactEquation = require('../equations/ContactEquation');
var Vec3 = require('../math/Vec3');

/**
 * Lock constraint. Will remove all degrees of freedom between the bodies.
 * @class LockConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
function LockConstraint(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    // Set pivot point in between
    var pivotA = new Vec3();
    var pivotB = new Vec3();
    var halfWay = new Vec3();
    bodyA.position.vadd(bodyB.position, halfWay);
    halfWay.scale(0.5, halfWay);
    bodyB.pointToLocalFrame(halfWay, pivotB);
    bodyA.pointToLocalFrame(halfWay, pivotA);

    // The point-to-point constraint will keep a point shared between the bodies
    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

    // Store initial rotation of the bodies as unit vectors in the local body spaces
    this.xA = bodyA.vectorToLocalFrame(Vec3.UNIT_X);
    this.xB = bodyB.vectorToLocalFrame(Vec3.UNIT_X);
    this.yA = bodyA.vectorToLocalFrame(Vec3.UNIT_Y);
    this.yB = bodyB.vectorToLocalFrame(Vec3.UNIT_Y);
    this.zA = bodyA.vectorToLocalFrame(Vec3.UNIT_Z);
    this.zB = bodyB.vectorToLocalFrame(Vec3.UNIT_Z);

    // ...and the following rotational equations will keep all rotational DOF's in place

    /**
     * @property {RotationalEquation} rotationalEquation1
     */
    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} rotationalEquation2
     */
    var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} rotationalEquation3
     */
    var r3 = this.rotationalEquation3 = new RotationalEquation(bodyA,bodyB,options);

    this.equations.push(r1, r2, r3);
}
LockConstraint.prototype = new PointToPointConstraint();
LockConstraint.constructor = LockConstraint;

var LockConstraint_update_tmpVec1 = new Vec3();
var LockConstraint_update_tmpVec2 = new Vec3();

LockConstraint.prototype.update = function(){
    var bodyA = this.bodyA,
        bodyB = this.bodyB,
        motor = this.motorEquation,
        r1 = this.rotationalEquation1,
        r2 = this.rotationalEquation2,
        r3 = this.rotationalEquation3,
        worldAxisA = LockConstraint_update_tmpVec1,
        worldAxisB = LockConstraint_update_tmpVec2;

    PointToPointConstraint.prototype.update.call(this);

    // These vector pairs must be orthogonal
    bodyA.vectorToWorldFrame(this.xA, r1.axisA);
    bodyB.vectorToWorldFrame(this.yB, r1.axisB);

    bodyA.vectorToWorldFrame(this.yA, r2.axisA);
    bodyB.vectorToWorldFrame(this.zB, r2.axisB);

    bodyA.vectorToWorldFrame(this.zA, r3.axisA);
    bodyB.vectorToWorldFrame(this.xB, r3.axisB);
};


},{"../equations/ContactEquation":22,"../equations/RotationalEquation":25,"../equations/RotationalMotorEquation":26,"../math/Vec3":33,"./Constraint":16,"./PointToPointConstraint":20}],20:[function(require,module,exports){
module.exports = PointToPointConstraint;

var Constraint = require('./Constraint');
var ContactEquation = require('../equations/ContactEquation');
var Vec3 = require('../math/Vec3');

/**
 * Connects two bodies at given offset points.
 * @class PointToPointConstraint
 * @extends Constraint
 * @constructor
 * @param {Body} bodyA
 * @param {Vec3} pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
 * @param {Body} bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
 * @param {Vec3} pivotB See pivotA.
 * @param {Number} maxForce The maximum force that should be applied to constrain the bodies.
 *
 * @example
 *     var bodyA = new Body({ mass: 1 });
 *     var bodyB = new Body({ mass: 1 });
 *     bodyA.position.set(-1, 0, 0);
 *     bodyB.position.set(1, 0, 0);
 *     bodyA.addShape(shapeA);
 *     bodyB.addShape(shapeB);
 *     world.addBody(bodyA);
 *     world.addBody(bodyB);
 *     var localPivotA = new Vec3(1, 0, 0);
 *     var localPivotB = new Vec3(-1, 0, 0);
 *     var constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);
 *     world.addConstraint(constraint);
 */
function PointToPointConstraint(bodyA,pivotA,bodyB,pivotB,maxForce){
    Constraint.call(this,bodyA,bodyB);

    maxForce = typeof(maxForce) !== 'undefined' ? maxForce : 1e6;

    /**
     * Pivot, defined locally in bodyA.
     * @property {Vec3} pivotA
     */
    this.pivotA = pivotA ? pivotA.clone() : new Vec3();

    /**
     * Pivot, defined locally in bodyB.
     * @property {Vec3} pivotB
     */
    this.pivotB = pivotB ? pivotB.clone() : new Vec3();

    /**
     * @property {ContactEquation} equationX
     */
    var x = this.equationX = new ContactEquation(bodyA,bodyB);

    /**
     * @property {ContactEquation} equationY
     */
    var y = this.equationY = new ContactEquation(bodyA,bodyB);

    /**
     * @property {ContactEquation} equationZ
     */
    var z = this.equationZ = new ContactEquation(bodyA,bodyB);

    // Equations to be fed to the solver
    this.equations.push(x, y, z);

    // Make the equations bidirectional
    x.minForce = y.minForce = z.minForce = -maxForce;
    x.maxForce = y.maxForce = z.maxForce =  maxForce;

    x.ni.set(1, 0, 0);
    y.ni.set(0, 1, 0);
    z.ni.set(0, 0, 1);
}
PointToPointConstraint.prototype = new Constraint();

PointToPointConstraint.prototype.update = function(){
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;
    var x = this.equationX;
    var y = this.equationY;
    var z = this.equationZ;

    // Rotate the pivots to world space
    bodyA.quaternion.vmult(this.pivotA,x.ri);
    bodyB.quaternion.vmult(this.pivotB,x.rj);

    y.ri.copy(x.ri);
    y.rj.copy(x.rj);
    z.ri.copy(x.ri);
    z.rj.copy(x.rj);
};
},{"../equations/ContactEquation":22,"../math/Vec3":33,"./Constraint":16}],21:[function(require,module,exports){
module.exports = ConeEquation;

var Vec3 = require('../math/Vec3');
var Mat3 = require('../math/Mat3');
var Equation = require('./Equation');

/**
 * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
 * @class ConeEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Vec3} [options.axisA] Local axis in A
 * @param {Vec3} [options.axisB] Local axis in B
 * @param {Vec3} [options.angle] The "cone angle" to keep
 * @param {number} [options.maxForce=1e6]
 * @extends Equation
 */
function ConeEquation(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    Equation.call(this,bodyA,bodyB,-maxForce, maxForce);

    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);

    /**
     * The cone angle to keep
     * @property {number} angle
     */
    this.angle = typeof(options.angle) !== 'undefined' ? options.angle : 0;
}

ConeEquation.prototype = new Equation();
ConeEquation.prototype.constructor = ConeEquation;

var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();

ConeEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,

        ni = this.axisA,
        nj = this.axisB,

        nixnj = tmpVec1,
        njxni = tmpVec2,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB;

    // Caluclate cross products
    ni.cross(nj, nixnj);
    nj.cross(ni, njxni);

    // The angle between two vector is:
    // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b

    // g = a * b
    // gdot = (b x a) * wi + (a x b) * wj
    // G = [0 bxa 0 axb]
    // W = [vi wi vj wj]
    GA.rotational.copy(njxni);
    GB.rotational.copy(nixnj);

    var g = Math.cos(this.angle) - ni.dot(nj),
        GW = this.computeGW(),
        GiMf = this.computeGiMf();

    var B = - g * a - GW * b - h * GiMf;

    return B;
};


},{"../math/Mat3":30,"../math/Vec3":33,"./Equation":23}],22:[function(require,module,exports){
module.exports = ContactEquation;

var Equation = require('./Equation');
var Vec3 = require('../math/Vec3');
var Mat3 = require('../math/Mat3');

/**
 * Contact/non-penetration constraint equation
 * @class ContactEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @extends Equation
 */
function ContactEquation(bodyA, bodyB, maxForce){
    maxForce = typeof(maxForce) !== 'undefined' ? maxForce : 1e6;
    Equation.call(this, bodyA, bodyB, 0, maxForce);

    /**
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0.0; // "bounciness": u1 = -e*u0

    /**
     * World-oriented vector that goes from the center of bi to the contact point.
     * @property {Vec3} ri
     */
    this.ri = new Vec3();

    /**
     * World-oriented vector that starts in body j position and goes to the contact point.
     * @property {Vec3} rj
     */
    this.rj = new Vec3();

    /**
     * Contact normal, pointing out of body i.
     * @property {Vec3} ni
     */
    this.ni = new Vec3();
}

ContactEquation.prototype = new Equation();
ContactEquation.prototype.constructor = ContactEquation;

var ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors
var ContactEquation_computeB_temp2 = new Vec3();
var ContactEquation_computeB_temp3 = new Vec3();
ContactEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,
        bi = this.bi,
        bj = this.bj,
        ri = this.ri,
        rj = this.rj,
        rixn = ContactEquation_computeB_temp1,
        rjxn = ContactEquation_computeB_temp2,

        vi = bi.velocity,
        wi = bi.angularVelocity,
        fi = bi.force,
        taui = bi.torque,

        vj = bj.velocity,
        wj = bj.angularVelocity,
        fj = bj.force,
        tauj = bj.torque,

        penetrationVec = ContactEquation_computeB_temp3,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB,

        n = this.ni;

    // Caluclate cross products
    ri.cross(n,rixn);
    rj.cross(n,rjxn);

    // g = xj+rj -(xi+ri)
    // G = [ -ni  -rixn  ni  rjxn ]
    n.negate(GA.spatial);
    rixn.negate(GA.rotational);
    GB.spatial.copy(n);
    GB.rotational.copy(rjxn);

    // Calculate the penetration vector
    penetrationVec.copy(bj.position);
    penetrationVec.vadd(rj,penetrationVec);
    penetrationVec.vsub(bi.position,penetrationVec);
    penetrationVec.vsub(ri,penetrationVec);

    var g = n.dot(penetrationVec);

    // Compute iteration
    var ePlusOne = this.restitution + 1;
    var GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
    var GiMf = this.computeGiMf();

    var B = - g * a - GW * b - h*GiMf;

    return B;
};

var ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();

/**
 * Get the current relative velocity in the contact point.
 * @method getImpactVelocityAlongNormal
 * @return {number}
 */
ContactEquation.prototype.getImpactVelocityAlongNormal = function(){
    var vi = ContactEquation_getImpactVelocityAlongNormal_vi;
    var vj = ContactEquation_getImpactVelocityAlongNormal_vj;
    var xi = ContactEquation_getImpactVelocityAlongNormal_xi;
    var xj = ContactEquation_getImpactVelocityAlongNormal_xj;
    var relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;

    this.bi.position.vadd(this.ri, xi);
    this.bj.position.vadd(this.rj, xj);

    this.bi.getVelocityAtWorldPoint(xi, vi);
    this.bj.getVelocityAtWorldPoint(xj, vj);

    vi.vsub(vj, relVel);

    return this.ni.dot(relVel);
};


},{"../math/Mat3":30,"../math/Vec3":33,"./Equation":23}],23:[function(require,module,exports){
module.exports = Equation;

var JacobianElement = require('../math/JacobianElement'),
    Vec3 = require('../math/Vec3');

/**
 * Equation base class
 * @class Equation
 * @constructor
 * @author schteppe
 * @param {Body} bi
 * @param {Body} bj
 * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.
 * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.
 */
function Equation(bi,bj,minForce,maxForce){
    this.id = Equation.id++;

    /**
     * @property {number} minForce
     */
    this.minForce = typeof(minForce)==="undefined" ? -1e6 : minForce;

    /**
     * @property {number} maxForce
     */
    this.maxForce = typeof(maxForce)==="undefined" ? 1e6 : maxForce;

    /**
     * @property bi
     * @type {Body}
     */
    this.bi = bi;

    /**
     * @property bj
     * @type {Body}
     */
    this.bj = bj;

    /**
     * SPOOK parameter
     * @property {number} a
     */
    this.a = 0.0;

    /**
     * SPOOK parameter
     * @property {number} b
     */
    this.b = 0.0;

    /**
     * SPOOK parameter
     * @property {number} eps
     */
    this.eps = 0.0;

    /**
     * @property {JacobianElement} jacobianElementA
     */
    this.jacobianElementA = new JacobianElement();

    /**
     * @property {JacobianElement} jacobianElementB
     */
    this.jacobianElementB = new JacobianElement();

    /**
     * @property {boolean} enabled
     * @default true
     */
    this.enabled = true;

    /**
     * A number, proportional to the force added to the bodies.
     * @property {number} multiplier
     * @readonly
     */
    this.multiplier = 0;

    // Set typical spook params
    this.setSpookParams(1e7,4,1/60);
}
Equation.prototype.constructor = Equation;

Equation.id = 0;

/**
 * Recalculates a,b,eps.
 * @method setSpookParams
 */
Equation.prototype.setSpookParams = function(stiffness,relaxation,timeStep){
    var d = relaxation,
        k = stiffness,
        h = timeStep;
    this.a = 4.0 / (h * (1 + 4 * d));
    this.b = (4.0 * d) / (1 + 4 * d);
    this.eps = 4.0 / (h * h * k * (1 + 4 * d));
};

/**
 * Computes the RHS of the SPOOK equation
 * @method computeB
 * @return {Number}
 */
Equation.prototype.computeB = function(a,b,h){
    var GW = this.computeGW(),
        Gq = this.computeGq(),
        GiMf = this.computeGiMf();
    return - Gq * a - GW * b - GiMf*h;
};

/**
 * Computes G*q, where q are the generalized body coordinates
 * @method computeGq
 * @return {Number}
 */
Equation.prototype.computeGq = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        xi = bi.position,
        xj = bj.position;
    return GA.spatial.dot(xi) + GB.spatial.dot(xj);
};

var zero = new Vec3();

/**
 * Computes G*W, where W are the body velocities
 * @method computeGW
 * @return {Number}
 */
Equation.prototype.computeGW = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        vi = bi.velocity,
        vj = bj.velocity,
        wi = bi.angularVelocity,
        wj = bj.angularVelocity;
    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);
};


/**
 * Computes G*Wlambda, where W are the body velocities
 * @method computeGWlambda
 * @return {Number}
 */
Equation.prototype.computeGWlambda = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        vi = bi.vlambda,
        vj = bj.vlambda,
        wi = bi.wlambda,
        wj = bj.wlambda;
    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);
};

/**
 * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
 * @method computeGiMf
 * @return {Number}
 */
var iMfi = new Vec3(),
    iMfj = new Vec3(),
    invIi_vmult_taui = new Vec3(),
    invIj_vmult_tauj = new Vec3();
Equation.prototype.computeGiMf = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        fi = bi.force,
        ti = bi.torque,
        fj = bj.force,
        tj = bj.torque,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve;

    fi.scale(invMassi,iMfi);
    fj.scale(invMassj,iMfj);

    bi.invInertiaWorldSolve.vmult(ti,invIi_vmult_taui);
    bj.invInertiaWorldSolve.vmult(tj,invIj_vmult_tauj);

    return GA.multiplyVectors(iMfi,invIi_vmult_taui) + GB.multiplyVectors(iMfj,invIj_vmult_tauj);
};

/**
 * Computes G*inv(M)*G'
 * @method computeGiMGt
 * @return {Number}
 */
var tmp = new Vec3();
Equation.prototype.computeGiMGt = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaWorldSolve,
        invIj = bj.invInertiaWorldSolve,
        result = invMassi + invMassj;

    invIi.vmult(GA.rotational,tmp);
    result += tmp.dot(GA.rotational);

    invIj.vmult(GB.rotational,tmp);
    result += tmp.dot(GB.rotational);

    return  result;
};

var addToWlambda_temp = new Vec3(),
    addToWlambda_Gi = new Vec3(),
    addToWlambda_Gj = new Vec3(),
    addToWlambda_ri = new Vec3(),
    addToWlambda_rj = new Vec3(),
    addToWlambda_Mdiag = new Vec3();

/**
 * Add constraint velocity to the bodies.
 * @method addToWlambda
 * @param {Number} deltalambda
 */
Equation.prototype.addToWlambda = function(deltalambda){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        temp = addToWlambda_temp;

    // Add to linear velocity
    // v_lambda += inv(M) * delta_lamba * G
    bi.vlambda.addScaledVector(bi.invMassSolve * deltalambda, GA.spatial, bi.vlambda);
    bj.vlambda.addScaledVector(bj.invMassSolve * deltalambda, GB.spatial, bj.vlambda);

    // Add to angular velocity
    bi.invInertiaWorldSolve.vmult(GA.rotational,temp);
    bi.wlambda.addScaledVector(deltalambda, temp, bi.wlambda);

    bj.invInertiaWorldSolve.vmult(GB.rotational,temp);
    bj.wlambda.addScaledVector(deltalambda, temp, bj.wlambda);
};

/**
 * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
 * @method computeInvC
 * @param  {Number} eps
 * @return {Number}
 */
Equation.prototype.computeC = function(){
    return this.computeGiMGt() + this.eps;
};

},{"../math/JacobianElement":29,"../math/Vec3":33}],24:[function(require,module,exports){
module.exports = FrictionEquation;

var Equation = require('./Equation');
var Vec3 = require('../math/Vec3');
var Mat3 = require('../math/Mat3');

/**
 * Constrains the slipping in a contact along a tangent
 * @class FrictionEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
 * @extends Equation
 */
function FrictionEquation(bodyA, bodyB, slipForce){
    Equation.call(this,bodyA, bodyB, -slipForce, slipForce);
    this.ri = new Vec3();
    this.rj = new Vec3();
    this.t = new Vec3(); // tangent
}

FrictionEquation.prototype = new Equation();
FrictionEquation.prototype.constructor = FrictionEquation;

var FrictionEquation_computeB_temp1 = new Vec3();
var FrictionEquation_computeB_temp2 = new Vec3();
FrictionEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,
        bi = this.bi,
        bj = this.bj,
        ri = this.ri,
        rj = this.rj,
        rixt = FrictionEquation_computeB_temp1,
        rjxt = FrictionEquation_computeB_temp2,
        t = this.t;

    // Caluclate cross products
    ri.cross(t,rixt);
    rj.cross(t,rjxt);

    // G = [-t -rixt t rjxt]
    // And remember, this is a pure velocity constraint, g is always zero!
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB;
    t.negate(GA.spatial);
    rixt.negate(GA.rotational);
    GB.spatial.copy(t);
    GB.rotational.copy(rjxt);

    var GW = this.computeGW();
    var GiMf = this.computeGiMf();

    var B = - GW * b - h * GiMf;

    return B;
};

},{"../math/Mat3":30,"../math/Vec3":33,"./Equation":23}],25:[function(require,module,exports){
module.exports = RotationalEquation;

var Vec3 = require('../math/Vec3');
var Mat3 = require('../math/Mat3');
var Equation = require('./Equation');

/**
 * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
 * @class RotationalEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Vec3} [options.axisA]
 * @param {Vec3} [options.axisB]
 * @param {number} [options.maxForce]
 * @extends Equation
 */
function RotationalEquation(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    Equation.call(this,bodyA,bodyB,-maxForce, maxForce);

    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);

    this.maxAngle = Math.PI / 2;
}

RotationalEquation.prototype = new Equation();
RotationalEquation.prototype.constructor = RotationalEquation;

var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();

RotationalEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,

        ni = this.axisA,
        nj = this.axisB,

        nixnj = tmpVec1,
        njxni = tmpVec2,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB;

    // Caluclate cross products
    ni.cross(nj, nixnj);
    nj.cross(ni, njxni);

    // g = ni * nj
    // gdot = (nj x ni) * wi + (ni x nj) * wj
    // G = [0 njxni 0 nixnj]
    // W = [vi wi vj wj]
    GA.rotational.copy(njxni);
    GB.rotational.copy(nixnj);

    var g = Math.cos(this.maxAngle) - ni.dot(nj),
        GW = this.computeGW(),
        GiMf = this.computeGiMf();

    var B = - g * a - GW * b - h * GiMf;

    return B;
};


},{"../math/Mat3":30,"../math/Vec3":33,"./Equation":23}],26:[function(require,module,exports){
module.exports = RotationalMotorEquation;

var Vec3 = require('../math/Vec3');
var Mat3 = require('../math/Mat3');
var Equation = require('./Equation');

/**
 * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
 * @class RotationalMotorEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} maxForce
 * @extends Equation
 */
function RotationalMotorEquation(bodyA, bodyB, maxForce){
    maxForce = typeof(maxForce)!=='undefined' ? maxForce : 1e6;
    Equation.call(this,bodyA,bodyB,-maxForce,maxForce);

    /**
     * World oriented rotational axis
     * @property {Vec3} axisA
     */
    this.axisA = new Vec3();

    /**
     * World oriented rotational axis
     * @property {Vec3} axisB
     */
    this.axisB = new Vec3(); // World oriented rotational axis

    /**
     * Motor velocity
     * @property {Number} targetVelocity
     */
    this.targetVelocity = 0;
}

RotationalMotorEquation.prototype = new Equation();
RotationalMotorEquation.prototype.constructor = RotationalMotorEquation;

RotationalMotorEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,
        bi = this.bi,
        bj = this.bj,

        axisA = this.axisA,
        axisB = this.axisB,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB;

    // g = 0
    // gdot = axisA * wi - axisB * wj
    // gdot = G * W = G * [vi wi vj wj]
    // =>
    // G = [0 axisA 0 -axisB]

    GA.rotational.copy(axisA);
    axisB.negate(GB.rotational);

    var GW = this.computeGW() - this.targetVelocity,
        GiMf = this.computeGiMf();

    var B = - GW * b - h * GiMf;

    return B;
};

},{"../math/Mat3":30,"../math/Vec3":33,"./Equation":23}],27:[function(require,module,exports){
var Utils = require('../utils/Utils');

module.exports = ContactMaterial;

/**
 * Defines what happens when two materials meet.
 * @class ContactMaterial
 * @constructor
 * @param {Material} m1
 * @param {Material} m2
 * @param {object} [options]
 * @param {Number} [options.friction=0.3]
 * @param {Number} [options.restitution=0.3]
 * @param {number} [options.contactEquationStiffness=1e7]
 * @param {number} [options.contactEquationRelaxation=3]
 * @param {number} [options.frictionEquationStiffness=1e7]
 * @param {Number} [options.frictionEquationRelaxation=3]
 */
function ContactMaterial(m1, m2, options){
    options = Utils.defaults(options, {
        friction: 0.3,
        restitution: 0.3,
        contactEquationStiffness: 1e7,
        contactEquationRelaxation: 3,
        frictionEquationStiffness: 1e7,
        frictionEquationRelaxation: 3
    });

    /**
     * Identifier of this material
     * @property {Number} id
     */
    this.id = ContactMaterial.idCounter++;

    /**
     * Participating materials
     * @property {Array} materials
     * @todo  Should be .materialA and .materialB instead
     */
    this.materials = [m1, m2];

    /**
     * Friction coefficient
     * @property {Number} friction
     */
    this.friction = options.friction;

    /**
     * Restitution coefficient
     * @property {Number} restitution
     */
    this.restitution = options.restitution;

    /**
     * Stiffness of the produced contact equations
     * @property {Number} contactEquationStiffness
     */
    this.contactEquationStiffness = options.contactEquationStiffness;

    /**
     * Relaxation time of the produced contact equations
     * @property {Number} contactEquationRelaxation
     */
    this.contactEquationRelaxation = options.contactEquationRelaxation;

    /**
     * Stiffness of the produced friction equations
     * @property {Number} frictionEquationStiffness
     */
    this.frictionEquationStiffness = options.frictionEquationStiffness;

    /**
     * Relaxation time of the produced friction equations
     * @property {Number} frictionEquationRelaxation
     */
    this.frictionEquationRelaxation = options.frictionEquationRelaxation;
}

ContactMaterial.idCounter = 0;

},{"../utils/Utils":56}],28:[function(require,module,exports){
module.exports = Material;

/**
 * Defines a physics material.
 * @class Material
 * @constructor
 * @param {object} [options]
 * @author schteppe
 */
function Material(options){
    var name = '';
    options = options || {};

    // Backwards compatibility fix
    if(typeof(options) === 'string'){
        name = options;
        options = {};
    } else if(typeof(options) === 'object') {
        name = '';
    }

    /**
     * @property name
     * @type {String}
     */
    this.name = name;

    /**
     * material id.
     * @property id
     * @type {number}
     */
    this.id = Material.idCounter++;

    /**
     * Friction for this material. If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
     * @property {number} friction
     */
    this.friction = typeof(options.friction) !== 'undefined' ? options.friction : -1;

    /**
     * Restitution for this material. If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
     * @property {number} restitution
     */
    this.restitution = typeof(options.restitution) !== 'undefined' ? options.restitution : -1;
}

Material.idCounter = 0;

},{}],29:[function(require,module,exports){
module.exports = JacobianElement;

var Vec3 = require('./Vec3');

/**
 * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
 * @class JacobianElement
 * @constructor
 */
function JacobianElement(){

    /**
     * @property {Vec3} spatial
     */
    this.spatial = new Vec3();

    /**
     * @property {Vec3} rotational
     */
    this.rotational = new Vec3();
}

/**
 * Multiply with other JacobianElement
 * @method multiplyElement
 * @param  {JacobianElement} element
 * @return {Number}
 */
JacobianElement.prototype.multiplyElement = function(element){
    return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
};

/**
 * Multiply with two vectors
 * @method multiplyVectors
 * @param  {Vec3} spatial
 * @param  {Vec3} rotational
 * @return {Number}
 */
JacobianElement.prototype.multiplyVectors = function(spatial,rotational){
    return spatial.dot(this.spatial) + rotational.dot(this.rotational);
};

},{"./Vec3":33}],30:[function(require,module,exports){
module.exports = Mat3;

var Vec3 = require('./Vec3');

/**
 * A 3x3 matrix.
 * @class Mat3
 * @constructor
 * @param array elements Array of nine elements. Optional.
 * @author schteppe / http://github.com/schteppe
 */
function Mat3(elements){
    /**
     * A vector of length 9, containing all matrix elements
     * @property {Array} elements
     */
    if(elements){
        this.elements = elements;
    } else {
        this.elements = [0,0,0,0,0,0,0,0,0];
    }
}

/**
 * Sets the matrix to identity
 * @method identity
 * @todo Should perhaps be renamed to setIdentity() to be more clear.
 * @todo Create another function that immediately creates an identity matrix eg. eye()
 */
Mat3.prototype.identity = function(){
    var e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;

    e[3] = 0;
    e[4] = 1;
    e[5] = 0;

    e[6] = 0;
    e[7] = 0;
    e[8] = 1;
};

/**
 * Set all elements to zero
 * @method setZero
 */
Mat3.prototype.setZero = function(){
    var e = this.elements;
    e[0] = 0;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 0;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 0;
};

/**
 * Sets the matrix diagonal elements from a Vec3
 * @method setTrace
 * @param {Vec3} vec3
 */
Mat3.prototype.setTrace = function(vec3){
    var e = this.elements;
    e[0] = vec3.x;
    e[4] = vec3.y;
    e[8] = vec3.z;
};

/**
 * Gets the matrix diagonal elements
 * @method getTrace
 * @return {Vec3}
 */
Mat3.prototype.getTrace = function(target){
    var target = target || new Vec3();
    var e = this.elements;
    target.x = e[0];
    target.y = e[4];
    target.z = e[8];
};

/**
 * Matrix-Vector multiplication
 * @method vmult
 * @param {Vec3} v The vector to multiply with
 * @param {Vec3} target Optional, target to save the result in.
 */
Mat3.prototype.vmult = function(v,target){
    target = target || new Vec3();

    var e = this.elements,
        x = v.x,
        y = v.y,
        z = v.z;
    target.x = e[0]*x + e[1]*y + e[2]*z;
    target.y = e[3]*x + e[4]*y + e[5]*z;
    target.z = e[6]*x + e[7]*y + e[8]*z;

    return target;
};

/**
 * Matrix-scalar multiplication
 * @method smult
 * @param {Number} s
 */
Mat3.prototype.smult = function(s){
    for(var i=0; i<this.elements.length; i++){
        this.elements[i] *= s;
    }
};

/**
 * Matrix multiplication
 * @method mmult
 * @param {Mat3} m Matrix to multiply with from left side.
 * @return {Mat3} The result.
 */
Mat3.prototype.mmult = function(m,target){
    var r = target || new Mat3();
    for(var i=0; i<3; i++){
        for(var j=0; j<3; j++){
            var sum = 0.0;
            for(var k=0; k<3; k++){
                sum += m.elements[i+k*3] * this.elements[k+j*3];
            }
            r.elements[i+j*3] = sum;
        }
    }
    return r;
};

/**
 * Scale each column of the matrix
 * @method scale
 * @param {Vec3} v
 * @return {Mat3} The result.
 */
Mat3.prototype.scale = function(v,target){
    target = target || new Mat3();
    var e = this.elements,
        t = target.elements;
    for(var i=0; i!==3; i++){
        t[3*i + 0] = v.x * e[3*i + 0];
        t[3*i + 1] = v.y * e[3*i + 1];
        t[3*i + 2] = v.z * e[3*i + 2];
    }
    return target;
};

/**
 * Solve Ax=b
 * @method solve
 * @param {Vec3} b The right hand side
 * @param {Vec3} target Optional. Target vector to save in.
 * @return {Vec3} The solution x
 * @todo should reuse arrays
 */
Mat3.prototype.solve = function(b,target){
    target = target || new Vec3();

    // Construct equations
    var nr = 3; // num rows
    var nc = 4; // num cols
    var eqns = [];
    for(var i=0; i<nr*nc; i++){
        eqns.push(0);
    }
    var i,j;
    for(i=0; i<3; i++){
        for(j=0; j<3; j++){
            eqns[i+nc*j] = this.elements[i+3*j];
        }
    }
    eqns[3+4*0] = b.x;
    eqns[3+4*1] = b.y;
    eqns[3+4*2] = b.z;

    // Compute right upper triangular version of the matrix - Gauss elimination
    var n = 3, k = n, np;
    var kp = 4; // num rows
    var p, els;
    do {
        i = k - n;
        if (eqns[i+nc*i] === 0) {
            // the pivot is null, swap lines
            for (j = i + 1; j < k; j++) {
                if (eqns[i+nc*j] !== 0) {
                    np = kp;
                    do {  // do ligne( i ) = ligne( i ) + ligne( k )
                        p = kp - np;
                        eqns[p+nc*i] += eqns[p+nc*j];
                    } while (--np);
                    break;
                }
            }
        }
        if (eqns[i+nc*i] !== 0) {
            for (j = i + 1; j < k; j++) {
                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
                np = kp;
                do {  // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
                    p = kp - np;
                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
                } while (--np);
            }
        }
    } while (--n);

    // Get the solution
    target.z = eqns[2*nc+3] / eqns[2*nc+2];
    target.y = (eqns[1*nc+3] - eqns[1*nc+2]*target.z) / eqns[1*nc+1];
    target.x = (eqns[0*nc+3] - eqns[0*nc+2]*target.z - eqns[0*nc+1]*target.y) / eqns[0*nc+0];

    if(isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x===Infinity || target.y===Infinity || target.z===Infinity){
        throw "Could not solve equation! Got x=["+target.toString()+"], b=["+b.toString()+"], A=["+this.toString()+"]";
    }

    return target;
};

/**
 * Get an element in the matrix by index. Index starts at 0, not 1!!!
 * @method e
 * @param {Number} row
 * @param {Number} column
 * @param {Number} value Optional. If provided, the matrix element will be set to this value.
 * @return {Number}
 */
Mat3.prototype.e = function( row , column ,value){
    if(value===undefined){
        return this.elements[column+3*row];
    } else {
        // Set value
        this.elements[column+3*row] = value;
    }
};

/**
 * Copy another matrix into this matrix object.
 * @method copy
 * @param {Mat3} source
 * @return {Mat3} this
 */
Mat3.prototype.copy = function(source){
    for(var i=0; i < source.elements.length; i++){
        this.elements[i] = source.elements[i];
    }
    return this;
};

/**
 * Returns a string representation of the matrix.
 * @method toString
 * @return string
 */
Mat3.prototype.toString = function(){
    var r = "";
    var sep = ",";
    for(var i=0; i<9; i++){
        r += this.elements[i] + sep;
    }
    return r;
};

/**
 * reverse the matrix
 * @method reverse
 * @param {Mat3} target Optional. Target matrix to save in.
 * @return {Mat3} The solution x
 */
Mat3.prototype.reverse = function(target){

    target = target || new Mat3();

    // Construct equations
    var nr = 3; // num rows
    var nc = 6; // num cols
    var eqns = [];
    for(var i=0; i<nr*nc; i++){
        eqns.push(0);
    }
    var i,j;
    for(i=0; i<3; i++){
        for(j=0; j<3; j++){
            eqns[i+nc*j] = this.elements[i+3*j];
        }
    }
    eqns[3+6*0] = 1;
    eqns[3+6*1] = 0;
    eqns[3+6*2] = 0;
    eqns[4+6*0] = 0;
    eqns[4+6*1] = 1;
    eqns[4+6*2] = 0;
    eqns[5+6*0] = 0;
    eqns[5+6*1] = 0;
    eqns[5+6*2] = 1;

    // Compute right upper triangular version of the matrix - Gauss elimination
    var n = 3, k = n, np;
    var kp = nc; // num rows
    var p;
    do {
        i = k - n;
        if (eqns[i+nc*i] === 0) {
            // the pivot is null, swap lines
            for (j = i + 1; j < k; j++) {
                if (eqns[i+nc*j] !== 0) {
                    np = kp;
                    do { // do line( i ) = line( i ) + line( k )
                        p = kp - np;
                        eqns[p+nc*i] += eqns[p+nc*j];
                    } while (--np);
                    break;
                }
            }
        }
        if (eqns[i+nc*i] !== 0) {
            for (j = i + 1; j < k; j++) {
                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
                np = kp;
                do { // do line( k ) = line( k ) - multiplier * line( i )
                    p = kp - np;
                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
                } while (--np);
            }
        }
    } while (--n);

    // eliminate the upper left triangle of the matrix
    i = 2;
    do {
        j = i-1;
        do {
            var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
            np = nc;
            do {
                p = nc - np;
                eqns[p+nc*j] =  eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
            } while (--np);
        } while (j--);
    } while (--i);

    // operations on the diagonal
    i = 2;
    do {
        var multiplier = 1 / eqns[i+nc*i];
        np = nc;
        do {
            p = nc - np;
            eqns[p+nc*i] = eqns[p+nc*i] * multiplier ;
        } while (--np);
    } while (i--);

    i = 2;
    do {
        j = 2;
        do {
            p = eqns[nr+j+nc*i];
            if( isNaN( p ) || p ===Infinity ){
                throw "Could not reverse! A=["+this.toString()+"]";
            }
            target.e( i , j , p );
        } while (j--);
    } while (i--);

    return target;
};

/**
 * Set the matrix from a quaterion
 * @method setRotationFromQuaternion
 * @param {Quaternion} q
 */
Mat3.prototype.setRotationFromQuaternion = function( q ) {
    var x = q.x, y = q.y, z = q.z, w = q.w,
        x2 = x + x, y2 = y + y, z2 = z + z,
        xx = x * x2, xy = x * y2, xz = x * z2,
        yy = y * y2, yz = y * z2, zz = z * z2,
        wx = w * x2, wy = w * y2, wz = w * z2,
        e = this.elements;

    e[3*0 + 0] = 1 - ( yy + zz );
    e[3*0 + 1] = xy - wz;
    e[3*0 + 2] = xz + wy;

    e[3*1 + 0] = xy + wz;
    e[3*1 + 1] = 1 - ( xx + zz );
    e[3*1 + 2] = yz - wx;

    e[3*2 + 0] = xz - wy;
    e[3*2 + 1] = yz + wx;
    e[3*2 + 2] = 1 - ( xx + yy );

    return this;
};

/**
 * Transpose the matrix
 * @method transpose
 * @param  {Mat3} target Where to store the result.
 * @return {Mat3} The target Mat3, or a new Mat3 if target was omitted.
 */
Mat3.prototype.transpose = function( target ) {
    target = target || new Mat3();

    var Mt = target.elements,
        M = this.elements;

    for(var i=0; i!==3; i++){
        for(var j=0; j!==3; j++){
            Mt[3*i + j] = M[3*j + i];
        }
    }

    return target;
};

},{"./Vec3":33}],31:[function(require,module,exports){
module.exports = Quaternion;

var Vec3 = require('./Vec3');

/**
 * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
 * @class Quaternion
 * @constructor
 * @param {Number} x Multiplier of the imaginary basis vector i.
 * @param {Number} y Multiplier of the imaginary basis vector j.
 * @param {Number} z Multiplier of the imaginary basis vector k.
 * @param {Number} w Multiplier of the real part.
 * @see http://en.wikipedia.org/wiki/Quaternion
 */
function Quaternion(x,y,z,w){
    /**
     * @property {Number} x
     */
    this.x = x!==undefined ? x : 0;

    /**
     * @property {Number} y
     */
    this.y = y!==undefined ? y : 0;

    /**
     * @property {Number} z
     */
    this.z = z!==undefined ? z : 0;

    /**
     * The multiplier of the real quaternion basis vector.
     * @property {Number} w
     */
    this.w = w!==undefined ? w : 1;
}

/**
 * Set the value of the quaternion.
 * @method set
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @param {Number} w
 */
Quaternion.prototype.set = function(x,y,z,w){
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
};

/**
 * Convert to a readable format
 * @method toString
 * @return string
 */
Quaternion.prototype.toString = function(){
    return this.x+","+this.y+","+this.z+","+this.w;
};

/**
 * Convert to an Array
 * @method toArray
 * @return Array
 */
Quaternion.prototype.toArray = function(){
    return [this.x, this.y, this.z, this.w];
};

/**
 * Set the quaternion components given an axis and an angle.
 * @method setFromAxisAngle
 * @param {Vec3} axis
 * @param {Number} angle in radians
 */
Quaternion.prototype.setFromAxisAngle = function(axis,angle){
    var s = Math.sin(angle*0.5);
    this.x = axis.x * s;
    this.y = axis.y * s;
    this.z = axis.z * s;
    this.w = Math.cos(angle*0.5);
    return this;
};

/**
 * Converts the quaternion to axis/angle representation.
 * @method toAxisAngle
 * @param {Vec3} [targetAxis] A vector object to reuse for storing the axis.
 * @return {Array} An array, first elemnt is the axis and the second is the angle in radians.
 */
Quaternion.prototype.toAxisAngle = function(targetAxis){
    targetAxis = targetAxis || new Vec3();
    this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
    var angle = 2 * Math.acos(this.w);
    var s = Math.sqrt(1-this.w*this.w); // assuming quaternion normalised then w is less than 1, so term always positive.
    if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
        // if s close to zero then direction of axis not important
        targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;
        targetAxis.y = this.y;
        targetAxis.z = this.z;
    } else {
        targetAxis.x = this.x / s; // normalise axis
        targetAxis.y = this.y / s;
        targetAxis.z = this.z / s;
    }
    return [targetAxis,angle];
};

var sfv_t1 = new Vec3(),
    sfv_t2 = new Vec3();

/**
 * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
 * @method setFromVectors
 * @param {Vec3} u
 * @param {Vec3} v
 */
Quaternion.prototype.setFromVectors = function(u,v){
    if(u.isAntiparallelTo(v)){
        var t1 = sfv_t1;
        var t2 = sfv_t2;

        u.tangents(t1,t2);
        this.setFromAxisAngle(t1,Math.PI);
    } else {
        var a = u.cross(v);
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        this.w = Math.sqrt(Math.pow(u.norm(),2) * Math.pow(v.norm(),2)) + u.dot(v);
        this.normalize();
    }
    return this;
};

/**
 * Quaternion multiplication
 * @method mult
 * @param {Quaternion} q
 * @param {Quaternion} target Optional.
 * @return {Quaternion}
 */
var Quaternion_mult_va = new Vec3();
var Quaternion_mult_vb = new Vec3();
var Quaternion_mult_vaxvb = new Vec3();
Quaternion.prototype.mult = function(q,target){
    target = target || new Quaternion();

    var ax = this.x, ay = this.y, az = this.z, aw = this.w,
        bx = q.x, by = q.y, bz = q.z, bw = q.w;

    target.x = ax * bw + aw * bx + ay * bz - az * by;
    target.y = ay * bw + aw * by + az * bx - ax * bz;
    target.z = az * bw + aw * bz + ax * by - ay * bx;
    target.w = aw * bw - ax * bx - ay * by - az * bz;

    return target;
};

/**
 * Get the inverse quaternion rotation.
 * @method inverse
 * @param {Quaternion} target
 * @return {Quaternion}
 */
Quaternion.prototype.inverse = function(target){
    var x = this.x, y = this.y, z = this.z, w = this.w;
    target = target || new Quaternion();

    this.conjugate(target);
    var inorm2 = 1/(x*x + y*y + z*z + w*w);
    target.x *= inorm2;
    target.y *= inorm2;
    target.z *= inorm2;
    target.w *= inorm2;

    return target;
};

/**
 * Get the quaternion conjugate
 * @method conjugate
 * @param {Quaternion} target
 * @return {Quaternion}
 */
Quaternion.prototype.conjugate = function(target){
    target = target || new Quaternion();

    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    target.w = this.w;

    return target;
};

/**
 * Normalize the quaternion. Note that this changes the values of the quaternion.
 * @method normalize
 */
Quaternion.prototype.normalize = function(){
    var l = Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);
    if ( l === 0 ) {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
    } else {
        l = 1 / l;
        this.x *= l;
        this.y *= l;
        this.z *= l;
        this.w *= l;
    }
    return this;
};

/**
 * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
 * @method normalizeFast
 * @see http://jsperf.com/fast-quaternion-normalization
 * @author unphased, https://github.com/unphased
 */
Quaternion.prototype.normalizeFast = function () {
    var f = (3.0-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2.0;
    if ( f === 0 ) {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
    } else {
        this.x *= f;
        this.y *= f;
        this.z *= f;
        this.w *= f;
    }
    return this;
};

/**
 * Multiply the quaternion by a vector
 * @method vmult
 * @param {Vec3} v
 * @param {Vec3} target Optional
 * @return {Vec3}
 */
Quaternion.prototype.vmult = function(v,target){
    target = target || new Vec3();

    var x = v.x,
        y = v.y,
        z = v.z;

    var qx = this.x,
        qy = this.y,
        qz = this.z,
        qw = this.w;

    // q*v
    var ix =  qw * x + qy * z - qz * y,
    iy =  qw * y + qz * x - qx * z,
    iz =  qw * z + qx * y - qy * x,
    iw = -qx * x - qy * y - qz * z;

    target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

    return target;
};

/**
 * Copies value of source to this quaternion.
 * @method copy
 * @param {Quaternion} source
 * @return {Quaternion} this
 */
Quaternion.prototype.copy = function(source){
    this.x = source.x;
    this.y = source.y;
    this.z = source.z;
    this.w = source.w;
    return this;
};

/**
 * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm
 * @method toEuler
 * @param {Vec3} target
 * @param string order Three-character string e.g. "YZX", which also is default.
 */
Quaternion.prototype.toEuler = function(target,order){
    order = order || "YZX";

    var heading, attitude, bank;
    var x = this.x, y = this.y, z = this.z, w = this.w;

    switch(order){
    case "YZX":
        var test = x*y + z*w;
        if (test > 0.499) { // singularity at north pole
            heading = 2 * Math.atan2(x,w);
            attitude = Math.PI/2;
            bank = 0;
        }
        if (test < -0.499) { // singularity at south pole
            heading = -2 * Math.atan2(x,w);
            attitude = - Math.PI/2;
            bank = 0;
        }
        if(isNaN(heading)){
            var sqx = x*x;
            var sqy = y*y;
            var sqz = z*z;
            heading = Math.atan2(2*y*w - 2*x*z , 1 - 2*sqy - 2*sqz); // Heading
            attitude = Math.asin(2*test); // attitude
            bank = Math.atan2(2*x*w - 2*y*z , 1 - 2*sqx - 2*sqz); // bank
        }
        break;
    default:
        throw new Error("Euler order "+order+" not supported yet.");
    }

    target.y = heading;
    target.z = attitude;
    target.x = bank;
};

/**
 * See http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
 * @method setFromEuler
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @param {String} order The order to apply angles: 'XYZ' or 'YXZ' or any other combination
 */
Quaternion.prototype.setFromEuler = function ( x, y, z, order ) {
    order = order || "XYZ";

    var c1 = Math.cos( x / 2 );
    var c2 = Math.cos( y / 2 );
    var c3 = Math.cos( z / 2 );
    var s1 = Math.sin( x / 2 );
    var s2 = Math.sin( y / 2 );
    var s3 = Math.sin( z / 2 );

    if ( order === 'XYZ' ) {

        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'YXZ' ) {

        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( order === 'ZXY' ) {

        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'ZYX' ) {

        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( order === 'YZX' ) {

        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'XZY' ) {

        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;

    }

    return this;
};

/**
 * @method clone
 * @return {Quaternion}
 */
Quaternion.prototype.clone = function(){
    return new Quaternion(this.x, this.y, this.z, this.w);
};

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @method slerp
 * @param {Quaternion} toQuat second operand
 * @param {Number} t interpolation amount between the self quaternion and toQuat
 * @param {Quaternion} [target] A quaternion to store the result in. If not provided, a new one will be created.
 * @returns {Quaternion} The "target" object
 */
Quaternion.prototype.slerp = function (toQuat, t, target) {
    target = target || new Quaternion();

    var ax = this.x,
        ay = this.y,
        az = this.z,
        aw = this.w,
        bx = toQuat.x,
        by = toQuat.y,
        bz = toQuat.z,
        bw = toQuat.w;

    var omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;

    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }

    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {
        // "from" and "to" quaternions are very close
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }

    // calculate final values
    target.x = scale0 * ax + scale1 * bx;
    target.y = scale0 * ay + scale1 * by;
    target.z = scale0 * az + scale1 * bz;
    target.w = scale0 * aw + scale1 * bw;

    return target;
};

/**
 * Rotate an absolute orientation quaternion given an angular velocity and a time step.
 * @param  {Vec3} angularVelocity
 * @param  {number} dt
 * @param  {Vec3} angularFactor
 * @param  {Quaternion} target
 * @return {Quaternion} The "target" object
 */
Quaternion.prototype.integrate = function(angularVelocity, dt, angularFactor, target){
    target = target || new Quaternion();

    var ax = angularVelocity.x * angularFactor.x,
        ay = angularVelocity.y * angularFactor.y,
        az = angularVelocity.z * angularFactor.z,
        bx = this.x,
        by = this.y,
        bz = this.z,
        bw = this.w;

    var half_dt = dt * 0.5;

    target.x += half_dt * (ax * bw + ay * bz - az * by);
    target.y += half_dt * (ay * bw + az * bx - ax * bz);
    target.z += half_dt * (az * bw + ax * by - ay * bx);
    target.w += half_dt * (- ax * bx - ay * by - az * bz);

    return target;
};
},{"./Vec3":33}],32:[function(require,module,exports){
var Vec3 = require('./Vec3');
var Quaternion = require('./Quaternion');

module.exports = Transform;

/**
 * @class Transform
 * @constructor
 */
function Transform(options) {
    options = options || {};

	/**
	 * @property {Vec3} position
	 */
	this.position = new Vec3();
    if(options.position){
        this.position.copy(options.position);
    }

	/**
	 * @property {Quaternion} quaternion
	 */
	this.quaternion = new Quaternion();
    if(options.quaternion){
        this.quaternion.copy(options.quaternion);
    }
}

var tmpQuat = new Quaternion();

/**
 * @static
 * @method pointToLocaFrame
 * @param {Vec3} position
 * @param {Quaternion} quaternion
 * @param {Vec3} worldPoint
 * @param {Vec3} result
 */
Transform.pointToLocalFrame = function(position, quaternion, worldPoint, result){
    var result = result || new Vec3();
    worldPoint.vsub(position, result);
    quaternion.conjugate(tmpQuat);
    tmpQuat.vmult(result, result);
    return result;
};

/**
 * Get a global point in local transform coordinates.
 * @method pointToLocal
 * @param  {Vec3} point
 * @param  {Vec3} result
 * @return {Vec3} The "result" vector object
 */
Transform.prototype.pointToLocal = function(worldPoint, result){
    return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
};

/**
 * @static
 * @method pointToWorldFrame
 * @param {Vec3} position
 * @param {Vec3} quaternion
 * @param {Vec3} localPoint
 * @param {Vec3} result
 */
Transform.pointToWorldFrame = function(position, quaternion, localPoint, result){
    var result = result || new Vec3();
    quaternion.vmult(localPoint, result);
    result.vadd(position, result);
    return result;
};

/**
 * Get a local point in global transform coordinates.
 * @method pointToWorld
 * @param  {Vec3} point
 * @param  {Vec3} result
 * @return {Vec3} The "result" vector object
 */
Transform.prototype.pointToWorld = function(localPoint, result){
    return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
};


Transform.prototype.vectorToWorldFrame = function(localVector, result){
    var result = result || new Vec3();
    this.quaternion.vmult(localVector, result);
    return result;
};

Transform.vectorToWorldFrame = function(quaternion, localVector, result){
    quaternion.vmult(localVector, result);
    return result;
};

Transform.vectorToLocalFrame = function(position, quaternion, worldVector, result){
    var result = result || new Vec3();
    quaternion.w *= -1;
    quaternion.vmult(worldVector, result);
    quaternion.w *= -1;
    return result;
};

},{"./Quaternion":31,"./Vec3":33}],33:[function(require,module,exports){
module.exports = Vec3;

var Mat3 = require('./Mat3');

/**
 * 3-dimensional vector
 * @class Vec3
 * @constructor
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @author schteppe
 * @example
 *     var v = new Vec3(1, 2, 3);
 *     console.log('x=' + v.x); // x=1
 */
function Vec3(x,y,z){
    /**
     * @property x
     * @type {Number}
     */
    this.x = x||0.0;

    /**
     * @property y
     * @type {Number}
     */
    this.y = y||0.0;

    /**
     * @property z
     * @type {Number}
     */
    this.z = z||0.0;
}

/**
 * @static
 * @property {Vec3} ZERO
 */
Vec3.ZERO = new Vec3(0, 0, 0);

/**
 * @static
 * @property {Vec3} UNIT_X
 */
Vec3.UNIT_X = new Vec3(1, 0, 0);

/**
 * @static
 * @property {Vec3} UNIT_Y
 */
Vec3.UNIT_Y = new Vec3(0, 1, 0);

/**
 * @static
 * @property {Vec3} UNIT_Z
 */
Vec3.UNIT_Z = new Vec3(0, 0, 1);

/**
 * Vector cross product
 * @method cross
 * @param {Vec3} v
 * @param {Vec3} target Optional. Target to save in.
 * @return {Vec3}
 */
Vec3.prototype.cross = function(v,target){
    var vx=v.x, vy=v.y, vz=v.z, x=this.x, y=this.y, z=this.z;
    target = target || new Vec3();

    target.x = (y * vz) - (z * vy);
    target.y = (z * vx) - (x * vz);
    target.z = (x * vy) - (y * vx);

    return target;
};

/**
 * Set the vectors' 3 elements
 * @method set
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @return Vec3
 */
Vec3.prototype.set = function(x,y,z){
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
};

/**
 * Set all components of the vector to zero.
 * @method setZero
 */
Vec3.prototype.setZero = function(){
    this.x = this.y = this.z = 0;
};

/**
 * Vector addition
 * @method vadd
 * @param {Vec3} v
 * @param {Vec3} target Optional.
 * @return {Vec3}
 */
Vec3.prototype.vadd = function(v,target){
    if(target){
        target.x = v.x + this.x;
        target.y = v.y + this.y;
        target.z = v.z + this.z;
    } else {
        return new Vec3(this.x + v.x,
                               this.y + v.y,
                               this.z + v.z);
    }
};

/**
 * Vector subtraction
 * @method vsub
 * @param {Vec3} v
 * @param {Vec3} target Optional. Target to save in.
 * @return {Vec3}
 */
Vec3.prototype.vsub = function(v,target){
    if(target){
        target.x = this.x - v.x;
        target.y = this.y - v.y;
        target.z = this.z - v.z;
    } else {
        return new Vec3(this.x-v.x,
                               this.y-v.y,
                               this.z-v.z);
    }
};

/**
 * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
 * @method crossmat
 * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf
 * @return {Mat3}
 */
Vec3.prototype.crossmat = function(){
    return new Mat3([     0,  -this.z,   this.y,
                            this.z,        0,  -this.x,
                           -this.y,   this.x,        0]);
};

/**
 * Normalize the vector. Note that this changes the values in the vector.
 * @method normalize
 * @return {Number} Returns the norm of the vector
 */
Vec3.prototype.normalize = function(){
    var x=this.x, y=this.y, z=this.z;
    var n = Math.sqrt(x*x + y*y + z*z);
    if(n>0.0){
        var invN = 1/n;
        this.x *= invN;
        this.y *= invN;
        this.z *= invN;
    } else {
        // Make something up
        this.x = 0;
        this.y = 0;
        this.z = 0;
    }
    return n;
};

/**
 * Get the version of this vector that is of length 1.
 * @method unit
 * @param {Vec3} target Optional target to save in
 * @return {Vec3} Returns the unit vector
 */
Vec3.prototype.unit = function(target){
    target = target || new Vec3();
    var x=this.x, y=this.y, z=this.z;
    var ninv = Math.sqrt(x*x + y*y + z*z);
    if(ninv>0.0){
        ninv = 1.0/ninv;
        target.x = x * ninv;
        target.y = y * ninv;
        target.z = z * ninv;
    } else {
        target.x = 1;
        target.y = 0;
        target.z = 0;
    }
    return target;
};

/**
 * Get the length of the vector
 * @method norm
 * @return {Number}
 * @deprecated Use .length() instead
 */
Vec3.prototype.norm = function(){
    var x=this.x, y=this.y, z=this.z;
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Get the length of the vector
 * @method length
 * @return {Number}
 */
Vec3.prototype.length = Vec3.prototype.norm;

/**
 * Get the squared length of the vector
 * @method norm2
 * @return {Number}
 * @deprecated Use .lengthSquared() instead.
 */
Vec3.prototype.norm2 = function(){
    return this.dot(this);
};

/**
 * Get the squared length of the vector.
 * @method lengthSquared
 * @return {Number}
 */
Vec3.prototype.lengthSquared = Vec3.prototype.norm2;

/**
 * Get distance from this point to another point
 * @method distanceTo
 * @param  {Vec3} p
 * @return {Number}
 */
Vec3.prototype.distanceTo = function(p){
    var x=this.x, y=this.y, z=this.z;
    var px=p.x, py=p.y, pz=p.z;
    return Math.sqrt((px-x)*(px-x)+
                     (py-y)*(py-y)+
                     (pz-z)*(pz-z));
};

/**
 * Get squared distance from this point to another point
 * @method distanceSquared
 * @param  {Vec3} p
 * @return {Number}
 */
Vec3.prototype.distanceSquared = function(p){
    var x=this.x, y=this.y, z=this.z;
    var px=p.x, py=p.y, pz=p.z;
    return (px-x)*(px-x) + (py-y)*(py-y) + (pz-z)*(pz-z);
};

/**
 * Multiply all the components of the vector with a scalar.
 * @deprecated Use .scale instead
 * @method mult
 * @param {Number} scalar
 * @param {Vec3} target The vector to save the result in.
 * @return {Vec3}
 * @deprecated Use .scale() instead
 */
Vec3.prototype.mult = function(scalar,target){
    target = target || new Vec3();
    var x = this.x,
        y = this.y,
        z = this.z;
    target.x = scalar * x;
    target.y = scalar * y;
    target.z = scalar * z;
    return target;
};

/**
 * Multiply the vector with an other vector, component-wise.
 * @method mult
 * @param {Number} vector
 * @param {Vec3} target The vector to save the result in.
 * @return {Vec3}
 */
Vec3.prototype.vmul = function(vector, target){
    target = target || new Vec3();
    target.x = vector.x * this.x;
    target.y = vector.y * this.y;
    target.z = vector.z * this.z;
    return target;
};

/**
 * Multiply the vector with a scalar.
 * @method scale
 * @param {Number} scalar
 * @param {Vec3} target
 * @return {Vec3}
 */
Vec3.prototype.scale = Vec3.prototype.mult;

/**
 * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
 * @method addScaledVector
 * @param {Number} scalar
 * @param {Vec3} vector
 * @param {Vec3} target The vector to save the result in.
 * @return {Vec3}
 */
Vec3.prototype.addScaledVector = function(scalar, vector, target){
    target = target || new Vec3();
    target.x = this.x + scalar * vector.x;
    target.y = this.y + scalar * vector.y;
    target.z = this.z + scalar * vector.z;
    return target;
};

/**
 * Calculate dot product
 * @method dot
 * @param {Vec3} v
 * @return {Number}
 */
Vec3.prototype.dot = function(v){
    return this.x * v.x + this.y * v.y + this.z * v.z;
};

/**
 * @method isZero
 * @return bool
 */
Vec3.prototype.isZero = function(){
    return this.x===0 && this.y===0 && this.z===0;
};

/**
 * Make the vector point in the opposite direction.
 * @method negate
 * @param {Vec3} target Optional target to save in
 * @return {Vec3}
 */
Vec3.prototype.negate = function(target){
    target = target || new Vec3();
    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    return target;
};

/**
 * Compute two artificial tangents to the vector
 * @method tangents
 * @param {Vec3} t1 Vector object to save the first tangent in
 * @param {Vec3} t2 Vector object to save the second tangent in
 */
var Vec3_tangents_n = new Vec3();
var Vec3_tangents_randVec = new Vec3();
Vec3.prototype.tangents = function(t1,t2){
    var norm = this.norm();
    if(norm>0.0){
        var n = Vec3_tangents_n;
        var inorm = 1/norm;
        n.set(this.x*inorm,this.y*inorm,this.z*inorm);
        var randVec = Vec3_tangents_randVec;
        if(Math.abs(n.x) < 0.9){
            randVec.set(1,0,0);
            n.cross(randVec,t1);
        } else {
            randVec.set(0,1,0);
            n.cross(randVec,t1);
        }
        n.cross(t1,t2);
    } else {
        // The normal length is zero, make something up
        t1.set(1, 0, 0);
        t2.set(0, 1, 0);
    }
};

/**
 * Converts to a more readable format
 * @method toString
 * @return string
 */
Vec3.prototype.toString = function(){
    return this.x+","+this.y+","+this.z;
};

/**
 * Converts to an array
 * @method toArray
 * @return Array
 */
Vec3.prototype.toArray = function(){
    return [this.x, this.y, this.z];
};

/**
 * Copies value of source to this vector.
 * @method copy
 * @param {Vec3} source
 * @return {Vec3} this
 */
Vec3.prototype.copy = function(source){
    this.x = source.x;
    this.y = source.y;
    this.z = source.z;
    return this;
};


/**
 * Do a linear interpolation between two vectors
 * @method lerp
 * @param {Vec3} v
 * @param {Number} t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
 * @param {Vec3} target
 */
Vec3.prototype.lerp = function(v,t,target){
    var x=this.x, y=this.y, z=this.z;
    target.x = x + (v.x-x)*t;
    target.y = y + (v.y-y)*t;
    target.z = z + (v.z-z)*t;
};

/**
 * Check if a vector equals is almost equal to another one.
 * @method almostEquals
 * @param {Vec3} v
 * @param {Number} precision
 * @return bool
 */
Vec3.prototype.almostEquals = function(v,precision){
    if(precision===undefined){
        precision = 1e-6;
    }
    if( Math.abs(this.x-v.x)>precision ||
        Math.abs(this.y-v.y)>precision ||
        Math.abs(this.z-v.z)>precision){
        return false;
    }
    return true;
};

/**
 * Check if a vector is almost zero
 * @method almostZero
 * @param {Number} precision
 */
Vec3.prototype.almostZero = function(precision){
    if(precision===undefined){
        precision = 1e-6;
    }
    if( Math.abs(this.x)>precision ||
        Math.abs(this.y)>precision ||
        Math.abs(this.z)>precision){
        return false;
    }
    return true;
};

var antip_neg = new Vec3();

/**
 * Check if the vector is anti-parallel to another vector.
 * @method isAntiparallelTo
 * @param  {Vec3}  v
 * @param  {Number}  precision Set to zero for exact comparisons
 * @return {Boolean}
 */
Vec3.prototype.isAntiparallelTo = function(v,precision){
    this.negate(antip_neg);
    return antip_neg.almostEquals(v,precision);
};

/**
 * Clone the vector
 * @method clone
 * @return {Vec3}
 */
Vec3.prototype.clone = function(){
    return new Vec3(this.x, this.y, this.z);
};
},{"./Mat3":30}],34:[function(require,module,exports){
module.exports = Body;

var EventTarget = require('../utils/EventTarget');
var Shape = require('../shapes/Shape');
var Vec3 = require('../math/Vec3');
var Mat3 = require('../math/Mat3');
var Quaternion = require('../math/Quaternion');
var Material = require('../material/Material');
var AABB = require('../collision/AABB');
var Box = require('../shapes/Box');

/**
 * Base class for all body types.
 * @class Body
 * @constructor
 * @extends EventTarget
 * @param {object} [options]
 * @param {Vec3} [options.position]
 * @param {Vec3} [options.velocity]
 * @param {Vec3} [options.angularVelocity]
 * @param {Quaternion} [options.quaternion]
 * @param {number} [options.mass]
 * @param {Material} [options.material]
 * @param {number} [options.type]
 * @param {number} [options.linearDamping=0.01]
 * @param {number} [options.angularDamping=0.01]
 * @param {boolean} [options.allowSleep=true]
 * @param {number} [options.sleepSpeedLimit=0.1]
 * @param {number} [options.sleepTimeLimit=1]
 * @param {number} [options.collisionFilterGroup=1]
 * @param {number} [options.collisionFilterMask=1]
 * @param {boolean} [options.fixedRotation=false]
 * @param {Vec3} [options.linearFactor]
 * @param {Vec3} [options.angularFactor]
 * @param {Body} [options.shape]
 * @example
 *     var body = new Body({
 *         mass: 1
 *     });
 *     var shape = new Sphere(1);
 *     body.addShape(shape);
 *     world.addBody(body);
 */
function Body(options){
    options = options || {};

    EventTarget.apply(this);

    this.id = Body.idCounter++;

    /**
     * Reference to the world the body is living in
     * @property world
     * @type {World}
     */
    this.world = null;

    /**
     * Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, "this" will refer to this Body object.
     * @property preStep
     * @type {Function}
     * @deprecated Use World events instead
     */
    this.preStep = null;

    /**
     * Callback function that is used AFTER stepping the system. Inside the function, "this" will refer to this Body object.
     * @property postStep
     * @type {Function}
     * @deprecated Use World events instead
     */
    this.postStep = null;

    this.vlambda = new Vec3();

    /**
     * @property {Number} collisionFilterGroup
     */
    this.collisionFilterGroup = typeof(options.collisionFilterGroup) === 'number' ? options.collisionFilterGroup : 1;

    /**
     * @property {Number} collisionFilterMask
     */
    this.collisionFilterMask = typeof(options.collisionFilterMask) === 'number' ? options.collisionFilterMask : 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
     * @property {Number} collisionResponse
     */
	this.collisionResponse = true;

    /**
     * @property position
     * @type {Vec3}
     */
    this.position = new Vec3();

    /**
     * @property {Vec3} previousPosition
     */
    this.previousPosition = new Vec3();

    /**
     * Interpolated position of the body.
     * @property {Vec3} interpolatedPosition
     */
    this.interpolatedPosition = new Vec3();

    /**
     * Initial position of the body
     * @property initPosition
     * @type {Vec3}
     */
    this.initPosition = new Vec3();

    if(options.position){
        this.position.copy(options.position);
        this.previousPosition.copy(options.position);
        this.interpolatedPosition.copy(options.position);
        this.initPosition.copy(options.position);
    }

    /**
     * @property velocity
     * @type {Vec3}
     */
    this.velocity = new Vec3();

    if(options.velocity){
        this.velocity.copy(options.velocity);
    }

    /**
     * @property initVelocity
     * @type {Vec3}
     */
    this.initVelocity = new Vec3();

    /**
     * Linear force on the body
     * @property force
     * @type {Vec3}
     */
    this.force = new Vec3();

    var mass = typeof(options.mass) === 'number' ? options.mass : 0;

    /**
     * @property mass
     * @type {Number}
     * @default 0
     */
    this.mass = mass;

    /**
     * @property invMass
     * @type {Number}
     */
    this.invMass = mass > 0 ? 1.0 / mass : 0;

    /**
     * @property material
     * @type {Material}
     */
    this.material = options.material || null;

    /**
     * @property linearDamping
     * @type {Number}
     */
    this.linearDamping = typeof(options.linearDamping) === 'number' ? options.linearDamping : 0.01;

    /**
     * One of: Body.DYNAMIC, Body.STATIC and Body.KINEMATIC.
     * @property type
     * @type {Number}
     */
    this.type = (mass <= 0.0 ? Body.STATIC : Body.DYNAMIC);
    if(typeof(options.type) === typeof(Body.STATIC)){
        this.type = options.type;
    }

    /**
     * If true, the body will automatically fall to sleep.
     * @property allowSleep
     * @type {Boolean}
     * @default true
     */
    this.allowSleep = typeof(options.allowSleep) !== 'undefined' ? options.allowSleep : true;

    /**
     * Current sleep state.
     * @property sleepState
     * @type {Number}
     */
    this.sleepState = 0;

    /**
     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
     * @property sleepSpeedLimit
     * @type {Number}
     * @default 0.1
     */
    this.sleepSpeedLimit = typeof(options.sleepSpeedLimit) !== 'undefined' ? options.sleepSpeedLimit : 0.1;

    /**
     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
     * @property sleepTimeLimit
     * @type {Number}
     * @default 1
     */
    this.sleepTimeLimit = typeof(options.sleepTimeLimit) !== 'undefined' ? options.sleepTimeLimit : 1;

    this.timeLastSleepy = 0;

    this._wakeUpAfterNarrowphase = false;


    /**
     * Rotational force on the body, around center of mass
     * @property {Vec3} torque
     */
    this.torque = new Vec3();

    /**
     * Orientation of the body
     * @property quaternion
     * @type {Quaternion}
     */
    this.quaternion = new Quaternion();

    /**
     * @property initQuaternion
     * @type {Quaternion}
     */
    this.initQuaternion = new Quaternion();

    /**
     * @property {Quaternion} previousQuaternion
     */
    this.previousQuaternion = new Quaternion();

    /**
     * Interpolated orientation of the body.
     * @property {Quaternion} interpolatedQuaternion
     */
    this.interpolatedQuaternion = new Quaternion();

    if(options.quaternion){
        this.quaternion.copy(options.quaternion);
        this.initQuaternion.copy(options.quaternion);
        this.previousQuaternion.copy(options.quaternion);
        this.interpolatedQuaternion.copy(options.quaternion);
    }

    /**
     * @property angularVelocity
     * @type {Vec3}
     */
    this.angularVelocity = new Vec3();

    if(options.angularVelocity){
        this.angularVelocity.copy(options.angularVelocity);
    }

    /**
     * @property initAngularVelocity
     * @type {Vec3}
     */
    this.initAngularVelocity = new Vec3();

    /**
     * @property shapes
     * @type {array}
     */
    this.shapes = [];

    /**
     * @property shapeOffsets
     * @type {array}
     */
    this.shapeOffsets = [];

    /**
     * @property shapeOrientations
     * @type {array}
     */
    this.shapeOrientations = [];

    /**
     * @property inertia
     * @type {Vec3}
     */
    this.inertia = new Vec3();

    /**
     * @property {Vec3} invInertia
     */
    this.invInertia = new Vec3();

    /**
     * @property {Mat3} invInertiaWorld
     */
    this.invInertiaWorld = new Mat3();

    this.invMassSolve = 0;

    /**
     * @property {Vec3} invInertiaSolve
     */
    this.invInertiaSolve = new Vec3();

    /**
     * @property {Mat3} invInertiaWorldSolve
     */
    this.invInertiaWorldSolve = new Mat3();

    /**
     * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() after changing this.
     * @property {Boolean} fixedRotation
     * @default false
     */
    this.fixedRotation = typeof(options.fixedRotation) !== "undefined" ? options.fixedRotation : false;

    /**
     * @property {Number} angularDamping
     */
    this.angularDamping = typeof(options.angularDamping) !== 'undefined' ? options.angularDamping : 0.01;

    /**
     * @property {Vec3} linearFactor
     */
    this.linearFactor = new Vec3(1,1,1);
    if(options.linearFactor){
        this.linearFactor.copy(options.linearFactor);
    }

    /**
     * @property {Vec3} angularFactor
     */
    this.angularFactor = new Vec3(1,1,1);
    if(options.angularFactor){
        this.angularFactor.copy(options.angularFactor);
    }

    /**
     * @property aabb
     * @type {AABB}
     */
    this.aabb = new AABB();

    /**
     * Indicates if the AABB needs to be updated before use.
     * @property aabbNeedsUpdate
     * @type {Boolean}
     */
    this.aabbNeedsUpdate = true;

    this.wlambda = new Vec3();

    if(options.shape){
        this.addShape(options.shape);
    }

    this.updateMassProperties();
}
Body.prototype = new EventTarget();
Body.prototype.constructor = Body;

/**
 * Dispatched after two bodies collide. This event is dispatched on each
 * of the two bodies involved in the collision.
 * @event collide
 * @param {Body} body The body that was involved in the collision.
 * @param {ContactEquation} contact The details of the collision.
 */
Body.COLLIDE_EVENT_NAME = "collide";

/**
 * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
 * @static
 * @property DYNAMIC
 * @type {Number}
 */
Body.DYNAMIC = 1;

/**
 * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
 * @static
 * @property STATIC
 * @type {Number}
 */
Body.STATIC = 2;

/**
 * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
 * @static
 * @property KINEMATIC
 * @type {Number}
 */
Body.KINEMATIC = 4;



/**
 * @static
 * @property AWAKE
 * @type {number}
 */
Body.AWAKE = 0;

/**
 * @static
 * @property SLEEPY
 * @type {number}
 */
Body.SLEEPY = 1;

/**
 * @static
 * @property SLEEPING
 * @type {number}
 */
Body.SLEEPING = 2;

Body.idCounter = 0;

/**
 * Dispatched after a sleeping body has woken up.
 * @event wakeup
 */
Body.wakeupEvent = {
    type: "wakeup"
};

/**
 * Wake the body up.
 * @method wakeUp
 */
Body.prototype.wakeUp = function(){
    var s = this.sleepState;
    this.sleepState = 0;
    if(s === Body.SLEEPING){
        this.dispatchEvent(Body.wakeupEvent);
    }
};

/**
 * Force body sleep
 * @method sleep
 */
Body.prototype.sleep = function(){
    this.sleepState = Body.SLEEPING;
    this.velocity.set(0,0,0);
    this.angularVelocity.set(0,0,0);
};

/**
 * Dispatched after a body has gone in to the sleepy state.
 * @event sleepy
 */
Body.sleepyEvent = {
    type: "sleepy"
};

/**
 * Dispatched after a body has fallen asleep.
 * @event sleep
 */
Body.sleepEvent = {
    type: "sleep"
};

/**
 * Called every timestep to update internal sleep timer and change sleep state if needed.
 * @method sleepTick
 * @param {Number} time The world time in seconds
 */
Body.prototype.sleepTick = function(time){
    if(this.allowSleep){
        var sleepState = this.sleepState;
        var speedSquared = this.velocity.norm2() + this.angularVelocity.norm2();
        var speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);
        if(sleepState===Body.AWAKE && speedSquared < speedLimitSquared){
            this.sleepState = Body.SLEEPY; // Sleepy
            this.timeLastSleepy = time;
            this.dispatchEvent(Body.sleepyEvent);
        } else if(sleepState===Body.SLEEPY && speedSquared > speedLimitSquared){
            this.wakeUp(); // Wake up
        } else if(sleepState===Body.SLEEPY && (time - this.timeLastSleepy ) > this.sleepTimeLimit){
            this.sleep(); // Sleeping
            this.dispatchEvent(Body.sleepEvent);
        }
    }
};

/**
 * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
 * @method updateSolveMassProperties
 */
Body.prototype.updateSolveMassProperties = function(){
    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){
        this.invMassSolve = 0;
        this.invInertiaSolve.setZero();
        this.invInertiaWorldSolve.setZero();
    } else {
        this.invMassSolve = this.invMass;
        this.invInertiaSolve.copy(this.invInertia);
        this.invInertiaWorldSolve.copy(this.invInertiaWorld);
    }
};

/**
 * Convert a world point to local body frame.
 * @method pointToLocalFrame
 * @param  {Vec3} worldPoint
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.pointToLocalFrame = function(worldPoint,result){
    var result = result || new Vec3();
    worldPoint.vsub(this.position,result);
    this.quaternion.conjugate().vmult(result,result);
    return result;
};

/**
 * Convert a world vector to local body frame.
 * @method vectorToLocalFrame
 * @param  {Vec3} worldPoint
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.vectorToLocalFrame = function(worldVector, result){
    var result = result || new Vec3();
    this.quaternion.conjugate().vmult(worldVector,result);
    return result;
};

/**
 * Convert a local body point to world frame.
 * @method pointToWorldFrame
 * @param  {Vec3} localPoint
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.pointToWorldFrame = function(localPoint,result){
    var result = result || new Vec3();
    this.quaternion.vmult(localPoint,result);
    result.vadd(this.position,result);
    return result;
};

/**
 * Convert a local body point to world frame.
 * @method vectorToWorldFrame
 * @param  {Vec3} localVector
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.vectorToWorldFrame = function(localVector, result){
    var result = result || new Vec3();
    this.quaternion.vmult(localVector, result);
    return result;
};

var tmpVec = new Vec3();
var tmpQuat = new Quaternion();

/**
 * Add a shape to the body with a local offset and orientation.
 * @method addShape
 * @param {Shape} shape
 * @param {Vec3} [_offset]
 * @param {Quaternion} [_orientation]
 * @return {Body} The body object, for chainability.
 */
Body.prototype.addShape = function(shape, _offset, _orientation){
    var offset = new Vec3();
    var orientation = new Quaternion();

    if(_offset){
        offset.copy(_offset);
    }
    if(_orientation){
        orientation.copy(_orientation);
    }

    this.shapes.push(shape);
    this.shapeOffsets.push(offset);
    this.shapeOrientations.push(orientation);
    this.updateMassProperties();
    this.updateBoundingRadius();

    this.aabbNeedsUpdate = true;

    return this;
};

/**
 * Update the bounding radius of the body. Should be done if any of the shapes are changed.
 * @method updateBoundingRadius
 */
Body.prototype.updateBoundingRadius = function(){
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        N = shapes.length,
        radius = 0;

    for(var i=0; i!==N; i++){
        var shape = shapes[i];
        shape.updateBoundingSphereRadius();
        var offset = shapeOffsets[i].norm(),
            r = shape.boundingSphereRadius;
        if(offset + r > radius){
            radius = offset + r;
        }
    }

    this.boundingRadius = radius;
};

var computeAABB_shapeAABB = new AABB();

/**
 * Updates the .aabb
 * @method computeAABB
 * @todo rename to updateAABB()
 */
Body.prototype.computeAABB = function(){
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        shapeOrientations = this.shapeOrientations,
        N = shapes.length,
        offset = tmpVec,
        orientation = tmpQuat,
        bodyQuat = this.quaternion,
        aabb = this.aabb,
        shapeAABB = computeAABB_shapeAABB;

    for(var i=0; i!==N; i++){
        var shape = shapes[i];

        // Get shape world position
        bodyQuat.vmult(shapeOffsets[i], offset);
        offset.vadd(this.position, offset);

        // Get shape world quaternion
        shapeOrientations[i].mult(bodyQuat, orientation);

        // Get shape AABB
        shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);

        if(i === 0){
            aabb.copy(shapeAABB);
        } else {
            aabb.extend(shapeAABB);
        }
    }

    this.aabbNeedsUpdate = false;
};

var uiw_m1 = new Mat3(),
    uiw_m2 = new Mat3(),
    uiw_m3 = new Mat3();

/**
 * Update .inertiaWorld and .invInertiaWorld
 * @method updateInertiaWorld
 */
Body.prototype.updateInertiaWorld = function(force){
    var I = this.invInertia;
    if (I.x === I.y && I.y === I.z && !force) {
        // If inertia M = s*I, where I is identity and s a scalar, then
        //    R*M*R' = R*(s*I)*R' = s*R*I*R' = s*R*R' = s*I = M
        // where R is the rotation matrix.
        // In other words, we don't have to transform the inertia if all
        // inertia diagonal entries are equal.
    } else {
        var m1 = uiw_m1,
            m2 = uiw_m2,
            m3 = uiw_m3;
        m1.setRotationFromQuaternion(this.quaternion);
        m1.transpose(m2);
        m1.scale(I,m1);
        m1.mmult(m2,this.invInertiaWorld);
    }
};

/**
 * Apply force to a world point. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.torque.
 * @method applyForce
 * @param  {Vec3} force The amount of force to add.
 * @param  {Vec3} relativePoint A point relative to the center of mass to apply the force on.
 */
var Body_applyForce_r = new Vec3();
var Body_applyForce_rotForce = new Vec3();
Body.prototype.applyForce = function(force,relativePoint){
    if(this.type !== Body.DYNAMIC){ // Needed?
        return;
    }

    // Compute produced rotational force
    var rotForce = Body_applyForce_rotForce;
    relativePoint.cross(force,rotForce);

    // Add linear force
    this.force.vadd(force,this.force);

    // Add rotational force
    this.torque.vadd(rotForce,this.torque);
};

/**
 * Apply force to a local point in the body.
 * @method applyLocalForce
 * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
 * @param  {Vec3} localPoint A local point in the body to apply the force on.
 */
var Body_applyLocalForce_worldForce = new Vec3();
var Body_applyLocalForce_relativePointWorld = new Vec3();
Body.prototype.applyLocalForce = function(localForce, localPoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    var worldForce = Body_applyLocalForce_worldForce;
    var relativePointWorld = Body_applyLocalForce_relativePointWorld;

    // Transform the force vector to world space
    this.vectorToWorldFrame(localForce, worldForce);
    this.vectorToWorldFrame(localPoint, relativePointWorld);

    this.applyForce(worldForce, relativePointWorld);
};

/**
 * Apply impulse to a world point. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
 * @method applyImpulse
 * @param  {Vec3} impulse The amount of impulse to add.
 * @param  {Vec3} relativePoint A point relative to the center of mass to apply the force on.
 */
var Body_applyImpulse_r = new Vec3();
var Body_applyImpulse_velo = new Vec3();
var Body_applyImpulse_rotVelo = new Vec3();
Body.prototype.applyImpulse = function(impulse, relativePoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    // Compute point position relative to the body center
    var r = relativePoint;

    // Compute produced central impulse velocity
    var velo = Body_applyImpulse_velo;
    velo.copy(impulse);
    velo.mult(this.invMass,velo);

    // Add linear impulse
    this.velocity.vadd(velo, this.velocity);

    // Compute produced rotational impulse velocity
    var rotVelo = Body_applyImpulse_rotVelo;
    r.cross(impulse,rotVelo);

    /*
    rotVelo.x *= this.invInertia.x;
    rotVelo.y *= this.invInertia.y;
    rotVelo.z *= this.invInertia.z;
    */
    this.invInertiaWorld.vmult(rotVelo,rotVelo);

    // Add rotational Impulse
    this.angularVelocity.vadd(rotVelo, this.angularVelocity);
};

/**
 * Apply locally-defined impulse to a local point in the body.
 * @method applyLocalImpulse
 * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
 * @param  {Vec3} localPoint A local point in the body to apply the force on.
 */
var Body_applyLocalImpulse_worldImpulse = new Vec3();
var Body_applyLocalImpulse_relativePoint = new Vec3();
Body.prototype.applyLocalImpulse = function(localImpulse, localPoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    var worldImpulse = Body_applyLocalImpulse_worldImpulse;
    var relativePointWorld = Body_applyLocalImpulse_relativePoint;

    // Transform the force vector to world space
    this.vectorToWorldFrame(localImpulse, worldImpulse);
    this.vectorToWorldFrame(localPoint, relativePointWorld);

    this.applyImpulse(worldImpulse, relativePointWorld);
};

var Body_updateMassProperties_halfExtents = new Vec3();

/**
 * Should be called whenever you change the body shape or mass.
 * @method updateMassProperties
 */
Body.prototype.updateMassProperties = function(){
    var halfExtents = Body_updateMassProperties_halfExtents;

    this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
    var I = this.inertia;
    var fixed = this.fixedRotation;

    // Approximate with AABB box
    this.computeAABB();
    halfExtents.set(
        (this.aabb.upperBound.x-this.aabb.lowerBound.x) / 2,
        (this.aabb.upperBound.y-this.aabb.lowerBound.y) / 2,
        (this.aabb.upperBound.z-this.aabb.lowerBound.z) / 2
    );
    Box.calculateInertia(halfExtents, this.mass, I);

    this.invInertia.set(
        I.x > 0 && !fixed ? 1.0 / I.x : 0,
        I.y > 0 && !fixed ? 1.0 / I.y : 0,
        I.z > 0 && !fixed ? 1.0 / I.z : 0
    );
    this.updateInertiaWorld(true);
};

/**
 * Get world velocity of a point in the body.
 * @method getVelocityAtWorldPoint
 * @param  {Vec3} worldPoint
 * @param  {Vec3} result
 * @return {Vec3} The result vector.
 */
Body.prototype.getVelocityAtWorldPoint = function(worldPoint, result){
    var r = new Vec3();
    worldPoint.vsub(this.position, r);
    this.angularVelocity.cross(r, result);
    this.velocity.vadd(result, result);
    return result;
};

var torque = new Vec3();
var invI_tau_dt = new Vec3();
var w = new Quaternion();
var wq = new Quaternion();

/**
 * Move the body forward in time.
 * @param {number} dt Time step
 * @param {boolean} quatNormalize Set to true to normalize the body quaternion
 * @param {boolean} quatNormalizeFast If the quaternion should be normalized using "fast" quaternion normalization
 */
Body.prototype.integrate = function(dt, quatNormalize, quatNormalizeFast){

    // Save previous position
    this.previousPosition.copy(this.position);
    this.previousQuaternion.copy(this.quaternion);

    if(!(this.type === Body.DYNAMIC || this.type === Body.KINEMATIC) || this.sleepState === Body.SLEEPING){ // Only for dynamic
        return;
    }

    var velo = this.velocity,
        angularVelo = this.angularVelocity,
        pos = this.position,
        force = this.force,
        torque = this.torque,
        quat = this.quaternion,
        invMass = this.invMass,
        invInertia = this.invInertiaWorld,
        linearFactor = this.linearFactor;

    velo.x += force.x * invMass * dt * linearFactor.x;
    velo.y += force.y * invMass * dt * linearFactor.y;
    velo.z += force.z * invMass * dt * linearFactor.z;

    var e = invInertia.elements;
    angularVelo.x += dt * (e[0] * torque.x + e[1] * torque.y + e[2] * torque.z);
    angularVelo.y += dt * (e[3] * torque.x + e[4] * torque.y + e[5] * torque.z);
    angularVelo.z += dt * (e[6] * torque.x + e[7] * torque.y + e[8] * torque.z);

    // Use new velocity  - leap frog
    pos.x += velo.x * dt;
    pos.y += velo.y * dt;
    pos.z += velo.z * dt;

    quat.integrate(this.angularVelocity, dt, this.angularFactor, quat);

    if(quatNormalize){
        if(quatNormalizeFast){
            quat.normalizeFast();
        } else {
            quat.normalize();
        }
    }

    this.aabbNeedsUpdate = true;

    // Update world inertia
    this.updateInertiaWorld();
};
},{"../collision/AABB":6,"../material/Material":28,"../math/Mat3":30,"../math/Quaternion":31,"../math/Vec3":33,"../shapes/Box":40,"../shapes/Shape":46,"../utils/EventTarget":52}],35:[function(require,module,exports){
var Body = require('./Body');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var RaycastResult = require('../collision/RaycastResult');
var Ray = require('../collision/Ray');
var WheelInfo = require('../objects/WheelInfo');

module.exports = RaycastVehicle;

/**
 * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
 * @class RaycastVehicle
 * @constructor
 * @param {object} [options]
 * @param {Body} [options.chassisBody] The car chassis body.
 * @param {integer} [options.indexRightAxis] Axis to use for right. x=0, y=1, z=2
 * @param {integer} [options.indexLeftAxis]
 * @param {integer} [options.indexUpAxis]
 */
function RaycastVehicle(options){

    /**
     * @property {Body} chassisBody
     */
    this.chassisBody = options.chassisBody;

    /**
     * An array of WheelInfo objects.
     * @property {array} wheelInfos
     */
    this.wheelInfos = [];

    /**
     * Will be set to true if the car is sliding.
     * @property {boolean} sliding
     */
    this.sliding = false;

    /**
     * @property {World} world
     */
    this.world = null;

    /**
     * Index of the right axis, 0=x, 1=y, 2=z
     * @property {integer} indexRightAxis
     * @default 1
     */
    this.indexRightAxis = typeof(options.indexRightAxis) !== 'undefined' ? options.indexRightAxis : 1;

    /**
     * Index of the forward axis, 0=x, 1=y, 2=z
     * @property {integer} indexForwardAxis
     * @default 0
     */
    this.indexForwardAxis = typeof(options.indexForwardAxis) !== 'undefined' ? options.indexForwardAxis : 0;

    /**
     * Index of the up axis, 0=x, 1=y, 2=z
     * @property {integer} indexUpAxis
     * @default 2
     */
    this.indexUpAxis = typeof(options.indexUpAxis) !== 'undefined' ? options.indexUpAxis : 2;
}

var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();
var tmpVec3 = new Vec3();
var tmpVec4 = new Vec3();
var tmpVec5 = new Vec3();
var tmpVec6 = new Vec3();
var tmpRay = new Ray();

/**
 * Add a wheel. For information about the options, see WheelInfo.
 * @method addWheel
 * @param {object} [options]
 */
RaycastVehicle.prototype.addWheel = function(options){
    options = options || {};

    var info = new WheelInfo(options);
    var index = this.wheelInfos.length;
    this.wheelInfos.push(info);

    return index;
};

/**
 * Set the steering value of a wheel.
 * @method setSteeringValue
 * @param {number} value
 * @param {integer} wheelIndex
 */
RaycastVehicle.prototype.setSteeringValue = function(value, wheelIndex){
    var wheel = this.wheelInfos[wheelIndex];
    wheel.steering = value;
};

var torque = new Vec3();

/**
 * Set the wheel force to apply on one of the wheels each time step
 * @method applyEngineForce
 * @param  {number} value
 * @param  {integer} wheelIndex
 */
RaycastVehicle.prototype.applyEngineForce = function(value, wheelIndex){
    this.wheelInfos[wheelIndex].engineForce = value;
};

/**
 * Set the braking force of a wheel
 * @method setBrake
 * @param {number} brake
 * @param {integer} wheelIndex
 */
RaycastVehicle.prototype.setBrake = function(brake, wheelIndex){
    this.wheelInfos[wheelIndex].brake = brake;
};

/**
 * Add the vehicle including its constraints to the world.
 * @method addToWorld
 * @param {World} world
 */
RaycastVehicle.prototype.addToWorld = function(world){
    var constraints = this.constraints;
    world.addBody(this.chassisBody);
    var that = this;
    this.preStepCallback = function(){
        that.updateVehicle(world.dt);
    };
    world.addEventListener('preStep', this.preStepCallback);
    this.world = world;
};

/**
 * Get one of the wheel axles, world-oriented.
 * @private
 * @method getVehicleAxisWorld
 * @param  {integer} axisIndex
 * @param  {Vec3} result
 */
RaycastVehicle.prototype.getVehicleAxisWorld = function(axisIndex, result){
    result.set(
        axisIndex === 0 ? 1 : 0,
        axisIndex === 1 ? 1 : 0,
        axisIndex === 2 ? 1 : 0
    );
    this.chassisBody.vectorToWorldFrame(result, result);
};

RaycastVehicle.prototype.updateVehicle = function(timeStep){
    var wheelInfos = this.wheelInfos;
    var numWheels = wheelInfos.length;
    var chassisBody = this.chassisBody;

    for (var i = 0; i < numWheels; i++) {
        this.updateWheelTransform(i);
    }

    this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();

    var forwardWorld = new Vec3();
    this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);

    if (forwardWorld.dot(chassisBody.velocity) < 0){
        this.currentVehicleSpeedKmHour *= -1;
    }

    // simulate suspension
    for (var i = 0; i < numWheels; i++) {
        this.castRay(wheelInfos[i]);
    }

    this.updateSuspension(timeStep);

    var impulse = new Vec3();
    var relpos = new Vec3();
    for (var i = 0; i < numWheels; i++) {
        //apply suspension force
        var wheel = wheelInfos[i];
        var suspensionForce = wheel.suspensionForce;
        if (suspensionForce > wheel.maxSuspensionForce) {
            suspensionForce = wheel.maxSuspensionForce;
        }
        wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);

        wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);
        chassisBody.applyImpulse(impulse, relpos);
    }

    this.updateFriction(timeStep);

    var hitNormalWorldScaledWithProj = new Vec3();
    var fwd  = new Vec3();
    var vel = new Vec3();
    for (i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];
        //var relpos = new Vec3();
        //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);
        chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel);

        // Hack to get the rotation in the correct direction
        var m = 1;
        switch(this.indexUpAxis){
        case 1:
            m = -1;
            break;
        }

        if (wheel.isInContact) {

            this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
            var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
            wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);

            fwd.vsub(hitNormalWorldScaledWithProj, fwd);

            var proj2 = fwd.dot(vel);
            wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
        }

        if((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed){
            // Apply custom rotation when accelerating and sliding
            wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
        }

        // Lock wheels
        if(Math.abs(wheel.brake) > Math.abs(wheel.engineForce)){
            wheel.deltaRotation = 0;
        }

        wheel.rotation += wheel.deltaRotation; // Use the old value
        wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
    }
};

RaycastVehicle.prototype.updateSuspension = function(deltaTime) {
    var chassisBody = this.chassisBody;
    var chassisMass = chassisBody.mass;
    var wheelInfos = this.wheelInfos;
    var numWheels = wheelInfos.length;

    for (var w_it = 0; w_it < numWheels; w_it++){
        var wheel = wheelInfos[w_it];

        if (wheel.isInContact){
            var force;

            // Spring
            var susp_length = wheel.suspensionRestLength;
            var current_length = wheel.suspensionLength;
            var length_diff = (susp_length - current_length);

            force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;

            // Damper
            var projected_rel_vel = wheel.suspensionRelativeVelocity;
            var susp_damping;
            if (projected_rel_vel < 0) {
                susp_damping = wheel.dampingCompression;
            } else {
                susp_damping = wheel.dampingRelaxation;
            }
            force -= susp_damping * projected_rel_vel;

            wheel.suspensionForce = force * chassisMass;
            if (wheel.suspensionForce < 0) {
                wheel.suspensionForce = 0;
            }
        } else {
            wheel.suspensionForce = 0;
        }
    }
};

/**
 * Remove the vehicle including its constraints from the world.
 * @method removeFromWorld
 * @param {World} world
 */
RaycastVehicle.prototype.removeFromWorld = function(world){
    var constraints = this.constraints;
    world.remove(this.chassisBody);
    world.removeEventListener('preStep', this.preStepCallback);
    this.world = null;
};

var castRay_rayvector = new Vec3();
var castRay_target = new Vec3();
RaycastVehicle.prototype.castRay = function(wheel) {
    var rayvector = castRay_rayvector;
    var target = castRay_target;

    this.updateWheelTransformWorld(wheel);
    var chassisBody = this.chassisBody;

    var depth = -1;

    var raylen = wheel.suspensionRestLength + wheel.radius;

    wheel.directionWorld.scale(raylen, rayvector);
    var source = wheel.chassisConnectionPointWorld;
    source.vadd(rayvector, target);
    var raycastResult = wheel.raycastResult;

    var param = 0;

    raycastResult.reset();
    // Turn off ray collision with the chassis temporarily
    var oldState = chassisBody.collisionResponse;
    chassisBody.collisionResponse = false;

    // Cast ray against world
    this.world.rayTest(source, target, raycastResult);
    chassisBody.collisionResponse = oldState;

    var object = raycastResult.body;

    wheel.raycastResult.groundObject = 0;

    if (object) {
        depth = raycastResult.distance;
        wheel.raycastResult.hitNormalWorld  = raycastResult.hitNormalWorld;
        wheel.isInContact = true;

        var hitDistance = raycastResult.distance;
        wheel.suspensionLength = hitDistance - wheel.radius;

        // clamp on max suspension travel
        var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;
        var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;
        if (wheel.suspensionLength < minSuspensionLength) {
            wheel.suspensionLength = minSuspensionLength;
        }
        if (wheel.suspensionLength > maxSuspensionLength) {
            wheel.suspensionLength = maxSuspensionLength;
            wheel.raycastResult.reset();
        }

        var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);

        var chassis_velocity_at_contactPoint = new Vec3();
        chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);

        var projVel = wheel.raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );

        if (denominator >= -0.1) {
            wheel.suspensionRelativeVelocity = 0;
            wheel.clippedInvContactDotSuspension = 1 / 0.1;
        } else {
            var inv = -1 / denominator;
            wheel.suspensionRelativeVelocity = projVel * inv;
            wheel.clippedInvContactDotSuspension = inv;
        }

    } else {

        //put wheel info as in rest position
        wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
        wheel.suspensionRelativeVelocity = 0.0;
        wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);
        wheel.clippedInvContactDotSuspension = 1.0;
    }

    return depth;
};

RaycastVehicle.prototype.updateWheelTransformWorld = function(wheel){
    wheel.isInContact = false;
    var chassisBody = this.chassisBody;
    chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);
    chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);
    chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
};


/**
 * Update one of the wheel transform.
 * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
 * @method updateWheelTransform
 * @param {integer} wheelIndex The wheel index to update.
 */
RaycastVehicle.prototype.updateWheelTransform = function(wheelIndex){
    var up = tmpVec4;
    var right = tmpVec5;
    var fwd = tmpVec6;

    var wheel = this.wheelInfos[wheelIndex];
    this.updateWheelTransformWorld(wheel);

    wheel.directionLocal.scale(-1, up);
    right.copy(wheel.axleLocal);
    up.cross(right, fwd);
    fwd.normalize();
    right.normalize();

    // Rotate around steering over the wheelAxle
    var steering = wheel.steering;
    var steeringOrn = new Quaternion();
    steeringOrn.setFromAxisAngle(up, steering);

    var rotatingOrn = new Quaternion();
    rotatingOrn.setFromAxisAngle(right, wheel.rotation);

    // World rotation of the wheel
    var q = wheel.worldTransform.quaternion;
    this.chassisBody.quaternion.mult(steeringOrn, q);
    q.mult(rotatingOrn, q);

    q.normalize();

    // world position of the wheel
    var p = wheel.worldTransform.position;
    p.copy(wheel.directionWorld);
    p.scale(wheel.suspensionLength, p);
    p.vadd(wheel.chassisConnectionPointWorld, p);
};

var directions = [
    new Vec3(1, 0, 0),
    new Vec3(0, 1, 0),
    new Vec3(0, 0, 1)
];

/**
 * Get the world transform of one of the wheels
 * @method getWheelTransformWorld
 * @param  {integer} wheelIndex
 * @return {Transform}
 */
RaycastVehicle.prototype.getWheelTransformWorld = function(wheelIndex) {
    return this.wheelInfos[wheelIndex].worldTransform;
};


var updateFriction_surfNormalWS_scaled_proj = new Vec3();
var updateFriction_axle = [];
var updateFriction_forwardWS = [];
var sideFrictionStiffness2 = 1;
RaycastVehicle.prototype.updateFriction = function(timeStep) {
    var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj;

    //calculate the impulse, so that the wheels don't move sidewards
    var wheelInfos = this.wheelInfos;
    var numWheels = wheelInfos.length;
    var chassisBody = this.chassisBody;
    var forwardWS = updateFriction_forwardWS;
    var axle = updateFriction_axle;

    var numWheelsOnGround = 0;

    for (var i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];

        var groundObject = wheel.raycastResult.body;
        if (groundObject){
            numWheelsOnGround++;
        }

        wheel.sideImpulse = 0;
        wheel.forwardImpulse = 0;
        if(!forwardWS[i]){
            forwardWS[i] = new Vec3();
        }
        if(!axle[i]){
            axle[i] = new Vec3();
        }
    }

    for (var i = 0; i < numWheels; i++){
        var wheel = wheelInfos[i];

        var groundObject = wheel.raycastResult.body;

        if (groundObject) {
            var axlei = axle[i];
            var wheelTrans = this.getWheelTransformWorld(i);

            // Get world axle
            wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);

            var surfNormalWS = wheel.raycastResult.hitNormalWorld;
            var proj = axlei.dot(surfNormalWS);
            surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
            axlei.vsub(surfNormalWS_scaled_proj, axlei);
            axlei.normalize();

            surfNormalWS.cross(axlei, forwardWS[i]);
            forwardWS[i].normalize();

            wheel.sideImpulse = resolveSingleBilateral(
                chassisBody,
                wheel.raycastResult.hitPointWorld,
                groundObject,
                wheel.raycastResult.hitPointWorld,
                axlei
            );

            wheel.sideImpulse *= sideFrictionStiffness2;
        }
    }

    var sideFactor = 1;
    var fwdFactor = 0.5;

    this.sliding = false;
    for (var i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];
        var groundObject = wheel.raycastResult.body;

        var rollingFriction = 0;

        wheel.slipInfo = 1;
        if (groundObject) {
            var defaultRollingFrictionImpulse = 0;
            var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse;

            // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
            // rollingFriction = calcRollingFriction(contactPt);
            rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);

            rollingFriction += wheel.engineForce * timeStep;

            // rollingFriction = 0;
            var factor = maxImpulse / rollingFriction;
            wheel.slipInfo *= factor;
        }

        //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)

        wheel.forwardImpulse = 0;
        wheel.skidInfo = 1;

        if (groundObject) {
            wheel.skidInfo = 1;

            var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
            var maximpSide = maximp;

            var maximpSquared = maximp * maximpSide;

            wheel.forwardImpulse = rollingFriction;//wheelInfo.engineForce* timeStep;

            var x = wheel.forwardImpulse * fwdFactor;
            var y = wheel.sideImpulse * sideFactor;

            var impulseSquared = x * x + y * y;

            wheel.sliding = false;
            if (impulseSquared > maximpSquared) {
                this.sliding = true;
                wheel.sliding = true;

                var factor = maximp / Math.sqrt(impulseSquared);

                wheel.skidInfo *= factor;
            }
        }
    }

    if (this.sliding) {
        for (var i = 0; i < numWheels; i++) {
            var wheel = wheelInfos[i];
            if (wheel.sideImpulse !== 0) {
                if (wheel.skidInfo < 1){
                    wheel.forwardImpulse *= wheel.skidInfo;
                    wheel.sideImpulse *= wheel.skidInfo;
                }
            }
        }
    }

    // apply the impulses
    for (var i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];

        var rel_pos = new Vec3();
        wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos);
        // cannons applyimpulse is using world coord for the position
        //rel_pos.copy(wheel.raycastResult.hitPointWorld);

        if (wheel.forwardImpulse !== 0) {
            var impulse = new Vec3();
            forwardWS[i].scale(wheel.forwardImpulse, impulse);
            chassisBody.applyImpulse(impulse, rel_pos);
        }

        if (wheel.sideImpulse !== 0){
            var groundObject = wheel.raycastResult.body;

            var rel_pos2 = new Vec3();
            wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2);
            //rel_pos2.copy(wheel.raycastResult.hitPointWorld);
            var sideImp = new Vec3();
            axle[i].scale(wheel.sideImpulse, sideImp);

            // Scale the relative position in the up direction with rollInfluence.
            // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).
            chassisBody.vectorToLocalFrame(rel_pos, rel_pos);
            rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;
            chassisBody.vectorToWorldFrame(rel_pos, rel_pos);
            chassisBody.applyImpulse(sideImp, rel_pos);

            //apply friction impulse on the ground
            sideImp.scale(-1, sideImp);
            groundObject.applyImpulse(sideImp, rel_pos2);
        }
    }
};

var calcRollingFriction_vel1 = new Vec3();
var calcRollingFriction_vel2 = new Vec3();
var calcRollingFriction_vel = new Vec3();

function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
    var j1 = 0;
    var contactPosWorld = frictionPosWorld;

    // var rel_pos1 = new Vec3();
    // var rel_pos2 = new Vec3();
    var vel1 = calcRollingFriction_vel1;
    var vel2 = calcRollingFriction_vel2;
    var vel = calcRollingFriction_vel;
    // contactPosWorld.vsub(body0.position, rel_pos1);
    // contactPosWorld.vsub(body1.position, rel_pos2);

    body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
    body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
    vel1.vsub(vel2, vel);

    var vrel = frictionDirectionWorld.dot(vel);

    var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
    var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
    var relaxation = 1;
    var jacDiagABInv = relaxation / (denom0 + denom1);

    // calculate j that moves us to zero relative velocity
    j1 = -vrel * jacDiagABInv;

    if (maxImpulse < j1) {
        j1 = maxImpulse;
    }
    if (j1 < -maxImpulse) {
        j1 = -maxImpulse;
    }

    return j1;
}

var computeImpulseDenominator_r0 = new Vec3();
var computeImpulseDenominator_c0 = new Vec3();
var computeImpulseDenominator_vec = new Vec3();
var computeImpulseDenominator_m = new Vec3();
function computeImpulseDenominator(body, pos, normal) {
    var r0 = computeImpulseDenominator_r0;
    var c0 = computeImpulseDenominator_c0;
    var vec = computeImpulseDenominator_vec;
    var m = computeImpulseDenominator_m;

    pos.vsub(body.position, r0);
    r0.cross(normal, c0);
    body.invInertiaWorld.vmult(c0, m);
    m.cross(r0, vec);

    return body.invMass + normal.dot(vec);
}


var resolveSingleBilateral_vel1 = new Vec3();
var resolveSingleBilateral_vel2 = new Vec3();
var resolveSingleBilateral_vel = new Vec3();

//bilateral constraint between two dynamic objects
function resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse){
    var normalLenSqr = normal.norm2();
    if (normalLenSqr > 1.1){
        return 0; // no impulse
    }
    // var rel_pos1 = new Vec3();
    // var rel_pos2 = new Vec3();
    // pos1.vsub(body1.position, rel_pos1);
    // pos2.vsub(body2.position, rel_pos2);

    var vel1 = resolveSingleBilateral_vel1;
    var vel2 = resolveSingleBilateral_vel2;
    var vel = resolveSingleBilateral_vel;
    body1.getVelocityAtWorldPoint(pos1, vel1);
    body2.getVelocityAtWorldPoint(pos2, vel2);

    vel1.vsub(vel2, vel);

    var rel_vel = normal.dot(vel);

    var contactDamping = 0.2;
    var massTerm = 1 / (body1.invMass + body2.invMass);
    var impulse = - contactDamping * rel_vel * massTerm;

    return impulse;
}
},{"../collision/Ray":12,"../collision/RaycastResult":13,"../math/Quaternion":31,"../math/Vec3":33,"../objects/WheelInfo":39,"./Body":34}],36:[function(require,module,exports){
var Body = require('./Body');
var Sphere = require('../shapes/Sphere');
var Box = require('../shapes/Box');
var Vec3 = require('../math/Vec3');
var HingeConstraint = require('../constraints/HingeConstraint');

module.exports = RigidVehicle;

/**
 * Simple vehicle helper class with spherical rigid body wheels.
 * @class RigidVehicle
 * @constructor
 * @param {Body} [options.chassisBody]
 */
function RigidVehicle(options){
    this.wheelBodies = [];

    /**
     * @property coordinateSystem
     * @type {Vec3}
     */
    this.coordinateSystem = typeof(options.coordinateSystem)==='undefined' ? new Vec3(1, 2, 3) : options.coordinateSystem.clone();

    /**
     * @property {Body} chassisBody
     */
    this.chassisBody = options.chassisBody;

    if(!this.chassisBody){
        // No chassis body given. Create it!
        var chassisShape = new Box(new Vec3(5, 2, 0.5));
        this.chassisBody = new Body(1, chassisShape);
    }

    /**
     * @property constraints
     * @type {Array}
     */
    this.constraints = [];

    this.wheelAxes = [];
    this.wheelForces = [];
}

/**
 * Add a wheel
 * @method addWheel
 * @param {object} options
 * @param {boolean} [options.isFrontWheel]
 * @param {Vec3} [options.position] Position of the wheel, locally in the chassis body.
 * @param {Vec3} [options.direction] Slide direction of the wheel along the suspension.
 * @param {Vec3} [options.axis] Axis of rotation of the wheel, locally defined in the chassis.
 * @param {Body} [options.body] The wheel body.
 */
RigidVehicle.prototype.addWheel = function(options){
    options = options || {};
    var wheelBody = options.body;
    if(!wheelBody){
        wheelBody =  new Body(1, new Sphere(1.2));
    }
    this.wheelBodies.push(wheelBody);
    this.wheelForces.push(0);

    // Position constrain wheels
    var zero = new Vec3();
    var position = typeof(options.position) !== 'undefined' ? options.position.clone() : new Vec3();

    // Set position locally to the chassis
    var worldPosition = new Vec3();
    this.chassisBody.pointToWorldFrame(position, worldPosition);
    wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z);

    // Constrain wheel
    var axis = typeof(options.axis) !== 'undefined' ? options.axis.clone() : new Vec3(0, 1, 0);
    this.wheelAxes.push(axis);

    var hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {
        pivotA: position,
        axisA: axis,
        pivotB: Vec3.ZERO,
        axisB: axis,
        collideConnected: false
    });
    this.constraints.push(hingeConstraint);

    return this.wheelBodies.length - 1;
};

/**
 * Set the steering value of a wheel.
 * @method setSteeringValue
 * @param {number} value
 * @param {integer} wheelIndex
 * @todo check coordinateSystem
 */
RigidVehicle.prototype.setSteeringValue = function(value, wheelIndex){
    // Set angle of the hinge axis
    var axis = this.wheelAxes[wheelIndex];

    var c = Math.cos(value),
        s = Math.sin(value),
        x = axis.x,
        y = axis.y;
    this.constraints[wheelIndex].axisA.set(
        c*x -s*y,
        s*x +c*y,
        0
    );
};

/**
 * Set the target rotational speed of the hinge constraint.
 * @method setMotorSpeed
 * @param {number} value
 * @param {integer} wheelIndex
 */
RigidVehicle.prototype.setMotorSpeed = function(value, wheelIndex){
    var hingeConstraint = this.constraints[wheelIndex];
    hingeConstraint.enableMotor();
    hingeConstraint.motorTargetVelocity = value;
};

/**
 * Set the target rotational speed of the hinge constraint.
 * @method disableMotor
 * @param {number} value
 * @param {integer} wheelIndex
 */
RigidVehicle.prototype.disableMotor = function(wheelIndex){
    var hingeConstraint = this.constraints[wheelIndex];
    hingeConstraint.disableMotor();
};

var torque = new Vec3();

/**
 * Set the wheel force to apply on one of the wheels each time step
 * @method setWheelForce
 * @param  {number} value
 * @param  {integer} wheelIndex
 */
RigidVehicle.prototype.setWheelForce = function(value, wheelIndex){
    this.wheelForces[wheelIndex] = value;
};

/**
 * Apply a torque on one of the wheels.
 * @method applyWheelForce
 * @param  {number} value
 * @param  {integer} wheelIndex
 */
RigidVehicle.prototype.applyWheelForce = function(value, wheelIndex){
    var axis = this.wheelAxes[wheelIndex];
    var wheelBody = this.wheelBodies[wheelIndex];
    var bodyTorque = wheelBody.torque;

    axis.scale(value, torque);
    wheelBody.vectorToWorldFrame(torque, torque);
    bodyTorque.vadd(torque, bodyTorque);
};

/**
 * Add the vehicle including its constraints to the world.
 * @method addToWorld
 * @param {World} world
 */
RigidVehicle.prototype.addToWorld = function(world){
    var constraints = this.constraints;
    var bodies = this.wheelBodies.concat([this.chassisBody]);

    for (var i = 0; i < bodies.length; i++) {
        world.addBody(bodies[i]);
    }

    for (var i = 0; i < constraints.length; i++) {
        world.addConstraint(constraints[i]);
    }

    world.addEventListener('preStep', this._update.bind(this));
};

RigidVehicle.prototype._update = function(){
    var wheelForces = this.wheelForces;
    for (var i = 0; i < wheelForces.length; i++) {
        this.applyWheelForce(wheelForces[i], i);
    }
};

/**
 * Remove the vehicle including its constraints from the world.
 * @method removeFromWorld
 * @param {World} world
 */
RigidVehicle.prototype.removeFromWorld = function(world){
    var constraints = this.constraints;
    var bodies = this.wheelBodies.concat([this.chassisBody]);

    for (var i = 0; i < bodies.length; i++) {
        world.remove(bodies[i]);
    }

    for (var i = 0; i < constraints.length; i++) {
        world.removeConstraint(constraints[i]);
    }
};

var worldAxis = new Vec3();

/**
 * Get current rotational velocity of a wheel
 * @method getWheelSpeed
 * @param {integer} wheelIndex
 */
RigidVehicle.prototype.getWheelSpeed = function(wheelIndex){
    var axis = this.wheelAxes[wheelIndex];
    var wheelBody = this.wheelBodies[wheelIndex];
    var w = wheelBody.angularVelocity;
    this.chassisBody.vectorToWorldFrame(axis, worldAxis);
    return w.dot(worldAxis);
};

},{"../constraints/HingeConstraint":18,"../math/Vec3":33,"../shapes/Box":40,"../shapes/Sphere":47,"./Body":34}],37:[function(require,module,exports){
module.exports = SPHSystem;

var Shape = require('../shapes/Shape');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Particle = require('../shapes/Particle');
var Body = require('../objects/Body');
var Material = require('../material/Material');

/**
 * Smoothed-particle hydrodynamics system
 * @class SPHSystem
 * @constructor
 */
function SPHSystem(){
    this.particles = [];
	
    /**
     * Density of the system (kg/m3).
     * @property {number} density
     */
    this.density = 1;
	
    /**
     * Distance below which two particles are considered to be neighbors.
     * It should be adjusted so there are about 15-20 neighbor particles within this radius.
     * @property {number} smoothingRadius
     */
    this.smoothingRadius = 1;
    this.speedOfSound = 1;
	
    /**
     * Viscosity of the system.
     * @property {number} viscosity
     */
    this.viscosity = 0.01;
    this.eps = 0.000001;

    // Stuff Computed per particle
    this.pressures = [];
    this.densities = [];
    this.neighbors = [];
}

/**
 * Add a particle to the system.
 * @method add
 * @param {Body} particle
 */
SPHSystem.prototype.add = function(particle){
    this.particles.push(particle);
    if(this.neighbors.length < this.particles.length){
        this.neighbors.push([]);
    }
};

/**
 * Remove a particle from the system.
 * @method remove
 * @param {Body} particle
 */
SPHSystem.prototype.remove = function(particle){
    var idx = this.particles.indexOf(particle);
    if(idx !== -1){
        this.particles.splice(idx,1);
        if(this.neighbors.length > this.particles.length){
            this.neighbors.pop();
        }
    }
};

/**
 * Get neighbors within smoothing volume, save in the array neighbors
 * @method getNeighbors
 * @param {Body} particle
 * @param {Array} neighbors
 */
var SPHSystem_getNeighbors_dist = new Vec3();
SPHSystem.prototype.getNeighbors = function(particle,neighbors){
    var N = this.particles.length,
        id = particle.id,
        R2 = this.smoothingRadius * this.smoothingRadius,
        dist = SPHSystem_getNeighbors_dist;
    for(var i=0; i!==N; i++){
        var p = this.particles[i];
        p.position.vsub(particle.position,dist);
        if(id!==p.id && dist.norm2() < R2){
            neighbors.push(p);
        }
    }
};

// Temp vectors for calculation
var SPHSystem_update_dist = new Vec3(),
    SPHSystem_update_a_pressure = new Vec3(),
    SPHSystem_update_a_visc = new Vec3(),
    SPHSystem_update_gradW = new Vec3(),
    SPHSystem_update_r_vec = new Vec3(),
    SPHSystem_update_u = new Vec3(); // Relative velocity
SPHSystem.prototype.update = function(){
    var N = this.particles.length,
        dist = SPHSystem_update_dist,
        cs = this.speedOfSound,
        eps = this.eps;

    for(var i=0; i!==N; i++){
        var p = this.particles[i]; // Current particle
        var neighbors = this.neighbors[i];

        // Get neighbors
        neighbors.length = 0;
        this.getNeighbors(p,neighbors);
        neighbors.push(this.particles[i]); // Add current too
        var numNeighbors = neighbors.length;

        // Accumulate density for the particle
        var sum = 0.0;
        for(var j=0; j!==numNeighbors; j++){

            //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
            p.position.vsub(neighbors[j].position, dist);
            var len = dist.norm();

            var weight = this.w(len);
            sum += neighbors[j].mass * weight;
        }

        // Save
        this.densities[i] = sum;
        this.pressures[i] = cs * cs * (this.densities[i] - this.density);
    }

    // Add forces

    // Sum to these accelerations
    var a_pressure= SPHSystem_update_a_pressure;
    var a_visc =    SPHSystem_update_a_visc;
    var gradW =     SPHSystem_update_gradW;
    var r_vec =     SPHSystem_update_r_vec;
    var u =         SPHSystem_update_u;

    for(var i=0; i!==N; i++){

        var particle = this.particles[i];

        a_pressure.set(0,0,0);
        a_visc.set(0,0,0);

        // Init vars
        var Pij;
        var nabla;
        var Vij;

        // Sum up for all other neighbors
        var neighbors = this.neighbors[i];
        var numNeighbors = neighbors.length;

        //printf("Neighbors: ");
        for(var j=0; j!==numNeighbors; j++){

            var neighbor = neighbors[j];
            //printf("%d ",nj);

            // Get r once for all..
            particle.position.vsub(neighbor.position,r_vec);
            var r = r_vec.norm();

            // Pressure contribution
            Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i]*this.densities[i] + eps) + this.pressures[j] / (this.densities[j]*this.densities[j] + eps));
            this.gradw(r_vec, gradW);
            // Add to pressure acceleration
            gradW.mult(Pij , gradW);
            a_pressure.vadd(gradW, a_pressure);

            // Viscosity contribution
            neighbor.velocity.vsub(particle.velocity, u);
            u.mult( 1.0 / (0.0001+this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass , u );
            nabla = this.nablaw(r);
            u.mult(nabla,u);
            // Add to viscosity acceleration
            a_visc.vadd( u, a_visc );
        }

        // Calculate force
        a_visc.mult(particle.mass, a_visc);
        a_pressure.mult(particle.mass, a_pressure);

        // Add force to particles
        particle.force.vadd(a_visc, particle.force);
        particle.force.vadd(a_pressure, particle.force);
    }
};

// Calculate the weight using the W(r) weightfunction
SPHSystem.prototype.w = function(r){
    // 315
    var h = this.smoothingRadius;
    return 315.0/(64.0*Math.PI*Math.pow(h,9)) * Math.pow(h*h-r*r,3);
};

// calculate gradient of the weight function
SPHSystem.prototype.gradw = function(rVec,resultVec){
    var r = rVec.norm(),
        h = this.smoothingRadius;
    rVec.mult(945.0/(32.0*Math.PI*Math.pow(h,9)) * Math.pow((h*h-r*r),2) , resultVec);
};

// Calculate nabla(W)
SPHSystem.prototype.nablaw = function(r){
    var h = this.smoothingRadius;
    var nabla = 945.0/(32.0*Math.PI*Math.pow(h,9)) * (h*h-r*r)*(7*r*r - 3*h*h);
    return nabla;
};

},{"../material/Material":28,"../math/Quaternion":31,"../math/Vec3":33,"../objects/Body":34,"../shapes/Particle":44,"../shapes/Shape":46}],38:[function(require,module,exports){
var Vec3 = require('../math/Vec3');

module.exports = Spring;

/**
 * A spring, connecting two bodies.
 *
 * @class Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restLength]   A number > 0. Default: 1
 * @param {number} [options.stiffness]    A number >= 0. Default: 100
 * @param {number} [options.damping]      A number >= 0. Default: 1
 * @param {Vec3}  [options.worldAnchorA] Where to hook the spring to body A, in world coordinates.
 * @param {Vec3}  [options.worldAnchorB]
 * @param {Vec3}  [options.localAnchorA] Where to hook the spring to body A, in local body coordinates.
 * @param {Vec3}  [options.localAnchorB]
 */
function Spring(bodyA,bodyB,options){
    options = options || {};

    /**
     * Rest length of the spring.
     * @property restLength
     * @type {number}
     */
    this.restLength = typeof(options.restLength) === "number" ? options.restLength : 1;

    /**
     * Stiffness of the spring.
     * @property stiffness
     * @type {number}
     */
    this.stiffness = options.stiffness || 100;

    /**
     * Damping of the spring.
     * @property damping
     * @type {number}
     */
    this.damping = options.damping || 1;

    /**
     * First connected body.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second connected body.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * Anchor for bodyA in local bodyA coordinates.
     * @property localAnchorA
     * @type {Vec3}
     */
    this.localAnchorA = new Vec3();

    /**
     * Anchor for bodyB in local bodyB coordinates.
     * @property localAnchorB
     * @type {Vec3}
     */
    this.localAnchorB = new Vec3();

    if(options.localAnchorA){
        this.localAnchorA.copy(options.localAnchorA);
    }
    if(options.localAnchorB){
        this.localAnchorB.copy(options.localAnchorB);
    }
    if(options.worldAnchorA){
        this.setWorldAnchorA(options.worldAnchorA);
    }
    if(options.worldAnchorB){
        this.setWorldAnchorB(options.worldAnchorB);
    }
}

/**
 * Set the anchor point on body A, using world coordinates.
 * @method setWorldAnchorA
 * @param {Vec3} worldAnchorA
 */
Spring.prototype.setWorldAnchorA = function(worldAnchorA){
    this.bodyA.pointToLocalFrame(worldAnchorA,this.localAnchorA);
};

/**
 * Set the anchor point on body B, using world coordinates.
 * @method setWorldAnchorB
 * @param {Vec3} worldAnchorB
 */
Spring.prototype.setWorldAnchorB = function(worldAnchorB){
    this.bodyB.pointToLocalFrame(worldAnchorB,this.localAnchorB);
};

/**
 * Get the anchor point on body A, in world coordinates.
 * @method getWorldAnchorA
 * @param {Vec3} result The vector to store the result in.
 */
Spring.prototype.getWorldAnchorA = function(result){
    this.bodyA.pointToWorldFrame(this.localAnchorA,result);
};

/**
 * Get the anchor point on body B, in world coordinates.
 * @method getWorldAnchorB
 * @param {Vec3} result The vector to store the result in.
 */
Spring.prototype.getWorldAnchorB = function(result){
    this.bodyB.pointToWorldFrame(this.localAnchorB,result);
};

var applyForce_r =              new Vec3(),
    applyForce_r_unit =         new Vec3(),
    applyForce_u =              new Vec3(),
    applyForce_f =              new Vec3(),
    applyForce_worldAnchorA =   new Vec3(),
    applyForce_worldAnchorB =   new Vec3(),
    applyForce_ri =             new Vec3(),
    applyForce_rj =             new Vec3(),
    applyForce_ri_x_f =         new Vec3(),
    applyForce_rj_x_f =         new Vec3(),
    applyForce_tmp =            new Vec3();

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
Spring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restLength,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        r = applyForce_r,
        r_unit = applyForce_r_unit,
        u = applyForce_u,
        f = applyForce_f,
        tmp = applyForce_tmp;

    var worldAnchorA = applyForce_worldAnchorA,
        worldAnchorB = applyForce_worldAnchorB,
        ri = applyForce_ri,
        rj = applyForce_rj,
        ri_x_f = applyForce_ri_x_f,
        rj_x_f = applyForce_rj_x_f;

    // Get world anchors
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);

    // Get offset points
    worldAnchorA.vsub(bodyA.position,ri);
    worldAnchorB.vsub(bodyB.position,rj);

    // Compute distance vector between world anchor points
    worldAnchorB.vsub(worldAnchorA,r);
    var rlen = r.norm();
    r_unit.copy(r);
    r_unit.normalize();

    // Compute relative velocity of the anchor points, u
    bodyB.velocity.vsub(bodyA.velocity,u);
    // Add rotational velocity

    bodyB.angularVelocity.cross(rj,tmp);
    u.vadd(tmp,u);
    bodyA.angularVelocity.cross(ri,tmp);
    u.vsub(tmp,u);

    // F = - k * ( x - L ) - D * ( u )
    r_unit.mult(-k*(rlen-l) - d*u.dot(r_unit), f);

    // Add forces to bodies
    bodyA.force.vsub(f,bodyA.force);
    bodyB.force.vadd(f,bodyB.force);

    // Angular force
    ri.cross(f,ri_x_f);
    rj.cross(f,rj_x_f);
    bodyA.torque.vsub(ri_x_f,bodyA.torque);
    bodyB.torque.vadd(rj_x_f,bodyB.torque);
};

},{"../math/Vec3":33}],39:[function(require,module,exports){
var Vec3 = require('../math/Vec3');
var Transform = require('../math/Transform');
var RaycastResult = require('../collision/RaycastResult');
var Utils = require('../utils/Utils');

module.exports = WheelInfo;

/**
 * @class WheelInfo
 * @constructor
 * @param {Object} [options]
 *
 * @param {Vec3} [options.chassisConnectionPointLocal]
 * @param {Vec3} [options.chassisConnectionPointWorld]
 * @param {Vec3} [options.directionLocal]
 * @param {Vec3} [options.directionWorld]
 * @param {Vec3} [options.axleLocal]
 * @param {Vec3} [options.axleWorld]
 * @param {number} [options.suspensionRestLength=1]
 * @param {number} [options.suspensionMaxLength=2]
 * @param {number} [options.radius=1]
 * @param {number} [options.suspensionStiffness=100]
 * @param {number} [options.dampingCompression=10]
 * @param {number} [options.dampingRelaxation=10]
 * @param {number} [options.frictionSlip=10000]
 * @param {number} [options.steering=0]
 * @param {number} [options.rotation=0]
 * @param {number} [options.deltaRotation=0]
 * @param {number} [options.rollInfluence=0.01]
 * @param {number} [options.maxSuspensionForce]
 * @param {boolean} [options.isFrontWheel=true]
 * @param {number} [options.clippedInvContactDotSuspension=1]
 * @param {number} [options.suspensionRelativeVelocity=0]
 * @param {number} [options.suspensionForce=0]
 * @param {number} [options.skidInfo=0]
 * @param {number} [options.suspensionLength=0]
 * @param {number} [options.maxSuspensionTravel=1]
 * @param {boolean} [options.useCustomSlidingRotationalSpeed=false]
 * @param {number} [options.customSlidingRotationalSpeed=-0.1]
 */
function WheelInfo(options){
    options = Utils.defaults(options, {
        chassisConnectionPointLocal: new Vec3(),
        chassisConnectionPointWorld: new Vec3(),
        directionLocal: new Vec3(),
        directionWorld: new Vec3(),
        axleLocal: new Vec3(),
        axleWorld: new Vec3(),
        suspensionRestLength: 1,
        suspensionMaxLength: 2,
        radius: 1,
        suspensionStiffness: 100,
        dampingCompression: 10,
        dampingRelaxation: 10,
        frictionSlip: 10000,
        steering: 0,
        rotation: 0,
        deltaRotation: 0,
        rollInfluence: 0.01,
        maxSuspensionForce: Number.MAX_VALUE,
        isFrontWheel: true,
        clippedInvContactDotSuspension: 1,
        suspensionRelativeVelocity: 0,
        suspensionForce: 0,
        skidInfo: 0,
        suspensionLength: 0,
        maxSuspensionTravel: 1,
        useCustomSlidingRotationalSpeed: false,
        customSlidingRotationalSpeed: -0.1
    });

    /**
     * Max travel distance of the suspension, in meters.
     * @property {number} maxSuspensionTravel
     */
    this.maxSuspensionTravel = options.maxSuspensionTravel;

    /**
     * Speed to apply to the wheel rotation when the wheel is sliding.
     * @property {number} customSlidingRotationalSpeed
     */
    this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;

    /**
     * If the customSlidingRotationalSpeed should be used.
     * @property {Boolean} useCustomSlidingRotationalSpeed
     */
    this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;

    /**
     * @property {Boolean} sliding
     */
    this.sliding = false;

    /**
     * Connection point, defined locally in the chassis body frame.
     * @property {Vec3} chassisConnectionPointLocal
     */
    this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();

    /**
     * @property {Vec3} chassisConnectionPointWorld
     */
    this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();

    /**
     * @property {Vec3} directionLocal
     */
    this.directionLocal = options.directionLocal.clone();

    /**
     * @property {Vec3} directionWorld
     */
    this.directionWorld = options.directionWorld.clone();

    /**
     * @property {Vec3} axleLocal
     */
    this.axleLocal = options.axleLocal.clone();

    /**
     * @property {Vec3} axleWorld
     */
    this.axleWorld = options.axleWorld.clone();

    /**
     * @property {number} suspensionRestLength
     */
    this.suspensionRestLength = options.suspensionRestLength;

    /**
     * @property {number} suspensionMaxLength
     */
    this.suspensionMaxLength = options.suspensionMaxLength;

    /**
     * @property {number} radius
     */
    this.radius = options.radius;

    /**
     * @property {number} suspensionStiffness
     */
    this.suspensionStiffness = options.suspensionStiffness;

    /**
     * @property {number} dampingCompression
     */
    this.dampingCompression = options.dampingCompression;

    /**
     * @property {number} dampingRelaxation
     */
    this.dampingRelaxation = options.dampingRelaxation;

    /**
     * @property {number} frictionSlip
     */
    this.frictionSlip = options.frictionSlip;

    /**
     * @property {number} steering
     */
    this.steering = 0;

    /**
     * Rotation value, in radians.
     * @property {number} rotation
     */
    this.rotation = 0;

    /**
     * @property {number} deltaRotation
     */
    this.deltaRotation = 0;

    /**
     * @property {number} rollInfluence
     */
    this.rollInfluence = options.rollInfluence;

    /**
     * @property {number} maxSuspensionForce
     */
    this.maxSuspensionForce = options.maxSuspensionForce;

    /**
     * @property {number} engineForce
     */
    this.engineForce = 0;

    /**
     * @property {number} brake
     */
    this.brake = 0;

    /**
     * @property {number} isFrontWheel
     */
    this.isFrontWheel = options.isFrontWheel;

    /**
     * @property {number} clippedInvContactDotSuspension
     */
    this.clippedInvContactDotSuspension = 1;

    /**
     * @property {number} suspensionRelativeVelocity
     */
    this.suspensionRelativeVelocity = 0;

    /**
     * @property {number} suspensionForce
     */
    this.suspensionForce = 0;

    /**
     * @property {number} skidInfo
     */
    this.skidInfo = 0;

    /**
     * @property {number} suspensionLength
     */
    this.suspensionLength = 0;

    /**
     * @property {number} sideImpulse
     */
    this.sideImpulse = 0;

    /**
     * @property {number} forwardImpulse
     */
    this.forwardImpulse = 0;

    /**
     * The result from raycasting
     * @property {RaycastResult} raycastResult
     */
    this.raycastResult = new RaycastResult();

    /**
     * Wheel world transform
     * @property {Transform} worldTransform
     */
    this.worldTransform = new Transform();

    /**
     * @property {boolean} isInContact
     */
    this.isInContact = false;
}

var chassis_velocity_at_contactPoint = new Vec3();
var relpos = new Vec3();
var chassis_velocity_at_contactPoint = new Vec3();
WheelInfo.prototype.updateWheel = function(chassis){
    var raycastResult = this.raycastResult;

    if (this.isInContact){
        var project= raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
        raycastResult.hitPointWorld.vsub(chassis.position, relpos);
        chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
        var projVel = raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );
        if (project >= -0.1) {
            this.suspensionRelativeVelocity = 0.0;
            this.clippedInvContactDotSuspension = 1.0 / 0.1;
        } else {
            var inv = -1 / project;
            this.suspensionRelativeVelocity = projVel * inv;
            this.clippedInvContactDotSuspension = inv;
        }

    } else {
        // Not in contact : position wheel in a nice (rest length) position
        raycastResult.suspensionLength = this.suspensionRestLength;
        this.suspensionRelativeVelocity = 0.0;
        raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);
        this.clippedInvContactDotSuspension = 1.0;
    }
};
},{"../collision/RaycastResult":13,"../math/Transform":32,"../math/Vec3":33,"../utils/Utils":56}],40:[function(require,module,exports){
module.exports = Box;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');
var ConvexPolyhedron = require('./ConvexPolyhedron');

/**
 * A 3d box shape.
 * @class Box
 * @constructor
 * @param {Vec3} halfExtents
 * @author schteppe
 * @extends Shape
 */
function Box(halfExtents){
    Shape.call(this);

    this.type = Shape.types.BOX;

    /**
     * @property halfExtents
     * @type {Vec3}
     */
    this.halfExtents = halfExtents;

    /**
     * Used by the contact generator to make contacts with other convex polyhedra for example
     * @property convexPolyhedronRepresentation
     * @type {ConvexPolyhedron}
     */
    this.convexPolyhedronRepresentation = null;

    this.updateConvexPolyhedronRepresentation();
    this.updateBoundingSphereRadius();
}
Box.prototype = new Shape();
Box.prototype.constructor = Box;

/**
 * Updates the local convex polyhedron representation used for some collisions.
 * @method updateConvexPolyhedronRepresentation
 */
Box.prototype.updateConvexPolyhedronRepresentation = function(){
    var sx = this.halfExtents.x;
    var sy = this.halfExtents.y;
    var sz = this.halfExtents.z;
    var V = Vec3;

    var vertices = [
        new V(-sx,-sy,-sz),
        new V( sx,-sy,-sz),
        new V( sx, sy,-sz),
        new V(-sx, sy,-sz),
        new V(-sx,-sy, sz),
        new V( sx,-sy, sz),
        new V( sx, sy, sz),
        new V(-sx, sy, sz)
    ];

    var indices = [
        [3,2,1,0], // -z
        [4,5,6,7], // +z
        [5,4,0,1], // -y
        [2,3,7,6], // +y
        [0,4,7,3], // -x
        [1,2,6,5], // +x
    ];

    var axes = [
        new V(0, 0, 1),
        new V(0, 1, 0),
        new V(1, 0, 0)
    ];

    var h = new ConvexPolyhedron(vertices, indices);
    this.convexPolyhedronRepresentation = h;
    h.material = this.material;
};

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 * @return {Vec3}
 */
Box.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    Box.calculateInertia(this.halfExtents, mass, target);
    return target;
};

Box.calculateInertia = function(halfExtents,mass,target){
    var e = halfExtents;
    target.x = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.z*2*e.z );
    target.y = 1.0 / 12.0 * mass * (   2*e.x*2*e.x + 2*e.z*2*e.z );
    target.z = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.x*2*e.x );
};

/**
 * Get the box 6 side normals
 * @method getSideNormals
 * @param {array}      sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
 * @param {Quaternion} quat             Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
 * @return {array}
 */
Box.prototype.getSideNormals = function(sixTargetVectors,quat){
    var sides = sixTargetVectors;
    var ex = this.halfExtents;
    sides[0].set(  ex.x,     0,     0);
    sides[1].set(     0,  ex.y,     0);
    sides[2].set(     0,     0,  ex.z);
    sides[3].set( -ex.x,     0,     0);
    sides[4].set(     0, -ex.y,     0);
    sides[5].set(     0,     0, -ex.z);

    if(quat!==undefined){
        for(var i=0; i!==sides.length; i++){
            quat.vmult(sides[i],sides[i]);
        }
    }

    return sides;
};

Box.prototype.volume = function(){
    return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
};

Box.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = this.halfExtents.norm();
};

var worldCornerTempPos = new Vec3();
var worldCornerTempNeg = new Vec3();
Box.prototype.forEachWorldCorner = function(pos,quat,callback){

    var e = this.halfExtents;
    var corners = [[  e.x,  e.y,  e.z],
                   [ -e.x,  e.y,  e.z],
                   [ -e.x, -e.y,  e.z],
                   [ -e.x, -e.y, -e.z],
                   [  e.x, -e.y, -e.z],
                   [  e.x,  e.y, -e.z],
                   [ -e.x,  e.y, -e.z],
                   [  e.x, -e.y,  e.z]];
    for(var i=0; i<corners.length; i++){
        worldCornerTempPos.set(corners[i][0],corners[i][1],corners[i][2]);
        quat.vmult(worldCornerTempPos,worldCornerTempPos);
        pos.vadd(worldCornerTempPos,worldCornerTempPos);
        callback(worldCornerTempPos.x,
                 worldCornerTempPos.y,
                 worldCornerTempPos.z);
    }
};

var worldCornersTemp = [
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3()
];
Box.prototype.calculateWorldAABB = function(pos,quat,min,max){

    var e = this.halfExtents;
    worldCornersTemp[0].set(e.x, e.y, e.z);
    worldCornersTemp[1].set(-e.x,  e.y, e.z);
    worldCornersTemp[2].set(-e.x, -e.y, e.z);
    worldCornersTemp[3].set(-e.x, -e.y, -e.z);
    worldCornersTemp[4].set(e.x, -e.y, -e.z);
    worldCornersTemp[5].set(e.x,  e.y, -e.z);
    worldCornersTemp[6].set(-e.x,  e.y, -e.z);
    worldCornersTemp[7].set(e.x, -e.y,  e.z);

    var wc = worldCornersTemp[0];
    quat.vmult(wc, wc);
    pos.vadd(wc, wc);
    max.copy(wc);
    min.copy(wc);
    for(var i=1; i<8; i++){
        var wc = worldCornersTemp[i];
        quat.vmult(wc, wc);
        pos.vadd(wc, wc);
        var x = wc.x;
        var y = wc.y;
        var z = wc.z;
        if(x > max.x){
            max.x = x;
        }
        if(y > max.y){
            max.y = y;
        }
        if(z > max.z){
            max.z = z;
        }

        if(x < min.x){
            min.x = x;
        }
        if(y < min.y){
            min.y = y;
        }
        if(z < min.z){
            min.z = z;
        }
    }

    // Get each axis max
    // min.set(Infinity,Infinity,Infinity);
    // max.set(-Infinity,-Infinity,-Infinity);
    // this.forEachWorldCorner(pos,quat,function(x,y,z){
    //     if(x > max.x){
    //         max.x = x;
    //     }
    //     if(y > max.y){
    //         max.y = y;
    //     }
    //     if(z > max.z){
    //         max.z = z;
    //     }

    //     if(x < min.x){
    //         min.x = x;
    //     }
    //     if(y < min.y){
    //         min.y = y;
    //     }
    //     if(z < min.z){
    //         min.z = z;
    //     }
    // });
};

},{"../math/Vec3":33,"./ConvexPolyhedron":41,"./Shape":46}],41:[function(require,module,exports){
module.exports = ConvexPolyhedron;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Transform = require('../math/Transform');

/**
 * A set of polygons describing a convex shape.
 * @class ConvexPolyhedron
 * @constructor
 * @extends Shape
 * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
 * in the same 3D plane), instead these should be merged into one polygon.
 *
 * @param {array} points An array of Vec3's
 * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.
 *
 * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
 * @author schteppe / https://github.com/schteppe
 * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
 *
 * @todo Move the clipping functions to ContactGenerator?
 * @todo Automatically merge coplanar polygons in constructor.
 */
function ConvexPolyhedron(points, faces, uniqueAxes) {
    var that = this;
    Shape.call(this);
    this.type = Shape.types.CONVEXPOLYHEDRON;

    /**
     * Array of Vec3
     * @property vertices
     * @type {Array}
     */
    this.vertices = points||[];

    this.worldVertices = []; // World transformed version of .vertices
    this.worldVerticesNeedsUpdate = true;

    /**
     * Array of integer arrays, indicating which vertices each face consists of
     * @property faces
     * @type {Array}
     */
    this.faces = faces||[];

    /**
     * Array of Vec3
     * @property faceNormals
     * @type {Array}
     */
    this.faceNormals = [];
    this.computeNormals();

    this.worldFaceNormalsNeedsUpdate = true;
    this.worldFaceNormals = []; // World transformed version of .faceNormals

    /**
     * Array of Vec3
     * @property uniqueEdges
     * @type {Array}
     */
    this.uniqueEdges = [];

    /**
     * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
     * @property {Array} uniqueAxes
     */
    this.uniqueAxes = uniqueAxes ? uniqueAxes.slice() : null;

    this.computeEdges();
    this.updateBoundingSphereRadius();
}
ConvexPolyhedron.prototype = new Shape();
ConvexPolyhedron.prototype.constructor = ConvexPolyhedron;

var computeEdges_tmpEdge = new Vec3();
/**
 * Computes uniqueEdges
 * @method computeEdges
 */
ConvexPolyhedron.prototype.computeEdges = function(){
    var faces = this.faces;
    var vertices = this.vertices;
    var nv = vertices.length;
    var edges = this.uniqueEdges;

    edges.length = 0;

    var edge = computeEdges_tmpEdge;

    for(var i=0; i !== faces.length; i++){
        var face = faces[i];
        var numVertices = face.length;
        for(var j = 0; j !== numVertices; j++){
            var k = ( j+1 ) % numVertices;
            vertices[face[j]].vsub(vertices[face[k]], edge);
            edge.normalize();
            var found = false;
            for(var p=0; p !== edges.length; p++){
                if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)){
                    found = true;
                    break;
                }
            }

            if (!found){
                edges.push(edge.clone());
            }
        }
    }
};

/**
 * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.
 * @method computeNormals
 */
ConvexPolyhedron.prototype.computeNormals = function(){
    this.faceNormals.length = this.faces.length;

    // Generate normals
    for(var i=0; i<this.faces.length; i++){

        // Check so all vertices exists for this face
        for(var j=0; j<this.faces[i].length; j++){
            if(!this.vertices[this.faces[i][j]]){
                throw new Error("Vertex "+this.faces[i][j]+" not found!");
            }
        }

        var n = this.faceNormals[i] || new Vec3();
        this.getFaceNormal(i,n);
        n.negate(n);
        this.faceNormals[i] = n;
        var vertex = this.vertices[this.faces[i][0]];
        if(n.dot(vertex) < 0){
            console.error(".faceNormals[" + i + "] = Vec3("+n.toString()+") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");
            for(var j=0; j<this.faces[i].length; j++){
                console.warn(".vertices["+this.faces[i][j]+"] = Vec3("+this.vertices[this.faces[i][j]].toString()+")");
            }
        }
    }
};

/**
 * Get face normal given 3 vertices
 * @static
 * @method getFaceNormal
 * @param {Vec3} va
 * @param {Vec3} vb
 * @param {Vec3} vc
 * @param {Vec3} target
 */
var cb = new Vec3();
var ab = new Vec3();
ConvexPolyhedron.computeNormal = function ( va, vb, vc, target ) {
    vb.vsub(va,ab);
    vc.vsub(vb,cb);
    cb.cross(ab,target);
    if ( !target.isZero() ) {
        target.normalize();
    }
};

/**
 * Compute the normal of a face from its vertices
 * @method getFaceNormal
 * @param  {Number} i
 * @param  {Vec3} target
 */
ConvexPolyhedron.prototype.getFaceNormal = function(i,target){
    var f = this.faces[i];
    var va = this.vertices[f[0]];
    var vb = this.vertices[f[1]];
    var vc = this.vertices[f[2]];
    return ConvexPolyhedron.computeNormal(va,vb,vc,target);
};

/**
 * @method clipAgainstHull
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {ConvexPolyhedron} hullB
 * @param {Vec3} posB
 * @param {Quaternion} quatB
 * @param {Vec3} separatingNormal
 * @param {Number} minDist Clamp distance
 * @param {Number} maxDist
 * @param {array} result The an array of contact point objects, see clipFaceAgainstHull
 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
 */
var cah_WorldNormal = new Vec3();
ConvexPolyhedron.prototype.clipAgainstHull = function(posA,quatA,hullB,posB,quatB,separatingNormal,minDist,maxDist,result){
    var WorldNormal = cah_WorldNormal;
    var hullA = this;
    var curMaxDist = maxDist;
    var closestFaceB = -1;
    var dmax = -Number.MAX_VALUE;
    for(var face=0; face < hullB.faces.length; face++){
        WorldNormal.copy(hullB.faceNormals[face]);
        quatB.vmult(WorldNormal,WorldNormal);
        //posB.vadd(WorldNormal,WorldNormal);
        var d = WorldNormal.dot(separatingNormal);
        if (d > dmax){
            dmax = d;
            closestFaceB = face;
        }
    }
    var worldVertsB1 = [];
    var polyB = hullB.faces[closestFaceB];
    var numVertices = polyB.length;
    for(var e0=0; e0<numVertices; e0++){
        var b = hullB.vertices[polyB[e0]];
        var worldb = new Vec3();
        worldb.copy(b);
        quatB.vmult(worldb,worldb);
        posB.vadd(worldb,worldb);
        worldVertsB1.push(worldb);
    }

    if (closestFaceB>=0){
        this.clipFaceAgainstHull(separatingNormal,
                                 posA,
                                 quatA,
                                 worldVertsB1,
                                 minDist,
                                 maxDist,
                                 result);
    }
};

/**
 * Find the separating axis between this hull and another
 * @method findSeparatingAxis
 * @param {ConvexPolyhedron} hullB
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {Vec3} posB
 * @param {Quaternion} quatB
 * @param {Vec3} target The target vector to save the axis in
 * @return {bool} Returns false if a separation is found, else true
 */
var fsa_faceANormalWS3 = new Vec3(),
    fsa_Worldnormal1 = new Vec3(),
    fsa_deltaC = new Vec3(),
    fsa_worldEdge0 = new Vec3(),
    fsa_worldEdge1 = new Vec3(),
    fsa_Cross = new Vec3();
ConvexPolyhedron.prototype.findSeparatingAxis = function(hullB,posA,quatA,posB,quatB,target, faceListA, faceListB){
    var faceANormalWS3 = fsa_faceANormalWS3,
        Worldnormal1 = fsa_Worldnormal1,
        deltaC = fsa_deltaC,
        worldEdge0 = fsa_worldEdge0,
        worldEdge1 = fsa_worldEdge1,
        Cross = fsa_Cross;

    var dmin = Number.MAX_VALUE;
    var hullA = this;
    var curPlaneTests=0;

    if(!hullA.uniqueAxes){

        var numFacesA = faceListA ? faceListA.length : hullA.faces.length;

        // Test face normals from hullA
        for(var i=0; i<numFacesA; i++){
            var fi = faceListA ? faceListA[i] : i;

            // Get world face normal
            faceANormalWS3.copy(hullA.faceNormals[fi]);
            quatA.vmult(faceANormalWS3,faceANormalWS3);

            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(faceANormalWS3);
            }
        }

    } else {

        // Test unique axes
        for(var i = 0; i !== hullA.uniqueAxes.length; i++){

            // Get world axis
            quatA.vmult(hullA.uniqueAxes[i],faceANormalWS3);

            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(faceANormalWS3);
            }
        }
    }

    if(!hullB.uniqueAxes){

        // Test face normals from hullB
        var numFacesB = faceListB ? faceListB.length : hullB.faces.length;
        for(var i=0;i<numFacesB;i++){

            var fi = faceListB ? faceListB[i] : i;

            Worldnormal1.copy(hullB.faceNormals[fi]);
            quatB.vmult(Worldnormal1,Worldnormal1);
            curPlaneTests++;
            var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(Worldnormal1);
            }
        }
    } else {

        // Test unique axes in B
        for(var i = 0; i !== hullB.uniqueAxes.length; i++){
            quatB.vmult(hullB.uniqueAxes[i],Worldnormal1);

            curPlaneTests++;
            var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(Worldnormal1);
            }
        }
    }

    // Test edges
    for(var e0=0; e0 !== hullA.uniqueEdges.length; e0++){

        // Get world edge
        quatA.vmult(hullA.uniqueEdges[e0],worldEdge0);

        for(var e1=0; e1 !== hullB.uniqueEdges.length; e1++){

            // Get world edge 2
            quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
            worldEdge0.cross(worldEdge1,Cross);

            if(!Cross.almostZero()){
                Cross.normalize();
                var dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);
                if(dist === false){
                    return false;
                }
                if(dist < dmin){
                    dmin = dist;
                    target.copy(Cross);
                }
            }
        }
    }

    posB.vsub(posA,deltaC);
    if((deltaC.dot(target))>0.0){
        target.negate(target);
    }

    return true;
};

var maxminA=[], maxminB=[];

/**
 * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
 * @method testSepAxis
 * @param {Vec3} axis
 * @param {ConvexPolyhedron} hullB
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {Vec3} posB
 * @param {Quaternion} quatB
 * @return {number} The overlap depth, or FALSE if no penetration.
 */
ConvexPolyhedron.prototype.testSepAxis = function(axis, hullB, posA, quatA, posB, quatB){
    var hullA=this;
    ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
    ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
    var maxA = maxminA[0];
    var minA = maxminA[1];
    var maxB = maxminB[0];
    var minB = maxminB[1];
    if(maxA<minB || maxB<minA){
        return false; // Separated
    }
    var d0 = maxA - minB;
    var d1 = maxB - minA;
    var depth = d0<d1 ? d0:d1;
    return depth;
};

var cli_aabbmin = new Vec3(),
    cli_aabbmax = new Vec3();

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 */
ConvexPolyhedron.prototype.calculateLocalInertia = function(mass,target){
    // Approximate with box inertia
    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
    this.computeLocalAABB(cli_aabbmin,cli_aabbmax);
    var x = cli_aabbmax.x - cli_aabbmin.x,
        y = cli_aabbmax.y - cli_aabbmin.y,
        z = cli_aabbmax.z - cli_aabbmin.z;
    target.x = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z );
    target.y = 1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z );
    target.z = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x );
};

/**
 * @method getPlaneConstantOfFace
 * @param  {Number} face_i Index of the face
 * @return {Number}
 */
ConvexPolyhedron.prototype.getPlaneConstantOfFace = function(face_i){
    var f = this.faces[face_i];
    var n = this.faceNormals[face_i];
    var v = this.vertices[f[0]];
    var c = -n.dot(v);
    return c;
};

/**
 * Clip a face against a hull.
 * @method clipFaceAgainstHull
 * @param {Vec3} separatingNormal
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {Array} worldVertsB1 An array of Vec3 with vertices in the world frame.
 * @param {Number} minDist Distance clamping
 * @param {Number} maxDist
 * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
 */
var cfah_faceANormalWS = new Vec3(),
    cfah_edge0 = new Vec3(),
    cfah_WorldEdge0 = new Vec3(),
    cfah_worldPlaneAnormal1 = new Vec3(),
    cfah_planeNormalWS1 = new Vec3(),
    cfah_worldA1 = new Vec3(),
    cfah_localPlaneNormal = new Vec3(),
    cfah_planeNormalWS = new Vec3();
ConvexPolyhedron.prototype.clipFaceAgainstHull = function(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist,result){
    var faceANormalWS = cfah_faceANormalWS,
        edge0 = cfah_edge0,
        WorldEdge0 = cfah_WorldEdge0,
        worldPlaneAnormal1 = cfah_worldPlaneAnormal1,
        planeNormalWS1 = cfah_planeNormalWS1,
        worldA1 = cfah_worldA1,
        localPlaneNormal = cfah_localPlaneNormal,
        planeNormalWS = cfah_planeNormalWS;

    var hullA = this;
    var worldVertsB2 = [];
    var pVtxIn = worldVertsB1;
    var pVtxOut = worldVertsB2;
    // Find the face with normal closest to the separating axis
    var closestFaceA = -1;
    var dmin = Number.MAX_VALUE;
    for(var face=0; face<hullA.faces.length; face++){
        faceANormalWS.copy(hullA.faceNormals[face]);
        quatA.vmult(faceANormalWS,faceANormalWS);
        //posA.vadd(faceANormalWS,faceANormalWS);
        var d = faceANormalWS.dot(separatingNormal);
        if (d < dmin){
            dmin = d;
            closestFaceA = face;
        }
    }
    if (closestFaceA < 0){
        // console.log("--- did not find any closest face... ---");
        return;
    }
    //console.log("closest A: ",closestFaceA);
    // Get the face and construct connected faces
    var polyA = hullA.faces[closestFaceA];
    polyA.connectedFaces = [];
    for(var i=0; i<hullA.faces.length; i++){
        for(var j=0; j<hullA.faces[i].length; j++){
            if(polyA.indexOf(hullA.faces[i][j])!==-1 /* Sharing a vertex*/ && i!==closestFaceA /* Not the one we are looking for connections from */ && polyA.connectedFaces.indexOf(i)===-1 /* Not already added */ ){
                polyA.connectedFaces.push(i);
            }
        }
    }
    // Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face
    var numContacts = pVtxIn.length;
    var numVerticesA = polyA.length;
    var res = [];
    for(var e0=0; e0<numVerticesA; e0++){
        var a = hullA.vertices[polyA[e0]];
        var b = hullA.vertices[polyA[(e0+1)%numVerticesA]];
        a.vsub(b,edge0);
        WorldEdge0.copy(edge0);
        quatA.vmult(WorldEdge0,WorldEdge0);
        posA.vadd(WorldEdge0,WorldEdge0);
        worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);//transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);
        quatA.vmult(worldPlaneAnormal1,worldPlaneAnormal1);
        posA.vadd(worldPlaneAnormal1,worldPlaneAnormal1);
        WorldEdge0.cross(worldPlaneAnormal1,planeNormalWS1);
        planeNormalWS1.negate(planeNormalWS1);
        worldA1.copy(a);
        quatA.vmult(worldA1,worldA1);
        posA.vadd(worldA1,worldA1);
        var planeEqWS1 = -worldA1.dot(planeNormalWS1);
        var planeEqWS;
        if(true){
            var otherFace = polyA.connectedFaces[e0];
            localPlaneNormal.copy(this.faceNormals[otherFace]);
            var localPlaneEq = this.getPlaneConstantOfFace(otherFace);

            planeNormalWS.copy(localPlaneNormal);
            quatA.vmult(planeNormalWS,planeNormalWS);
            //posA.vadd(planeNormalWS,planeNormalWS);
            var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
        } else  {
            planeNormalWS.copy(planeNormalWS1);
            planeEqWS = planeEqWS1;
        }

        // Clip face against our constructed plane
        this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS);

        // Throw away all clipped points, but save the reamining until next clip
        while(pVtxIn.length){
            pVtxIn.shift();
        }
        while(pVtxOut.length){
            pVtxIn.push(pVtxOut.shift());
        }
    }

    //console.log("Resulting points after clip:",pVtxIn);

    // only keep contact points that are behind the witness face
    localPlaneNormal.copy(this.faceNormals[closestFaceA]);

    var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
    planeNormalWS.copy(localPlaneNormal);
    quatA.vmult(planeNormalWS,planeNormalWS);

    var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
    for (var i=0; i<pVtxIn.length; i++){
        var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???
        /*console.log("depth calc from normal=",planeNormalWS.toString()," and constant "+planeEqWS+" and vertex ",pVtxIn[i].toString()," gives "+depth);*/
        if (depth <=minDist){
            console.log("clamped: depth="+depth+" to minDist="+(minDist+""));
            depth = minDist;
        }

        if (depth <=maxDist){
            var point = pVtxIn[i];
            if(depth<=0){
                /*console.log("Got contact point ",point.toString(),
                  ", depth=",depth,
                  "contact normal=",separatingNormal.toString(),
                  "plane",planeNormalWS.toString(),
                  "planeConstant",planeEqWS);*/
                var p = {
                    point:point,
                    normal:planeNormalWS,
                    depth: depth,
                };
                result.push(p);
            }
        }
    }
};

/**
 * Clip a face in a hull against the back of a plane.
 * @method clipFaceAgainstPlane
 * @param {Array} inVertices
 * @param {Array} outVertices
 * @param {Vec3} planeNormal
 * @param {Number} planeConstant The constant in the mathematical plane equation
 */
ConvexPolyhedron.prototype.clipFaceAgainstPlane = function(inVertices,outVertices, planeNormal, planeConstant){
    var n_dot_first, n_dot_last;
    var numVerts = inVertices.length;

    if(numVerts < 2){
        return outVertices;
    }

    var firstVertex = inVertices[inVertices.length-1],
        lastVertex =   inVertices[0];

    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

    for(var vi = 0; vi < numVerts; vi++){
        lastVertex = inVertices[vi];
        n_dot_last = planeNormal.dot(lastVertex) + planeConstant;
        if(n_dot_first < 0){
            if(n_dot_last < 0){
                // Start < 0, end < 0, so output lastVertex
                var newv = new Vec3();
                newv.copy(lastVertex);
                outVertices.push(newv);
            } else {
                // Start < 0, end >= 0, so output intersection
                var newv = new Vec3();
                firstVertex.lerp(lastVertex,
                                 n_dot_first / (n_dot_first - n_dot_last),
                                 newv);
                outVertices.push(newv);
            }
        } else {
            if(n_dot_last<0){
                // Start >= 0, end < 0 so output intersection and end
                var newv = new Vec3();
                firstVertex.lerp(lastVertex,
                                 n_dot_first / (n_dot_first - n_dot_last),
                                 newv);
                outVertices.push(newv);
                outVertices.push(lastVertex);
            }
        }
        firstVertex = lastVertex;
        n_dot_first = n_dot_last;
    }
    return outVertices;
};

// Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
ConvexPolyhedron.prototype.computeWorldVertices = function(position,quat){
    var N = this.vertices.length;
    while(this.worldVertices.length < N){
        this.worldVertices.push( new Vec3() );
    }

    var verts = this.vertices,
        worldVerts = this.worldVertices;
    for(var i=0; i!==N; i++){
        quat.vmult( verts[i] , worldVerts[i] );
        position.vadd( worldVerts[i] , worldVerts[i] );
    }

    this.worldVerticesNeedsUpdate = false;
};

var computeLocalAABB_worldVert = new Vec3();
ConvexPolyhedron.prototype.computeLocalAABB = function(aabbmin,aabbmax){
    var n = this.vertices.length,
        vertices = this.vertices,
        worldVert = computeLocalAABB_worldVert;

    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

    for(var i=0; i<n; i++){
        var v = vertices[i];
        if     (v.x < aabbmin.x){
            aabbmin.x = v.x;
        } else if(v.x > aabbmax.x){
            aabbmax.x = v.x;
        }
        if     (v.y < aabbmin.y){
            aabbmin.y = v.y;
        } else if(v.y > aabbmax.y){
            aabbmax.y = v.y;
        }
        if     (v.z < aabbmin.z){
            aabbmin.z = v.z;
        } else if(v.z > aabbmax.z){
            aabbmax.z = v.z;
        }
    }
};

/**
 * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
 * @method computeWorldFaceNormals
 * @param  {Quaternion} quat
 */
ConvexPolyhedron.prototype.computeWorldFaceNormals = function(quat){
    var N = this.faceNormals.length;
    while(this.worldFaceNormals.length < N){
        this.worldFaceNormals.push( new Vec3() );
    }

    var normals = this.faceNormals,
        worldNormals = this.worldFaceNormals;
    for(var i=0; i!==N; i++){
        quat.vmult( normals[i] , worldNormals[i] );
    }

    this.worldFaceNormalsNeedsUpdate = false;
};

/**
 * @method updateBoundingSphereRadius
 */
ConvexPolyhedron.prototype.updateBoundingSphereRadius = function(){
    // Assume points are distributed with local (0,0,0) as center
    var max2 = 0;
    var verts = this.vertices;
    for(var i=0, N=verts.length; i!==N; i++) {
        var norm2 = verts[i].norm2();
        if(norm2 > max2){
            max2 = norm2;
        }
    }
    this.boundingSphereRadius = Math.sqrt(max2);
};

var tempWorldVertex = new Vec3();

/**
 * @method calculateWorldAABB
 * @param {Vec3}        pos
 * @param {Quaternion}  quat
 * @param {Vec3}        min
 * @param {Vec3}        max
 */
ConvexPolyhedron.prototype.calculateWorldAABB = function(pos,quat,min,max){
    var n = this.vertices.length, verts = this.vertices;
    var minx,miny,minz,maxx,maxy,maxz;
    for(var i=0; i<n; i++){
        tempWorldVertex.copy(verts[i]);
        quat.vmult(tempWorldVertex,tempWorldVertex);
        pos.vadd(tempWorldVertex,tempWorldVertex);
        var v = tempWorldVertex;
        if     (v.x < minx || minx===undefined){
            minx = v.x;
        } else if(v.x > maxx || maxx===undefined){
            maxx = v.x;
        }

        if     (v.y < miny || miny===undefined){
            miny = v.y;
        } else if(v.y > maxy || maxy===undefined){
            maxy = v.y;
        }

        if     (v.z < minz || minz===undefined){
            minz = v.z;
        } else if(v.z > maxz || maxz===undefined){
            maxz = v.z;
        }
    }
    min.set(minx,miny,minz);
    max.set(maxx,maxy,maxz);
};

/**
 * Get approximate convex volume
 * @method volume
 * @return {Number}
 */
ConvexPolyhedron.prototype.volume = function(){
    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
};

/**
 * Get an average of all the vertices positions
 * @method getAveragePointLocal
 * @param  {Vec3} target
 * @return {Vec3}
 */
ConvexPolyhedron.prototype.getAveragePointLocal = function(target){
    target = target || new Vec3();
    var n = this.vertices.length,
        verts = this.vertices;
    for(var i=0; i<n; i++){
        target.vadd(verts[i],target);
    }
    target.mult(1/n,target);
    return target;
};

/**
 * Transform all local points. Will change the .vertices
 * @method transformAllPoints
 * @param  {Vec3} offset
 * @param  {Quaternion} quat
 */
ConvexPolyhedron.prototype.transformAllPoints = function(offset,quat){
    var n = this.vertices.length,
        verts = this.vertices;

    // Apply rotation
    if(quat){
        // Rotate vertices
        for(var i=0; i<n; i++){
            var v = verts[i];
            quat.vmult(v,v);
        }
        // Rotate face normals
        for(var i=0; i<this.faceNormals.length; i++){
            var v = this.faceNormals[i];
            quat.vmult(v,v);
        }
        /*
        // Rotate edges
        for(var i=0; i<this.uniqueEdges.length; i++){
            var v = this.uniqueEdges[i];
            quat.vmult(v,v);
        }*/
    }

    // Apply offset
    if(offset){
        for(var i=0; i<n; i++){
            var v = verts[i];
            v.vadd(offset,v);
        }
    }
};

/**
 * Checks whether p is inside the polyhedra. Must be in local coords. The point lies outside of the convex hull of the other points if and only if the direction of all the vectors from it to those other points are on less than one half of a sphere around it.
 * @method pointIsInside
 * @param  {Vec3} p      A point given in local coordinates
 * @return {Boolean}
 */
var ConvexPolyhedron_pointIsInside = new Vec3();
var ConvexPolyhedron_vToP = new Vec3();
var ConvexPolyhedron_vToPointInside = new Vec3();
ConvexPolyhedron.prototype.pointIsInside = function(p){
    var n = this.vertices.length,
        verts = this.vertices,
        faces = this.faces,
        normals = this.faceNormals;
    var positiveResult = null;
    var N = this.faces.length;
    var pointInside = ConvexPolyhedron_pointIsInside;
    this.getAveragePointLocal(pointInside);
    for(var i=0; i<N; i++){
        var numVertices = this.faces[i].length;
        var n = normals[i];
        var v = verts[faces[i][0]]; // We only need one point in the face

        // This dot product determines which side of the edge the point is
        var vToP = ConvexPolyhedron_vToP;
        p.vsub(v,vToP);
        var r1 = n.dot(vToP);

        var vToPointInside = ConvexPolyhedron_vToPointInside;
        pointInside.vsub(v,vToPointInside);
        var r2 = n.dot(vToPointInside);

        if((r1<0 && r2>0) || (r1>0 && r2<0)){
            return false; // Encountered some other sign. Exit.
        } else {
        }
    }

    // If we got here, all dot products were of the same sign.
    return positiveResult ? 1 : -1;
};

/**
 * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.
 * @static
 * @method project
 * @param {ConvexPolyhedron} hull
 * @param {Vec3} axis
 * @param {Vec3} pos
 * @param {Quaternion} quat
 * @param {array} result result[0] and result[1] will be set to maximum and minimum, respectively.
 */
var project_worldVertex = new Vec3();
var project_localAxis = new Vec3();
var project_localOrigin = new Vec3();
ConvexPolyhedron.project = function(hull, axis, pos, quat, result){
    var n = hull.vertices.length,
        worldVertex = project_worldVertex,
        localAxis = project_localAxis,
        max = 0,
        min = 0,
        localOrigin = project_localOrigin,
        vs = hull.vertices;

    localOrigin.setZero();

    // Transform the axis to local
    Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
    Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
    var add = localOrigin.dot(localAxis);

    min = max = vs[0].dot(localAxis);

    for(var i = 1; i < n; i++){
        var val = vs[i].dot(localAxis);

        if(val > max){
            max = val;
        }

        if(val < min){
            min = val;
        }
    }

    min -= add;
    max -= add;

    if(min > max){
        // Inconsistent - swap
        var temp = min;
        min = max;
        max = temp;
    }
    // Output
    result[0] = max;
    result[1] = min;
};

},{"../math/Quaternion":31,"../math/Transform":32,"../math/Vec3":33,"./Shape":46}],42:[function(require,module,exports){
module.exports = Cylinder;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var ConvexPolyhedron = require('./ConvexPolyhedron');

/**
 * @class Cylinder
 * @constructor
 * @extends ConvexPolyhedron
 * @author schteppe / https://github.com/schteppe
 * @param {Number} radiusTop
 * @param {Number} radiusBottom
 * @param {Number} height
 * @param {Number} numSegments The number of segments to build the cylinder out of
 */
function Cylinder( radiusTop, radiusBottom, height , numSegments ) {
    var N = numSegments,
        verts = [],
        axes = [],
        faces = [],
        bottomface = [],
        topface = [],
        cos = Math.cos,
        sin = Math.sin;

    // First bottom point
    verts.push(new Vec3(radiusBottom*cos(0),
                               radiusBottom*sin(0),
                               -height*0.5));
    bottomface.push(0);

    // First top point
    verts.push(new Vec3(radiusTop*cos(0),
                               radiusTop*sin(0),
                               height*0.5));
    topface.push(1);

    for(var i=0; i<N; i++){
        var theta = 2*Math.PI/N * (i+1);
        var thetaN = 2*Math.PI/N * (i+0.5);
        if(i<N-1){
            // Bottom
            verts.push(new Vec3(radiusBottom*cos(theta),
                                       radiusBottom*sin(theta),
                                       -height*0.5));
            bottomface.push(2*i+2);
            // Top
            verts.push(new Vec3(radiusTop*cos(theta),
                                       radiusTop*sin(theta),
                                       height*0.5));
            topface.push(2*i+3);

            // Face
            faces.push([2*i+2, 2*i+3, 2*i+1,2*i]);
        } else {
            faces.push([0,1, 2*i+1, 2*i]); // Connect
        }

        // Axis: we can cut off half of them if we have even number of segments
        if(N % 2 === 1 || i < N / 2){
            axes.push(new Vec3(cos(thetaN), sin(thetaN), 0));
        }
    }
    faces.push(topface);
    axes.push(new Vec3(0,0,1));

    // Reorder bottom face
    var temp = [];
    for(var i=0; i<bottomface.length; i++){
        temp.push(bottomface[bottomface.length - i - 1]);
    }
    faces.push(temp);

    this.type = Shape.types.CONVEXPOLYHEDRON;
    ConvexPolyhedron.call( this, verts, faces, axes );
}

Cylinder.prototype = new ConvexPolyhedron();

},{"../math/Quaternion":31,"../math/Vec3":33,"./ConvexPolyhedron":41,"./Shape":46}],43:[function(require,module,exports){
var Shape = require('./Shape');
var ConvexPolyhedron = require('./ConvexPolyhedron');
var Vec3 = require('../math/Vec3');
var Utils = require('../utils/Utils');

module.exports = Heightfield;

/**
 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
 * @class Heightfield
 * @extends Shape
 * @constructor
 * @param {Array} data An array of Y values that will be used to construct the terrain.
 * @param {object} options
 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
 * @param {Number} [options.maxValue] Maximum value.
 * @param {Number} [options.elementSize=0.1] World spacing between the data points in X direction.
 * @todo Should be possible to use along all axes, not just y
 * @todo should be possible to scale along all axes
 *
 * @example
 *     // Generate some height data (y-values).
 *     var data = [];
 *     for(var i = 0; i < 1000; i++){
 *         var y = 0.5 * Math.cos(0.2 * i);
 *         data.push(y);
 *     }
 *
 *     // Create the heightfield shape
 *     var heightfieldShape = new Heightfield(data, {
 *         elementSize: 1 // Distance between the data points in X and Y directions
 *     });
 *     var heightfieldBody = new Body();
 *     heightfieldBody.addShape(heightfieldShape);
 *     world.addBody(heightfieldBody);
 */
function Heightfield(data, options){
    options = Utils.defaults(options, {
        maxValue : null,
        minValue : null,
        elementSize : 1
    });

    /**
     * An array of numbers, or height values, that are spread out along the x axis.
     * @property {array} data
     */
    this.data = data;

    /**
     * Max value of the data
     * @property {number} maxValue
     */
    this.maxValue = options.maxValue;

    /**
     * Max value of the data
     * @property {number} minValue
     */
    this.minValue = options.minValue;

    /**
     * The width of each element
     * @property {number} elementSize
     * @todo elementSizeX and Y
     */
    this.elementSize = options.elementSize;

    if(options.minValue === null){
        this.updateMinValue();
    }
    if(options.maxValue === null){
        this.updateMaxValue();
    }

    this.cacheEnabled = true;

    Shape.call(this);

    this.pillarConvex = new ConvexPolyhedron();
    this.pillarOffset = new Vec3();

    this.type = Shape.types.HEIGHTFIELD;
    this.updateBoundingSphereRadius();

    // "i_j_isUpper" => { convex: ..., offset: ... }
    // for example:
    // _cachedPillars["0_2_1"]
    this._cachedPillars = {};
}
Heightfield.prototype = new Shape();

/**
 * Call whenever you change the data array.
 * @method update
 */
Heightfield.prototype.update = function(){
    this._cachedPillars = {};
};

/**
 * Update the .minValue property
 * @method updateMinValue
 */
Heightfield.prototype.updateMinValue = function(){
    var data = this.data;
    var minValue = data[0][0];
    for(var i=0; i !== data.length; i++){
        for(var j=0; j !== data[i].length; j++){
            var v = data[i][j];
            if(v < minValue){
                minValue = v;
            }
        }
    }
    this.minValue = minValue;
};

/**
 * Update the .maxValue property
 * @method updateMaxValue
 */
Heightfield.prototype.updateMaxValue = function(){
    var data = this.data;
    var maxValue = data[0][0];
    for(var i=0; i !== data.length; i++){
        for(var j=0; j !== data[i].length; j++){
            var v = data[i][j];
            if(v > maxValue){
                maxValue = v;
            }
        }
    }
    this.maxValue = maxValue;
};

/**
 * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
 * @method setHeightValueAtIndex
 * @param {integer} xi
 * @param {integer} yi
 * @param {number} value
 */
Heightfield.prototype.setHeightValueAtIndex = function(xi, yi, value){
    var data = this.data;
    data[xi][yi] = value;

    // Invalidate cache
    this.clearCachedConvexTrianglePillar(xi, yi, false);
    if(xi > 0){
        this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
        this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
    }
    if(yi > 0){
        this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
        this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
    }
    if(yi > 0 && xi > 0){
        this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
    }
};

/**
 * Get max/min in a rectangle in the matrix data
 * @method getRectMinMax
 * @param  {integer} iMinX
 * @param  {integer} iMinY
 * @param  {integer} iMaxX
 * @param  {integer} iMaxY
 * @param  {array} [result] An array to store the results in.
 * @return {array} The result array, if it was passed in. Minimum will be at position 0 and max at 1.
 */
Heightfield.prototype.getRectMinMax = function (iMinX, iMinY, iMaxX, iMaxY, result) {
    result = result || [];

    // Get max and min of the data
    var data = this.data,
        max = this.minValue; // Set first value
    for(var i = iMinX; i <= iMaxX; i++){
        for(var j = iMinY; j <= iMaxY; j++){
            var height = data[i][j];
            if(height > max){
                max = height;
            }
        }
    }

    result[0] = this.minValue;
    result[1] = max;
};



/**
 * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
 * @method getIndexOfPosition
 * @param  {number} x
 * @param  {number} y
 * @param  {array} result Two-element array
 * @param  {boolean} clamp If the position should be clamped to the heightfield edge.
 * @return {boolean}
 */
Heightfield.prototype.getIndexOfPosition = function (x, y, result, clamp) {

    // Get the index of the data points to test against
    var w = this.elementSize;
    var data = this.data;
    var xi = Math.floor(x / w);
    var yi = Math.floor(y / w);

    result[0] = xi;
    result[1] = yi;

    if(clamp){
        // Clamp index to edges
        if(xi < 0){ xi = 0; }
        if(yi < 0){ yi = 0; }
        if(xi >= data.length - 1){ xi = data.length - 1; }
        if(yi >= data[0].length - 1){ yi = data[0].length - 1; }
    }

    // Bail out if we are out of the terrain
    if(xi < 0 || yi < 0 || xi >= data.length-1 || yi >= data[0].length-1){
        return false;
    }

    return true;
};


var getHeightAt_idx = [];
var getHeightAt_weights = new Vec3();
var getHeightAt_a = new Vec3();
var getHeightAt_b = new Vec3();
var getHeightAt_c = new Vec3();

Heightfield.prototype.getTriangleAt = function(x, y, edgeClamp, a, b, c){
    var idx = getHeightAt_idx;
    this.getIndexOfPosition(x, y, idx, edgeClamp);
    var xi = idx[0];
    var yi = idx[1];

    var data = this.data;
    if(edgeClamp){
        xi = Math.min(data.length - 2, Math.max(0, xi));
        yi = Math.min(data[0].length - 2, Math.max(0, yi));
    }

    var elementSize = this.elementSize;
    var lowerDist2 = Math.pow(x / elementSize - xi, 2) + Math.pow(y / elementSize - yi, 2);
    var upperDist2 = Math.pow(x / elementSize - (xi + 1), 2) + Math.pow(y / elementSize - (yi + 1), 2);
    var upper = lowerDist2 > upperDist2;
    this.getTriangle(xi, yi, upper, a, b, c);
    return upper;
};

var getNormalAt_a = new Vec3();
var getNormalAt_b = new Vec3();
var getNormalAt_c = new Vec3();
var getNormalAt_e0 = new Vec3();
var getNormalAt_e1 = new Vec3();
Heightfield.prototype.getNormalAt = function(x, y, edgeClamp, result){
    var a = getNormalAt_a;
    var b = getNormalAt_b;
    var c = getNormalAt_c;
    var e0 = getNormalAt_e0;
    var e1 = getNormalAt_e1;
    this.getTriangleAt(x, y, edgeClamp, a, b, c);
    b.vsub(a, e0);
    c.vsub(a, e1);
    e0.cross(e1, result);
    result.normalize();
};


/**
 * Get an AABB of a square in the heightfield
 * @param  {number} xi
 * @param  {number} yi
 * @param  {AABB} result
 */
Heightfield.prototype.getAabbAtIndex = function(xi, yi, result){
    var data = this.data;
    var elementSize = this.elementSize;

    result.lowerBound.set(
        xi * elementSize,
        yi * elementSize,
        data[xi][yi]
    );
    result.upperBound.set(
        (xi + 1) * elementSize,
        (yi + 1) * elementSize,
        data[xi + 1][yi + 1]
    );
};


/**
 * Get the height in the heightfield at a given position
 * @param  {number} x
 * @param  {number} y
 * @param  {boolean} edgeClamp
 * @return {number}
 */
Heightfield.prototype.getHeightAt = function(x, y, edgeClamp){
    var data = this.data;
    var a = getHeightAt_a;
    var b = getHeightAt_b;
    var c = getHeightAt_c;
    var idx = getHeightAt_idx;

    this.getIndexOfPosition(x, y, idx, edgeClamp);
    var xi = idx[0];
    var yi = idx[1];
    if(edgeClamp){
        xi = Math.min(data.length - 2, Math.max(0, xi));
        yi = Math.min(data[0].length - 2, Math.max(0, yi));
    }
    var upper = this.getTriangleAt(x, y, edgeClamp, a, b, c);
    barycentricWeights(x, y, a.x, a.y, b.x, b.y, c.x, c.y, getHeightAt_weights);

    var w = getHeightAt_weights;

    if(upper){

        // Top triangle verts
        return data[xi + 1][yi + 1] * w.x + data[xi][yi + 1] * w.y + data[xi + 1][yi] * w.z;

    } else {

        // Top triangle verts
        return data[xi][yi] * w.x + data[xi + 1][yi] * w.y + data[xi][yi + 1] * w.z;
    }
};

// from https://en.wikipedia.org/wiki/Barycentric_coordinate_system
function barycentricWeights(x, y, ax, ay, bx, by, cx, cy, result){
    result.x = ((by - cy) * (x - cx) + (cx - bx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
    result.y = ((cy - ay) * (x - cx) + (ax - cx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
    result.z = 1 - result.x - result.y;
}

Heightfield.prototype.getCacheConvexTrianglePillarKey = function(xi, yi, getUpperTriangle){
    return xi + '_' + yi + '_' + (getUpperTriangle ? 1 : 0);
};

Heightfield.prototype.getCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){
    return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
};

Heightfield.prototype.setCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle, convex, offset){
    this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
        convex: convex,
        offset: offset
    };
};

Heightfield.prototype.clearCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){
    delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
};

/**
 * Get a triangle from the heightfield
 * @param  {number} xi
 * @param  {number} yi
 * @param  {boolean} upper
 * @param  {Vec3} a
 * @param  {Vec3} b
 * @param  {Vec3} c
 */
Heightfield.prototype.getTriangle = function(xi, yi, upper, a, b, c){
    var data = this.data;
    var elementSize = this.elementSize;

    if(upper){

        // Top triangle verts
        a.set(
            (xi + 1) * elementSize,
            (yi + 1) * elementSize,
            data[xi + 1][yi + 1]
        );
        b.set(
            xi * elementSize,
            (yi + 1) * elementSize,
            data[xi][yi + 1]
        );
        c.set(
            (xi + 1) * elementSize,
            yi * elementSize,
            data[xi + 1][yi]
        );

    } else {

        // Top triangle verts
        a.set(
            xi * elementSize,
            yi * elementSize,
            data[xi][yi]
        );
        b.set(
            (xi + 1) * elementSize,
            yi * elementSize,
            data[xi + 1][yi]
        );
        c.set(
            xi * elementSize,
            (yi + 1) * elementSize,
            data[xi][yi + 1]
        );
    }
};

/**
 * Get a triangle in the terrain in the form of a triangular convex shape.
 * @method getConvexTrianglePillar
 * @param  {integer} i
 * @param  {integer} j
 * @param  {boolean} getUpperTriangle
 */
Heightfield.prototype.getConvexTrianglePillar = function(xi, yi, getUpperTriangle){
    var result = this.pillarConvex;
    var offsetResult = this.pillarOffset;

    if(this.cacheEnabled){
        var data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);
        if(data){
            this.pillarConvex = data.convex;
            this.pillarOffset = data.offset;
            return;
        }

        result = new ConvexPolyhedron();
        offsetResult = new Vec3();

        this.pillarConvex = result;
        this.pillarOffset = offsetResult;
    }

    var data = this.data;
    var elementSize = this.elementSize;
    var faces = result.faces;

    // Reuse verts if possible
    result.vertices.length = 6;
    for (var i = 0; i < 6; i++) {
        if(!result.vertices[i]){
            result.vertices[i] = new Vec3();
        }
    }

    // Reuse faces if possible
    faces.length = 5;
    for (var i = 0; i < 5; i++) {
        if(!faces[i]){
            faces[i] = [];
        }
    }

    var verts = result.vertices;

    var h = (Math.min(
        data[xi][yi],
        data[xi+1][yi],
        data[xi][yi+1],
        data[xi+1][yi+1]
    ) - this.minValue ) / 2 + this.minValue;

    if (!getUpperTriangle) {

        // Center of the triangle pillar - all polygons are given relative to this one
        offsetResult.set(
            (xi + 0.25) * elementSize, // sort of center of a triangle
            (yi + 0.25) * elementSize,
            h // vertical center
        );

        // Top triangle verts
        verts[0].set(
            -0.25 * elementSize,
            -0.25 * elementSize,
            data[xi][yi] - h
        );
        verts[1].set(
            0.75 * elementSize,
            -0.25 * elementSize,
            data[xi + 1][yi] - h
        );
        verts[2].set(
            -0.25 * elementSize,
            0.75 * elementSize,
            data[xi][yi + 1] - h
        );

        // bottom triangle verts
        verts[3].set(
            -0.25 * elementSize,
            -0.25 * elementSize,
            -h-1
        );
        verts[4].set(
            0.75 * elementSize,
            -0.25 * elementSize,
            -h-1
        );
        verts[5].set(
            -0.25 * elementSize,
            0.75  * elementSize,
            -h-1
        );

        // top triangle
        faces[0][0] = 0;
        faces[0][1] = 1;
        faces[0][2] = 2;

        // bottom triangle
        faces[1][0] = 5;
        faces[1][1] = 4;
        faces[1][2] = 3;

        // -x facing quad
        faces[2][0] = 0;
        faces[2][1] = 2;
        faces[2][2] = 5;
        faces[2][3] = 3;

        // -y facing quad
        faces[3][0] = 1;
        faces[3][1] = 0;
        faces[3][2] = 3;
        faces[3][3] = 4;

        // +xy facing quad
        faces[4][0] = 4;
        faces[4][1] = 5;
        faces[4][2] = 2;
        faces[4][3] = 1;


    } else {

        // Center of the triangle pillar - all polygons are given relative to this one
        offsetResult.set(
            (xi + 0.75) * elementSize, // sort of center of a triangle
            (yi + 0.75) * elementSize,
            h // vertical center
        );

        // Top triangle verts
        verts[0].set(
            0.25 * elementSize,
            0.25 * elementSize,
            data[xi + 1][yi + 1] - h
        );
        verts[1].set(
            -0.75 * elementSize,
            0.25 * elementSize,
            data[xi][yi + 1] - h
        );
        verts[2].set(
            0.25 * elementSize,
            -0.75 * elementSize,
            data[xi + 1][yi] - h
        );

        // bottom triangle verts
        verts[3].set(
            0.25 * elementSize,
            0.25 * elementSize,
            - h-1
        );
        verts[4].set(
            -0.75 * elementSize,
            0.25 * elementSize,
            - h-1
        );
        verts[5].set(
            0.25 * elementSize,
            -0.75 * elementSize,
            - h-1
        );

        // Top triangle
        faces[0][0] = 0;
        faces[0][1] = 1;
        faces[0][2] = 2;

        // bottom triangle
        faces[1][0] = 5;
        faces[1][1] = 4;
        faces[1][2] = 3;

        // +x facing quad
        faces[2][0] = 2;
        faces[2][1] = 5;
        faces[2][2] = 3;
        faces[2][3] = 0;

        // +y facing quad
        faces[3][0] = 3;
        faces[3][1] = 4;
        faces[3][2] = 1;
        faces[3][3] = 0;

        // -xy facing quad
        faces[4][0] = 1;
        faces[4][1] = 4;
        faces[4][2] = 5;
        faces[4][3] = 2;
    }

    result.computeNormals();
    result.computeEdges();
    result.updateBoundingSphereRadius();

    this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
};

Heightfield.prototype.calculateLocalInertia = function(mass, target){
    target = target || new Vec3();
    target.set(0, 0, 0);
    return target;
};

Heightfield.prototype.volume = function(){
    return Number.MAX_VALUE; // The terrain is infinite
};

Heightfield.prototype.calculateWorldAABB = function(pos, quat, min, max){
    // TODO: do it properly
    min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
};

Heightfield.prototype.updateBoundingSphereRadius = function(){
    // Use the bounding box of the min/max values
    var data = this.data,
        s = this.elementSize;
    this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
};

/**
 * Sets the height values from an image. Currently only supported in browser.
 * @method setHeightsFromImage
 * @param {Image} image
 * @param {Vec3} scale
 */
Heightfield.prototype.setHeightsFromImage = function(image, scale){
    var canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    var context = canvas.getContext('2d');
    context.drawImage(image, 0, 0);
    var imageData = context.getImageData(0, 0, image.width, image.height);

    var matrix = this.data;
    matrix.length = 0;
    this.elementSize = Math.abs(scale.x) / imageData.width;
    for(var i=0; i<imageData.height; i++){
        var row = [];
        for(var j=0; j<imageData.width; j++){
            var a = imageData.data[(i*imageData.height + j) * 4];
            var b = imageData.data[(i*imageData.height + j) * 4 + 1];
            var c = imageData.data[(i*imageData.height + j) * 4 + 2];
            var height = (a + b + c) / 4 / 255 * scale.z;
            if(scale.x < 0){
                row.push(height);
            } else {
                row.unshift(height);
            }
        }
        if(scale.y < 0){
            matrix.unshift(row);
        } else {
            matrix.push(row);
        }
    }
    this.updateMaxValue();
    this.updateMinValue();
    this.update();
};
},{"../math/Vec3":33,"../utils/Utils":56,"./ConvexPolyhedron":41,"./Shape":46}],44:[function(require,module,exports){
module.exports = Particle;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');

/**
 * Particle shape.
 * @class Particle
 * @constructor
 * @author schteppe
 * @extends Shape
 */
function Particle(){
    Shape.call(this);

    this.type = Shape.types.PARTICLE;
}
Particle.prototype = new Shape();
Particle.prototype.constructor = Particle;

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 * @return {Vec3}
 */
Particle.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    target.set(0, 0, 0);
    return target;
};

Particle.prototype.volume = function(){
    return 0;
};

Particle.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = 0;
};

Particle.prototype.calculateWorldAABB = function(pos,quat,min,max){
    // Get each axis max
    min.copy(pos);
    max.copy(pos);
};

},{"../math/Vec3":33,"./Shape":46}],45:[function(require,module,exports){
module.exports = Plane;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');

/**
 * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a RigidBody and rotate that body. See the demos.
 * @class Plane
 * @constructor
 * @extends Shape
 * @author schteppe
 */
function Plane(){
    Shape.call(this);
    this.type = Shape.types.PLANE;

    // World oriented normal
    this.worldNormal = new Vec3();
    this.worldNormalNeedsUpdate = true;

    this.boundingSphereRadius = Number.MAX_VALUE;
}
Plane.prototype = new Shape();
Plane.prototype.constructor = Plane;

Plane.prototype.computeWorldNormal = function(quat){
    var n = this.worldNormal;
    n.set(0,0,1);
    quat.vmult(n,n);
    this.worldNormalNeedsUpdate = false;
};

Plane.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    return target;
};

Plane.prototype.volume = function(){
    return Number.MAX_VALUE; // The plane is infinite...
};

var tempNormal = new Vec3();
Plane.prototype.calculateWorldAABB = function(pos, quat, min, max){
    // The plane AABB is infinite, except if the normal is pointing along any axis
    tempNormal.set(0,0,1); // Default plane normal is z
    quat.vmult(tempNormal,tempNormal);
    var maxVal = Number.MAX_VALUE;
    min.set(-maxVal, -maxVal, -maxVal);
    max.set(maxVal, maxVal, maxVal);

    if(tempNormal.x === 1){ max.x = pos.x; }
    if(tempNormal.y === 1){ max.y = pos.y; }
    if(tempNormal.z === 1){ max.z = pos.z; }

    if(tempNormal.x === -1){ min.x = pos.x; }
    if(tempNormal.y === -1){ min.y = pos.y; }
    if(tempNormal.z === -1){ min.z = pos.z; }
};

Plane.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = Number.MAX_VALUE;
};
},{"../math/Vec3":33,"./Shape":46}],46:[function(require,module,exports){
module.exports = Shape;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Material = require('../material/Material');

/**
 * Base class for shapes
 * @class Shape
 * @constructor
 * @author schteppe
 * @todo Should have a mechanism for caching bounding sphere radius instead of calculating it each time
 */
function Shape(){

    /**
     * Identifyer of the Shape.
     * @property {number} id
     */
    this.id = Shape.idCounter++;

    /**
     * The type of this shape. Must be set to an int > 0 by subclasses.
     * @property type
     * @type {Number}
     * @see Shape.types
     */
    this.type = 0;

    /**
     * The local bounding sphere radius of this shape.
     * @property {Number} boundingSphereRadius
     */
    this.boundingSphereRadius = 0;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
     * @property {boolean} collisionResponse
     */
    this.collisionResponse = true;

    /**
     * @property {Material} material
     */
    this.material = null;
}
Shape.prototype.constructor = Shape;

/**
 * Computes the bounding sphere radius. The result is stored in the property .boundingSphereRadius
 * @method updateBoundingSphereRadius
 */
Shape.prototype.updateBoundingSphereRadius = function(){
    throw "computeBoundingSphereRadius() not implemented for shape type "+this.type;
};

/**
 * Get the volume of this shape
 * @method volume
 * @return {Number}
 */
Shape.prototype.volume = function(){
    throw "volume() not implemented for shape type "+this.type;
};

/**
 * Calculates the inertia in the local frame for this shape.
 * @method calculateLocalInertia
 * @param {Number} mass
 * @param {Vec3} target
 * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
 */
Shape.prototype.calculateLocalInertia = function(mass,target){
    throw "calculateLocalInertia() not implemented for shape type "+this.type;
};

Shape.idCounter = 0;

/**
 * The available shape types.
 * @static
 * @property types
 * @type {Object}
 */
Shape.types = {
    SPHERE:1,
    PLANE:2,
    BOX:4,
    COMPOUND:8,
    CONVEXPOLYHEDRON:16,
    HEIGHTFIELD:32,
    PARTICLE:64,
    CYLINDER:128,
    TRIMESH:256
};


},{"../material/Material":28,"../math/Quaternion":31,"../math/Vec3":33,"./Shape":46}],47:[function(require,module,exports){
module.exports = Sphere;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');

/**
 * Spherical shape
 * @class Sphere
 * @constructor
 * @extends Shape
 * @param {Number} radius The radius of the sphere, a non-negative number.
 * @author schteppe / http://github.com/schteppe
 */
function Sphere(radius){
    Shape.call(this);

    /**
     * @property {Number} radius
     */
    this.radius = radius!==undefined ? Number(radius) : 1.0;
    this.type = Shape.types.SPHERE;

    if(this.radius < 0){
        throw new Error('The sphere radius cannot be negative.');
    }

    this.updateBoundingSphereRadius();
}
Sphere.prototype = new Shape();
Sphere.prototype.constructor = Sphere;

Sphere.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    var I = 2.0*mass*this.radius*this.radius/5.0;
    target.x = I;
    target.y = I;
    target.z = I;
    return target;
};

Sphere.prototype.volume = function(){
    return 4.0 * Math.PI * this.radius / 3.0;
};

Sphere.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = this.radius;
};

Sphere.prototype.calculateWorldAABB = function(pos,quat,min,max){
    var r = this.radius;
    var axes = ['x','y','z'];
    for(var i=0; i<axes.length; i++){
        var ax = axes[i];
        min[ax] = pos[ax] - r;
        max[ax] = pos[ax] + r;
    }
};

},{"../math/Vec3":33,"./Shape":46}],48:[function(require,module,exports){
module.exports = Trimesh;

var Shape = require('./Shape');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Transform = require('../math/Transform');
var AABB = require('../collision/AABB');
var Octree = require('../utils/Octree');

/**
 * @class Trimesh
 * @constructor
 * @param {array} vertices
 * @param {array} indices
 * @extends Shape
 * @example
 *     // How to make a mesh with a single triangle
 *     var vertices = [
 *         0, 0, 0, // vertex 0
 *         1, 0, 0, // vertex 1
 *         0, 1, 0  // vertex 2
 *     ];
 *     var indices = [
 *         0, 1, 2  // triangle 0
 *     ];
 *     var trimeshShape = new Trimesh(vertices, indices);
 */
function Trimesh(vertices, indices) {
    Shape.call(this);
    this.type = Shape.types.TRIMESH;

    /**
     * @property vertices
     * @type {Array}
     */
    this.vertices = new Float32Array(vertices);

    /**
     * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
     * @property indices
     * @type {Array}
     */
    this.indices = new Int16Array(indices);

    /**
     * The normals data.
     * @property normals
     * @type {Array}
     */
    this.normals = new Float32Array(indices.length);

    /**
     * The local AABB of the mesh.
     * @property aabb
     * @type {Array}
     */
    this.aabb = new AABB();

    /**
     * References to vertex pairs, making up all unique edges in the trimesh.
     * @property {array} edges
     */
    this.edges = null;

    /**
     * Local scaling of the mesh. Use .setScale() to set it.
     * @property {Vec3} scale
     */
    this.scale = new Vec3(1, 1, 1);

    /**
     * The indexed triangles. Use .updateTree() to update it.
     * @property {Octree} tree
     */
    this.tree = new Octree();

    this.updateEdges();
    this.updateNormals();
    this.updateAABB();
    this.updateBoundingSphereRadius();
    this.updateTree();
}
Trimesh.prototype = new Shape();
Trimesh.prototype.constructor = Trimesh;

var computeNormals_n = new Vec3();

/**
 * @method updateTree
 */
Trimesh.prototype.updateTree = function(){
    var tree = this.tree;

    tree.reset();
    tree.aabb.copy(this.aabb);
    var scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled
    tree.aabb.lowerBound.x *= 1 / scale.x;
    tree.aabb.lowerBound.y *= 1 / scale.y;
    tree.aabb.lowerBound.z *= 1 / scale.z;
    tree.aabb.upperBound.x *= 1 / scale.x;
    tree.aabb.upperBound.y *= 1 / scale.y;
    tree.aabb.upperBound.z *= 1 / scale.z;

    // Insert all triangles
    var triangleAABB = new AABB();
    var a = new Vec3();
    var b = new Vec3();
    var c = new Vec3();
    var points = [a, b, c];
    for (var i = 0; i < this.indices.length / 3; i++) {
        //this.getTriangleVertices(i, a, b, c);

        // Get unscaled triangle verts
        var i3 = i * 3;
        this._getUnscaledVertex(this.indices[i3], a);
        this._getUnscaledVertex(this.indices[i3 + 1], b);
        this._getUnscaledVertex(this.indices[i3 + 2], c);

        triangleAABB.setFromPoints(points);
        tree.insert(triangleAABB, i);
    }
    tree.removeEmptyNodes();
};

var unscaledAABB = new AABB();

/**
 * Get triangles in a local AABB from the trimesh.
 * @method getTrianglesInAABB
 * @param  {AABB} aabb
 * @param  {array} result An array of integers, referencing the queried triangles.
 */
Trimesh.prototype.getTrianglesInAABB = function(aabb, result){
    unscaledAABB.copy(aabb);

    // Scale it to local
    var scale = this.scale;
    var isx = scale.x;
    var isy = scale.y;
    var isz = scale.z;
    var l = unscaledAABB.lowerBound;
    var u = unscaledAABB.upperBound;
    l.x /= isx;
    l.y /= isy;
    l.z /= isz;
    u.x /= isx;
    u.y /= isy;
    u.z /= isz;

    return this.tree.aabbQuery(unscaledAABB, result);
};

/**
 * @method setScale
 * @param {Vec3} scale
 */
Trimesh.prototype.setScale = function(scale){
    var wasUniform = this.scale.x === this.scale.y === this.scale.z;
    var isUniform = scale.x === scale.y === scale.z;

    if(!(wasUniform && isUniform)){
        // Non-uniform scaling. Need to update normals.
        this.updateNormals();
    }
    this.scale.copy(scale);
    this.updateAABB();
    this.updateBoundingSphereRadius();
};

/**
 * Compute the normals of the faces. Will save in the .normals array.
 * @method updateNormals
 */
Trimesh.prototype.updateNormals = function(){
    var n = computeNormals_n;

    // Generate normals
    var normals = this.normals;
    for(var i=0; i < this.indices.length / 3; i++){
        var i3 = i * 3;

        var a = this.indices[i3],
            b = this.indices[i3 + 1],
            c = this.indices[i3 + 2];

        this.getVertex(a, va);
        this.getVertex(b, vb);
        this.getVertex(c, vc);

        Trimesh.computeNormal(vb, va, vc, n);

        normals[i3] = n.x;
        normals[i3 + 1] = n.y;
        normals[i3 + 2] = n.z;
    }
};

/**
 * Update the .edges property
 * @method updateEdges
 */
Trimesh.prototype.updateEdges = function(){
    var edges = {};
    var add = function(indexA, indexB){
        var key = a < b ? a + '_' + b : b + '_' + a;
        edges[key] = true;
    };
    for(var i=0; i < this.indices.length / 3; i++){
        var i3 = i * 3;
        var a = this.indices[i3],
            b = this.indices[i3 + 1],
            c = this.indices[i3 + 2];
        add(a,b);
        add(b,c);
        add(c,a);
    }
    var keys = Object.keys(edges);
    this.edges = new Int16Array(keys.length * 2);
    for (var i = 0; i < keys.length; i++) {
        var indices = keys[i].split('_');
        this.edges[2 * i] = parseInt(indices[0], 10);
        this.edges[2 * i + 1] = parseInt(indices[1], 10);
    }
};

/**
 * Get an edge vertex
 * @method getEdgeVertex
 * @param  {number} edgeIndex
 * @param  {number} firstOrSecond 0 or 1, depending on which one of the vertices you need.
 * @param  {Vec3} vertexStore Where to store the result
 */
Trimesh.prototype.getEdgeVertex = function(edgeIndex, firstOrSecond, vertexStore){
    var vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];
    this.getVertex(vertexIndex, vertexStore);
};

var getEdgeVector_va = new Vec3();
var getEdgeVector_vb = new Vec3();

/**
 * Get a vector along an edge.
 * @method getEdgeVector
 * @param  {number} edgeIndex
 * @param  {Vec3} vectorStore
 */
Trimesh.prototype.getEdgeVector = function(edgeIndex, vectorStore){
    var va = getEdgeVector_va;
    var vb = getEdgeVector_vb;
    this.getEdgeVertex(edgeIndex, 0, va);
    this.getEdgeVertex(edgeIndex, 1, vb);
    vb.vsub(va, vectorStore);
};

/**
 * Get face normal given 3 vertices
 * @static
 * @method computeNormal
 * @param {Vec3} va
 * @param {Vec3} vb
 * @param {Vec3} vc
 * @param {Vec3} target
 */
var cb = new Vec3();
var ab = new Vec3();
Trimesh.computeNormal = function ( va, vb, vc, target ) {
    vb.vsub(va,ab);
    vc.vsub(vb,cb);
    cb.cross(ab,target);
    if ( !target.isZero() ) {
        target.normalize();
    }
};

var va = new Vec3();
var vb = new Vec3();
var vc = new Vec3();

/**
 * Get vertex i.
 * @method getVertex
 * @param  {number} i
 * @param  {Vec3} out
 * @return {Vec3} The "out" vector object
 */
Trimesh.prototype.getVertex = function(i, out){
    var scale = this.scale;
    this._getUnscaledVertex(i, out);
    out.x *= scale.x;
    out.y *= scale.y;
    out.z *= scale.z;
    return out;
};

/**
 * Get raw vertex i
 * @private
 * @method _getUnscaledVertex
 * @param  {number} i
 * @param  {Vec3} out
 * @return {Vec3} The "out" vector object
 */
Trimesh.prototype._getUnscaledVertex = function(i, out){
    var i3 = i * 3;
    var vertices = this.vertices;
    return out.set(
        vertices[i3],
        vertices[i3 + 1],
        vertices[i3 + 2]
    );
};

/**
 * Get a vertex from the trimesh,transformed by the given position and quaternion.
 * @method getWorldVertex
 * @param  {number} i
 * @param  {Vec3} pos
 * @param  {Quaternion} quat
 * @param  {Vec3} out
 * @return {Vec3} The "out" vector object
 */
Trimesh.prototype.getWorldVertex = function(i, pos, quat, out){
    this.getVertex(i, out);
    Transform.pointToWorldFrame(pos, quat, out, out);
    return out;
};

/**
 * Get the three vertices for triangle i.
 * @method getTriangleVertices
 * @param  {number} i
 * @param  {Vec3} a
 * @param  {Vec3} b
 * @param  {Vec3} c
 */
Trimesh.prototype.getTriangleVertices = function(i, a, b, c){
    var i3 = i * 3;
    this.getVertex(this.indices[i3], a);
    this.getVertex(this.indices[i3 + 1], b);
    this.getVertex(this.indices[i3 + 2], c);
};

/**
 * Compute the normal of triangle i.
 * @method getNormal
 * @param  {Number} i
 * @param  {Vec3} target
 * @return {Vec3} The "target" vector object
 */
Trimesh.prototype.getNormal = function(i, target){
    var i3 = i * 3;
    return target.set(
        this.normals[i3],
        this.normals[i3 + 1],
        this.normals[i3 + 2]
    );
};

var cli_aabb = new AABB();

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 * @return {Vec3} The "target" vector object
 */
Trimesh.prototype.calculateLocalInertia = function(mass,target){
    // Approximate with box inertia
    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
    this.computeLocalAABB(cli_aabb);
    var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x,
        y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y,
        z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
    return target.set(
        1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z ),
        1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z ),
        1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x )
    );
};

var computeLocalAABB_worldVert = new Vec3();

/**
 * Compute the local AABB for the trimesh
 * @method computeLocalAABB
 * @param  {AABB} aabb
 */
Trimesh.prototype.computeLocalAABB = function(aabb){
    var l = aabb.lowerBound,
        u = aabb.upperBound,
        n = this.vertices.length,
        vertices = this.vertices,
        v = computeLocalAABB_worldVert;

    this.getVertex(0, v);
    l.copy(v);
    u.copy(v);

    for(var i=0; i !== n; i++){
        this.getVertex(i, v);

        if(v.x < l.x){
            l.x = v.x;
        } else if(v.x > u.x){
            u.x = v.x;
        }

        if(v.y < l.y){
            l.y = v.y;
        } else if(v.y > u.y){
            u.y = v.y;
        }

        if(v.z < l.z){
            l.z = v.z;
        } else if(v.z > u.z){
            u.z = v.z;
        }
    }
};


/**
 * Update the .aabb property
 * @method updateAABB
 */
Trimesh.prototype.updateAABB = function(){
    this.computeLocalAABB(this.aabb);
};

/**
 * Will update the .boundingSphereRadius property
 * @method updateBoundingSphereRadius
 */
Trimesh.prototype.updateBoundingSphereRadius = function(){
    // Assume points are distributed with local (0,0,0) as center
    var max2 = 0;
    var vertices = this.vertices;
    var v = new Vec3();
    for(var i=0, N=vertices.length / 3; i !== N; i++) {
        this.getVertex(i, v);
        var norm2 = v.norm2();
        if(norm2 > max2){
            max2 = norm2;
        }
    }
    this.boundingSphereRadius = Math.sqrt(max2);
};

var tempWorldVertex = new Vec3();
var calculateWorldAABB_frame = new Transform();
var calculateWorldAABB_aabb = new AABB();

/**
 * @method calculateWorldAABB
 * @param {Vec3}        pos
 * @param {Quaternion}  quat
 * @param {Vec3}        min
 * @param {Vec3}        max
 */
Trimesh.prototype.calculateWorldAABB = function(pos,quat,min,max){
    /*
    var n = this.vertices.length / 3,
        verts = this.vertices;
    var minx,miny,minz,maxx,maxy,maxz;

    var v = tempWorldVertex;
    for(var i=0; i<n; i++){
        this.getVertex(i, v);
        quat.vmult(v, v);
        pos.vadd(v, v);
        if (v.x < minx || minx===undefined){
            minx = v.x;
        } else if(v.x > maxx || maxx===undefined){
            maxx = v.x;
        }

        if (v.y < miny || miny===undefined){
            miny = v.y;
        } else if(v.y > maxy || maxy===undefined){
            maxy = v.y;
        }

        if (v.z < minz || minz===undefined){
            minz = v.z;
        } else if(v.z > maxz || maxz===undefined){
            maxz = v.z;
        }
    }
    min.set(minx,miny,minz);
    max.set(maxx,maxy,maxz);
    */

    // Faster approximation using local AABB
    var frame = calculateWorldAABB_frame;
    var result = calculateWorldAABB_aabb;
    frame.position = pos;
    frame.quaternion = quat;
    this.aabb.toWorldFrame(frame, result);
    min.copy(result.lowerBound);
    max.copy(result.upperBound);
};

/**
 * Get approximate volume
 * @method volume
 * @return {Number}
 */
Trimesh.prototype.volume = function(){
    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
};

/**
 * Create a Trimesh instance, shaped as a torus.
 * @static
 * @method createTorus
 * @param  {number} [radius=1]
 * @param  {number} [tube=0.5]
 * @param  {number} [radialSegments=8]
 * @param  {number} [tubularSegments=6]
 * @param  {number} [arc=6.283185307179586]
 * @return {Trimesh} A torus
 */
Trimesh.createTorus = function (radius, tube, radialSegments, tubularSegments, arc) {
    radius = radius || 1;
    tube = tube || 0.5;
    radialSegments = radialSegments || 8;
    tubularSegments = tubularSegments || 6;
    arc = arc || Math.PI * 2;

    var vertices = [];
    var indices = [];

    for ( var j = 0; j <= radialSegments; j ++ ) {
        for ( var i = 0; i <= tubularSegments; i ++ ) {
            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;

            var x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
            var y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
            var z = tube * Math.sin( v );

            vertices.push( x, y, z );
        }
    }

    for ( var j = 1; j <= radialSegments; j ++ ) {
        for ( var i = 1; i <= tubularSegments; i ++ ) {
            var a = ( tubularSegments + 1 ) * j + i - 1;
            var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
            var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
            var d = ( tubularSegments + 1 ) * j + i;

            indices.push(a, b, d);
            indices.push(b, c, d);
        }
    }

    return new Trimesh(vertices, indices);
};

},{"../collision/AABB":6,"../math/Quaternion":31,"../math/Transform":32,"../math/Vec3":33,"../utils/Octree":53,"./Shape":46}],49:[function(require,module,exports){
module.exports = GSSolver;

var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Solver = require('./Solver');

/**
 * Constraint equation Gauss-Seidel solver.
 * @class GSSolver
 * @constructor
 * @todo The spook parameters should be specified for each constraint, not globally.
 * @author schteppe / https://github.com/schteppe
 * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
 * @extends Solver
 */
function GSSolver(){
    Solver.call(this);

    /**
     * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
     * @property iterations
     * @type {Number}
     * @todo write more about solver and iterations in the wiki
     */
    this.iterations = 10;

    /**
     * When tolerance is reached, the system is assumed to be converged.
     * @property tolerance
     * @type {Number}
     */
    this.tolerance = 1e-7;
}
GSSolver.prototype = new Solver();

var GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.
var GSSolver_solve_invCs = [];
var GSSolver_solve_Bs = [];
GSSolver.prototype.solve = function(dt,world){
    var iter = 0,
        maxIter = this.iterations,
        tolSquared = this.tolerance*this.tolerance,
        equations = this.equations,
        Neq = equations.length,
        bodies = world.bodies,
        Nbodies = bodies.length,
        h = dt,
        q, B, invC, deltalambda, deltalambdaTot, GWlambda, lambdaj;

    // Update solve mass
    if(Neq !== 0){
        for(var i=0; i!==Nbodies; i++){
            bodies[i].updateSolveMassProperties();
        }
    }

    // Things that does not change during iteration can be computed once
    var invCs = GSSolver_solve_invCs,
        Bs = GSSolver_solve_Bs,
        lambda = GSSolver_solve_lambda;
    invCs.length = Neq;
    Bs.length = Neq;
    lambda.length = Neq;
    for(var i=0; i!==Neq; i++){
        var c = equations[i];
        lambda[i] = 0.0;
        Bs[i] = c.computeB(h);
        invCs[i] = 1.0 / c.computeC();
    }

    if(Neq !== 0){

        // Reset vlambda
        for(var i=0; i!==Nbodies; i++){
            var b=bodies[i],
                vlambda=b.vlambda,
                wlambda=b.wlambda;
            vlambda.set(0,0,0);
            wlambda.set(0,0,0);
        }

        // Iterate over equations
        for(iter=0; iter!==maxIter; iter++){

            // Accumulate the total error for each iteration.
            deltalambdaTot = 0.0;

            for(var j=0; j!==Neq; j++){

                var c = equations[j];

                // Compute iteration
                B = Bs[j];
                invC = invCs[j];
                lambdaj = lambda[j];
                GWlambda = c.computeGWlambda();
                deltalambda = invC * ( B - GWlambda - c.eps * lambdaj );

                // Clamp if we are not within the min/max interval
                if(lambdaj + deltalambda < c.minForce){
                    deltalambda = c.minForce - lambdaj;
                } else if(lambdaj + deltalambda > c.maxForce){
                    deltalambda = c.maxForce - lambdaj;
                }
                lambda[j] += deltalambda;

                deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)

                c.addToWlambda(deltalambda);
            }

            // If the total error is small enough - stop iterate
            if(deltalambdaTot*deltalambdaTot < tolSquared){
                break;
            }
        }

        // Add result to velocity
        for(var i=0; i!==Nbodies; i++){
            var b=bodies[i],
                v=b.velocity,
                w=b.angularVelocity;

            b.vlambda.vmul(b.linearFactor, b.vlambda);
            v.vadd(b.vlambda, v);

            b.wlambda.vmul(b.angularFactor, b.wlambda);
            w.vadd(b.wlambda, w);
        }

        // Set the .multiplier property of each equation
        var l = equations.length;
        var invDt = 1 / h;
        while(l--){
            equations[l].multiplier = lambda[l] * invDt;
        }
    }

    return iter;
};

},{"../math/Quaternion":31,"../math/Vec3":33,"./Solver":50}],50:[function(require,module,exports){
module.exports = Solver;

/**
 * Constraint equation solver base class.
 * @class Solver
 * @constructor
 * @author schteppe / https://github.com/schteppe
 */
function Solver(){
    /**
     * All equations to be solved
     * @property {Array} equations
     */
    this.equations = [];
}

/**
 * Should be implemented in subclasses!
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */
Solver.prototype.solve = function(dt,world){
    // Should return the number of iterations done!
    return 0;
};

/**
 * Add an equation
 * @method addEquation
 * @param {Equation} eq
 */
Solver.prototype.addEquation = function(eq){
    if (eq.enabled) {
        this.equations.push(eq);
    }
};

/**
 * Remove an equation
 * @method removeEquation
 * @param {Equation} eq
 */
Solver.prototype.removeEquation = function(eq){
    var eqs = this.equations;
    var i = eqs.indexOf(eq);
    if(i !== -1){
        eqs.splice(i,1);
    }
};

/**
 * Add all equations
 * @method removeAllEquations
 */
Solver.prototype.removeAllEquations = function(){
    this.equations.length = 0;
};


},{}],51:[function(require,module,exports){
module.exports = SplitSolver;

var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var Solver = require('./Solver');
var Body = require('../objects/Body');

/**
 * Splits the equations into islands and solves them independently. Can improve performance.
 * @class SplitSolver
 * @constructor
 * @extends Solver
 * @param {Solver} subsolver
 */
function SplitSolver(subsolver){
    Solver.call(this);
    this.iterations = 10;
    this.tolerance = 1e-7;
    this.subsolver = subsolver;
    this.nodes = [];
    this.nodePool = [];

    // Create needed nodes, reuse if possible
    while(this.nodePool.length < 128){
        this.nodePool.push(this.createNode());
    }
}
SplitSolver.prototype = new Solver();

// Returns the number of subsystems
var SplitSolver_solve_nodes = []; // All allocated node objects
var SplitSolver_solve_nodePool = []; // All allocated node objects
var SplitSolver_solve_eqs = [];   // Temp array
var SplitSolver_solve_bds = [];   // Temp array
var SplitSolver_solve_dummyWorld = {bodies:[]}; // Temp object

var STATIC = Body.STATIC;
function getUnvisitedNode(nodes){
    var Nnodes = nodes.length;
    for(var i=0; i!==Nnodes; i++){
        var node = nodes[i];
        if(!node.visited && !(node.body.type & STATIC)){
            return node;
        }
    }
    return false;
}

var queue = [];
function bfs(root,visitFunc,bds,eqs){
    queue.push(root);
    root.visited = true;
    visitFunc(root,bds,eqs);
    while(queue.length) {
        var node = queue.pop();
        // Loop over unvisited child nodes
        var child;
        while((child = getUnvisitedNode(node.children))) {
            child.visited = true;
            visitFunc(child,bds,eqs);
            queue.push(child);
        }
    }
}

function visitFunc(node,bds,eqs){
    bds.push(node.body);
    var Neqs = node.eqs.length;
    for(var i=0; i!==Neqs; i++){
        var eq = node.eqs[i];
        if(eqs.indexOf(eq) === -1){
            eqs.push(eq);
        }
    }
}

SplitSolver.prototype.createNode = function(){
    return { body:null, children:[], eqs:[], visited:false };
};

/**
 * Solve the subsystems
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */
SplitSolver.prototype.solve = function(dt,world){
    var nodes=SplitSolver_solve_nodes,
        nodePool=this.nodePool,
        bodies=world.bodies,
        equations=this.equations,
        Neq=equations.length,
        Nbodies=bodies.length,
        subsolver=this.subsolver;

    // Create needed nodes, reuse if possible
    while(nodePool.length < Nbodies){
        nodePool.push(this.createNode());
    }
    nodes.length = Nbodies;
    for (var i = 0; i < Nbodies; i++) {
        nodes[i] = nodePool[i];
    }

    // Reset node values
    for(var i=0; i!==Nbodies; i++){
        var node = nodes[i];
        node.body = bodies[i];
        node.children.length = 0;
        node.eqs.length = 0;
        node.visited = false;
    }
    for(var k=0; k!==Neq; k++){
        var eq=equations[k],
            i=bodies.indexOf(eq.bi),
            j=bodies.indexOf(eq.bj),
            ni=nodes[i],
            nj=nodes[j];
        ni.children.push(nj);
        ni.eqs.push(eq);
        nj.children.push(ni);
        nj.eqs.push(eq);
    }

    var child, n=0, eqs=SplitSolver_solve_eqs;

    subsolver.tolerance = this.tolerance;
    subsolver.iterations = this.iterations;

    var dummyWorld = SplitSolver_solve_dummyWorld;
    while((child = getUnvisitedNode(nodes))){
        eqs.length = 0;
        dummyWorld.bodies.length = 0;
        bfs(child, visitFunc, dummyWorld.bodies, eqs);

        var Neqs = eqs.length;

        eqs = eqs.sort(sortById);

        for(var i=0; i!==Neqs; i++){
            subsolver.addEquation(eqs[i]);
        }

        var iter = subsolver.solve(dt,dummyWorld);
        subsolver.removeAllEquations();
        n++;
    }

    return n;
};

function sortById(a, b){
    return b.id - a.id;
}
},{"../math/Quaternion":31,"../math/Vec3":33,"../objects/Body":34,"./Solver":50}],52:[function(require,module,exports){
/**
 * Base class for objects that dispatches events.
 * @class EventTarget
 * @constructor
 */
var EventTarget = function () {

};

module.exports = EventTarget;

EventTarget.prototype = {
    constructor: EventTarget,

    /**
     * Add an event listener
     * @method addEventListener
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventTarget} The self object, for chainability.
     */
    addEventListener: function ( type, listener ) {
        if ( this._listeners === undefined ){ this._listeners = {}; }
        var listeners = this._listeners;
        if ( listeners[ type ] === undefined ) {
            listeners[ type ] = [];
        }
        if ( listeners[ type ].indexOf( listener ) === - 1 ) {
            listeners[ type ].push( listener );
        }
        return this;
    },

    /**
     * Check if an event listener is added
     * @method hasEventListener
     * @param  {String} type
     * @param  {Function} listener
     * @return {Boolean}
     */
    hasEventListener: function ( type, listener ) {
        if ( this._listeners === undefined ){ return false; }
        var listeners = this._listeners;
        if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
            return true;
        }
        return false;
    },

    /**
     * Remove an event listener
     * @method removeEventListener
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventTarget} The self object, for chainability.
     */
    removeEventListener: function ( type, listener ) {
        if ( this._listeners === undefined ){ return this; }
        var listeners = this._listeners;
        if ( listeners[type] === undefined ){ return this; }
        var index = listeners[ type ].indexOf( listener );
        if ( index !== - 1 ) {
            listeners[ type ].splice( index, 1 );
        }
        return this;
    },

    /**
     * Emit an event.
     * @method dispatchEvent
     * @param  {Object} event
     * @param  {String} event.type
     * @return {EventTarget} The self object, for chainability.
     */
    dispatchEvent: function ( event ) {
        if ( this._listeners === undefined ){ return this; }
        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];
        if ( listenerArray !== undefined ) {
            event.target = this;
            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {
                listenerArray[ i ].call( this, event );
            }
        }
        return this;
    }
};

},{}],53:[function(require,module,exports){
var AABB = require('../collision/AABB');
var Vec3 = require('../math/Vec3');

module.exports = Octree;

/**
 * @class OctreeNode
 * @param {object} [options]
 * @param {Octree} [options.root]
 * @param {AABB} [options.aabb]
 */
function OctreeNode(options){
    options = options || {};

    /**
     * The root node
     * @property {OctreeNode} root
     */
    this.root = options.root || null;

    /**
     * Boundary of this node
     * @property {AABB} aabb
     */
    this.aabb = options.aabb ? options.aabb.clone() : new AABB();

    /**
     * Contained data at the current node level.
     * @property {Array} data
     */
    this.data = [];

    /**
     * Children to this node
     * @property {Array} children
     */
    this.children = [];
}

/**
 * @class Octree
 * @param {AABB} aabb The total AABB of the tree
 * @param {object} [options]
 * @param {number} [options.maxDepth=8]
 * @extends OctreeNode
 */
function Octree(aabb, options){
    options = options || {};
    options.root = null;
    options.aabb = aabb;
    OctreeNode.call(this, options);

    /**
     * Maximum subdivision depth
     * @property {number} maxDepth
     */
    this.maxDepth = typeof(options.maxDepth) !== 'undefined' ? options.maxDepth : 8;
}
Octree.prototype = new OctreeNode();

OctreeNode.prototype.reset = function(aabb, options){
    this.children.length = this.data.length = 0;
};

/**
 * Insert data into this node
 * @method insert
 * @param  {AABB} aabb
 * @param  {object} elementData
 * @return {boolean} True if successful, otherwise false
 */
OctreeNode.prototype.insert = function(aabb, elementData, level){
    var nodeData = this.data;
    level = level || 0;

    // Ignore objects that do not belong in this node
    if (!this.aabb.contains(aabb)){
        return false; // object cannot be added
    }

    var children = this.children;

    if(level < (this.maxDepth || this.root.maxDepth)){
        // Subdivide if there are no children yet
        var subdivided = false;
        if (!children.length){
            this.subdivide();
            subdivided = true;
        }

        // add to whichever node will accept it
        for (var i = 0; i !== 8; i++) {
            if (children[i].insert(aabb, elementData, level + 1)){
                return true;
            }
        }

        if(subdivided){
            // No children accepted! Might as well just remove em since they contain none
            children.length = 0;
        }
    }

    // Too deep, or children didnt want it. add it in current node
    nodeData.push(elementData);

    return true;
};

var halfDiagonal = new Vec3();

/**
 * Create 8 equally sized children nodes and put them in the .children array.
 * @method subdivide
 */
OctreeNode.prototype.subdivide = function() {
    var aabb = this.aabb;
    var l = aabb.lowerBound;
    var u = aabb.upperBound;

    var children = this.children;

    children.push(
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,0,0) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,0,0) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,1,0) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,1,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,1,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,0,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,0,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,1,0) }) })
    );

    u.vsub(l, halfDiagonal);
    halfDiagonal.scale(0.5, halfDiagonal);

    var root = this.root || this;

    for (var i = 0; i !== 8; i++) {
        var child = children[i];

        // Set current node as root
        child.root = root;

        // Compute bounds
        var lowerBound = child.aabb.lowerBound;
        lowerBound.x *= halfDiagonal.x;
        lowerBound.y *= halfDiagonal.y;
        lowerBound.z *= halfDiagonal.z;

        lowerBound.vadd(l, lowerBound);

        // Upper bound is always lower bound + halfDiagonal
        lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
    }
};

/**
 * Get all data, potentially within an AABB
 * @method aabbQuery
 * @param  {AABB} aabb
 * @param  {array} result
 * @return {array} The "result" object
 */
OctreeNode.prototype.aabbQuery = function(aabb, result) {

    var nodeData = this.data;

    // abort if the range does not intersect this node
    // if (!this.aabb.overlaps(aabb)){
    //     return result;
    // }

    // Add objects at this level
    // Array.prototype.push.apply(result, nodeData);

    // Add child data
    // @todo unwrap recursion into a queue / loop, that's faster in JS
    var children = this.children;


    // for (var i = 0, N = this.children.length; i !== N; i++) {
    //     children[i].aabbQuery(aabb, result);
    // }

    var queue = [this];
    while (queue.length) {
        var node = queue.pop();
        if (node.aabb.overlaps(aabb)){
            Array.prototype.push.apply(result, node.data);
        }
        Array.prototype.push.apply(queue, node.children);
    }

    return result;
};

var tmpAABB = new AABB();

/**
 * Get all data, potentially intersected by a ray.
 * @method rayQuery
 * @param  {Ray} ray
 * @param  {Transform} treeTransform
 * @param  {array} result
 * @return {array} The "result" object
 */
OctreeNode.prototype.rayQuery = function(ray, treeTransform, result) {

    // Use aabb query for now.
    // @todo implement real ray query which needs less lookups
    ray.getAABB(tmpAABB);
    tmpAABB.toLocalFrame(treeTransform, tmpAABB);
    this.aabbQuery(tmpAABB, result);

    return result;
};

/**
 * @method removeEmptyNodes
 */
OctreeNode.prototype.removeEmptyNodes = function() {
    var queue = [this];
    while (queue.length) {
        var node = queue.pop();
        for (var i = node.children.length - 1; i >= 0; i--) {
            if(!node.children[i].data.length){
                node.children.splice(i, 1);
            }
        }
        Array.prototype.push.apply(queue, node.children);
    }
};

},{"../collision/AABB":6,"../math/Vec3":33}],54:[function(require,module,exports){
module.exports = Pool;

/**
 * For pooling objects that can be reused.
 * @class Pool
 * @constructor
 */
function Pool(){
    /**
     * The pooled objects
     * @property {Array} objects
     */
    this.objects = [];

    /**
     * Constructor of the objects
     * @property {mixed} type
     */
    this.type = Object;
}

/**
 * Release an object after use
 * @method release
 * @param {Object} obj
 */
Pool.prototype.release = function(){
    var Nargs = arguments.length;
    for(var i=0; i!==Nargs; i++){
        this.objects.push(arguments[i]);
    }
    return this;
};

/**
 * Get an object
 * @method get
 * @return {mixed}
 */
Pool.prototype.get = function(){
    if(this.objects.length===0){
        return this.constructObject();
    } else {
        return this.objects.pop();
    }
};

/**
 * Construct an object. Should be implmented in each subclass.
 * @method constructObject
 * @return {mixed}
 */
Pool.prototype.constructObject = function(){
    throw new Error("constructObject() not implemented in this Pool subclass yet!");
};

/**
 * @method resize
 * @param {number} size
 * @return {Pool} Self, for chaining
 */
Pool.prototype.resize = function (size) {
    var objects = this.objects;

    while (objects.length > size) {
        objects.pop();
    }

    while (objects.length < size) {
        objects.push(this.constructObject());
    }

    return this;
};


},{}],55:[function(require,module,exports){
module.exports = TupleDictionary;

/**
 * @class TupleDictionary
 * @constructor
 */
function TupleDictionary() {

    /**
     * The data storage
     * @property data
     * @type {Object}
     */
    this.data = { keys:[] };
}

/**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
TupleDictionary.prototype.get = function(i, j) {
    if (i > j) {
        // swap
        var temp = j;
        j = i;
        i = temp;
    }
    return this.data[i+'-'+j];
};

/**
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */
TupleDictionary.prototype.set = function(i, j, value) {
    if (i > j) {
        var temp = j;
        j = i;
        i = temp;
    }
    var key = i+'-'+j;

    // Check if key already exists
    if(!this.get(i,j)){
        this.data.keys.push(key);
    }

    this.data[key] = value;
};

/**
 * @method reset
 */
TupleDictionary.prototype.reset = function() {
    var data = this.data,
        keys = data.keys;
    while(keys.length > 0){
        var key = keys.pop();
        delete data[key];
    }
};

},{}],56:[function(require,module,exports){
function Utils(){}

module.exports = Utils;

/**
 * Extend an options object with default values.
 * @static
 * @method defaults
 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
 * @param  {object} defaults An object containing default values.
 * @return {object} The modified options object.
 */
Utils.defaults = function(options, defaults){
    options = options || {};

    for(var key in defaults){
        if(!(key in options)){
            options[key] = defaults[key];
        }
    }

    return options;
};

},{}],57:[function(require,module,exports){
module.exports = Vec3Pool;

var Vec3 = require('../math/Vec3');
var Pool = require('./Pool');

/**
 * @class Vec3Pool
 * @constructor
 * @extends Pool
 */
function Vec3Pool(){
    Pool.call(this);
    this.type = Vec3;
}
Vec3Pool.prototype = new Pool();

/**
 * Construct a vector
 * @method constructObject
 * @return {Vec3}
 */
Vec3Pool.prototype.constructObject = function(){
    return new Vec3();
};

},{"../math/Vec3":33,"./Pool":54}],58:[function(require,module,exports){
module.exports = Narrowphase;

var AABB = require('../collision/AABB');
var Shape = require('../shapes/Shape');
var Ray = require('../collision/Ray');
var Vec3 = require('../math/Vec3');
var Transform = require('../math/Transform');
var ConvexPolyhedron = require('../shapes/ConvexPolyhedron');
var Quaternion = require('../math/Quaternion');
var Solver = require('../solver/Solver');
var Vec3Pool = require('../utils/Vec3Pool');
var ContactEquation = require('../equations/ContactEquation');
var FrictionEquation = require('../equations/FrictionEquation');

/**
 * Helper class for the World. Generates ContactEquations.
 * @class Narrowphase
 * @constructor
 * @todo Sphere-ConvexPolyhedron contacts
 * @todo Contact reduction
 * @todo  should move methods to prototype
 */
function Narrowphase(world){

    /**
     * Internal storage of pooled contact points.
     * @property {Array} contactPointPool
     */
    this.contactPointPool = [];

    this.frictionEquationPool = [];

    this.result = [];
    this.frictionResult = [];

    /**
     * Pooled vectors.
     * @property {Vec3Pool} v3pool
     */
    this.v3pool = new Vec3Pool();

    this.world = world;
    this.currentContactMaterial = null;

    /**
     * @property {Boolean} enableFrictionReduction
     */
    this.enableFrictionReduction = false;
}

/**
 * Make a contact object, by using the internal pool or creating a new one.
 * @method createContactEquation
 * @param {Body} bi
 * @param {Body} bj
 * @param {Shape} si
 * @param {Shape} sj
 * @param {Shape} overrideShapeA
 * @param {Shape} overrideShapeB
 * @return {ContactEquation}
 */
Narrowphase.prototype.createContactEquation = function(bi, bj, si, sj, overrideShapeA, overrideShapeB){
    var c;
    if(this.contactPointPool.length){
        c = this.contactPointPool.pop();
        c.bi = bi;
        c.bj = bj;
    } else {
        c = new ContactEquation(bi, bj);
    }

    c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

    var cm = this.currentContactMaterial;

    c.restitution = cm.restitution;

    c.setSpookParams(
        cm.contactEquationStiffness,
        cm.contactEquationRelaxation,
        this.world.dt
    );

    var matA = si.material || bi.material;
    var matB = sj.material || bj.material;
    if(matA && matB && matA.restitution >= 0 && matB.restitution >= 0){
        c.restitution = matA.restitution * matB.restitution;
    }

    c.si = overrideShapeA || si;
    c.sj = overrideShapeB || sj;

    return c;
};

Narrowphase.prototype.createFrictionEquationsFromContact = function(contactEquation, outArray){
    var bodyA = contactEquation.bi;
    var bodyB = contactEquation.bj;
    var shapeA = contactEquation.si;
    var shapeB = contactEquation.sj;

    var world = this.world;
    var cm = this.currentContactMaterial;

    // If friction or restitution were specified in the material, use them
    var friction = cm.friction;
    var matA = shapeA.material || bodyA.material;
    var matB = shapeB.material || bodyB.material;
    if(matA && matB && matA.friction >= 0 && matB.friction >= 0){
        friction = matA.friction * matB.friction;
    }

    if(friction > 0){

        // Create 2 tangent equations
        var mug = friction * world.gravity.length();
        var reducedMass = (bodyA.invMass + bodyB.invMass);
        if(reducedMass > 0){
            reducedMass = 1/reducedMass;
        }
        var pool = this.frictionEquationPool;
        var c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA,bodyB,mug*reducedMass);
        var c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA,bodyB,mug*reducedMass);

        c1.bi = c2.bi = bodyA;
        c1.bj = c2.bj = bodyB;
        c1.minForce = c2.minForce = -mug*reducedMass;
        c1.maxForce = c2.maxForce = mug*reducedMass;

        // Copy over the relative vectors
        c1.ri.copy(contactEquation.ri);
        c1.rj.copy(contactEquation.rj);
        c2.ri.copy(contactEquation.ri);
        c2.rj.copy(contactEquation.rj);

        // Construct tangents
        contactEquation.ni.tangents(c1.t, c2.t);

        // Set spook params
        c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
        c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);

        c1.enabled = c2.enabled = contactEquation.enabled;

        outArray.push(c1, c2);

        return true;
    }

    return false;
};

var averageNormal = new Vec3();
var averageContactPointA = new Vec3();
var averageContactPointB = new Vec3();

// Take the average N latest contact point on the plane.
Narrowphase.prototype.createFrictionFromAverage = function(numContacts){
    // The last contactEquation
    var c = this.result[this.result.length - 1];

    // Create the result: two "average" friction equations
    if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {
        return;
    }

    var f1 = this.frictionResult[this.frictionResult.length - 2];
    var f2 = this.frictionResult[this.frictionResult.length - 1];

    averageNormal.setZero();
    averageContactPointA.setZero();
    averageContactPointB.setZero();

    var bodyA = c.bi;
    var bodyB = c.bj;
    for(var i=0; i!==numContacts; i++){
        c = this.result[this.result.length - 1 - i];
        if(c.bodyA !== bodyA){
            averageNormal.vadd(c.ni, averageNormal); // vec2.add(eq.t, eq.t, c.normalA);
            averageContactPointA.vadd(c.ri, averageContactPointA); // vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
            averageContactPointB.vadd(c.rj, averageContactPointB);
        } else {
            averageNormal.vsub(c.ni, averageNormal); // vec2.sub(eq.t, eq.t, c.normalA);
            averageContactPointA.vadd(c.rj, averageContactPointA); // vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
            averageContactPointB.vadd(c.ri, averageContactPointB);
        }
    }

    var invNumContacts = 1 / numContacts;
    averageContactPointA.scale(invNumContacts, f1.ri); // vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
    averageContactPointB.scale(invNumContacts, f1.rj); // vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
    f2.ri.copy(f1.ri); // Should be the same
    f2.rj.copy(f1.rj);
    averageNormal.normalize();
    averageNormal.tangents(f1.t, f2.t);
    // return eq;
};


var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();
var tmpQuat1 = new Quaternion();
var tmpQuat2 = new Quaternion();

/**
 * Generate all contacts between a list of body pairs
 * @method getContacts
 * @param {array} p1 Array of body indices
 * @param {array} p2 Array of body indices
 * @param {World} world
 * @param {array} result Array to store generated contacts
 * @param {array} oldcontacts Optional. Array of reusable contact objects
 */
Narrowphase.prototype.getContacts = function(p1, p2, world, result, oldcontacts, frictionResult, frictionPool){
    // Save old contact objects
    this.contactPointPool = oldcontacts;
    this.frictionEquationPool = frictionPool;
    this.result = result;
    this.frictionResult = frictionResult;

    var qi = tmpQuat1;
    var qj = tmpQuat2;
    var xi = tmpVec1;
    var xj = tmpVec2;

    for(var k=0, N=p1.length; k!==N; k++){

        // Get current collision bodies
        var bi = p1[k],
            bj = p2[k];

        // Get contact material
        var bodyContactMaterial = null;
        if(bi.material && bj.material){
            bodyContactMaterial = world.getContactMaterial(bi.material,bj.material) || null;
        }

        for (var i = 0; i < bi.shapes.length; i++) {
            bi.quaternion.mult(bi.shapeOrientations[i], qi);
            bi.quaternion.vmult(bi.shapeOffsets[i], xi);
            xi.vadd(bi.position, xi);
            var si = bi.shapes[i];

            for (var j = 0; j < bj.shapes.length; j++) {

                // Compute world transform of shapes
                bj.quaternion.mult(bj.shapeOrientations[j], qj);
                bj.quaternion.vmult(bj.shapeOffsets[j], xj);
                xj.vadd(bj.position, xj);
                var sj = bj.shapes[j];

                if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
                    continue;
                }

                // Get collision material
                var shapeContactMaterial = null;
                if(si.material && sj.material){
                    shapeContactMaterial = world.getContactMaterial(si.material,sj.material) || null;
                }

                this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial;

                // Get contacts
                var resolver = this[si.type | sj.type];
                if(resolver){
                    if (si.type < sj.type) {
                        resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj);
                    } else {
                        resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj);
                    }
                }
            }
        }
    }
};

var numWarnings = 0;
var maxWarnings = 10;

function warn(msg){
    if(numWarnings > maxWarnings){
        return;
    }

    numWarnings++;

    console.warn(msg);
}

Narrowphase.prototype[Shape.types.BOX | Shape.types.BOX] =
Narrowphase.prototype.boxBox = function(si,sj,xi,xj,qi,qj,bi,bj){
    si.convexPolyhedronRepresentation.material = si.material;
    sj.convexPolyhedronRepresentation.material = sj.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    this.convexConvex(si.convexPolyhedronRepresentation,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj);
};

Narrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.boxConvex = function(si,sj,xi,xj,qi,qj,bi,bj){
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    this.convexConvex(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);
};

Narrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] =
Narrowphase.prototype.boxParticle = function(si,sj,xi,xj,qi,qj,bi,bj){
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    this.convexParticle(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);
};

/**
 * @method sphereSphere
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE] =
Narrowphase.prototype.sphereSphere = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj){
    // We will have only one contact in this case
    var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);

    // Contact normal
    xj.vsub(xi, r.ni);
    r.ni.normalize();

    // Contact point locations
    r.ri.copy(r.ni);
    r.rj.copy(r.ni);
    r.ri.mult(si.radius, r.ri);
    r.rj.mult(-sj.radius, r.rj);

    r.ri.vadd(xi, r.ri);
    r.ri.vsub(bi.position, r.ri);

    r.rj.vadd(xj, r.rj);
    r.rj.vsub(bj.position, r.rj);

    this.result.push(r);

    this.createFrictionEquationsFromContact(r, this.frictionResult);
};

/**
 * @method planeTrimesh
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
var planeTrimesh_normal = new Vec3();
var planeTrimesh_relpos = new Vec3();
var planeTrimesh_projected = new Vec3();
Narrowphase.prototype[Shape.types.PLANE | Shape.types.TRIMESH] =
Narrowphase.prototype.planeTrimesh = function(
    planeShape,
    trimeshShape,
    planePos,
    trimeshPos,
    planeQuat,
    trimeshQuat,
    planeBody,
    trimeshBody,
    rsi,
    rsj
){
    // Make contacts!
    var v = new Vec3();

    var normal = planeTrimesh_normal;
    normal.set(0,0,1);
    planeQuat.vmult(normal,normal); // Turn normal according to plane

    for(var i=0; i<trimeshShape.vertices.length / 3; i++){

        // Get world vertex from trimesh
        trimeshShape.getVertex(i, v);

        // Safe up
        var v2 = new Vec3();
        v2.copy(v);
        Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);

        // Check plane side
        var relpos = planeTrimesh_relpos;
        v.vsub(planePos, relpos);
        var dot = normal.dot(relpos);

        if(dot <= 0.0){
            var r = this.createContactEquation(planeBody,trimeshBody,planeShape,trimeshShape,rsi,rsj);

            r.ni.copy(normal); // Contact normal is the plane normal

            // Get vertex position projected on plane
            var projected = planeTrimesh_projected;
            normal.scale(relpos.dot(normal), projected);
            v.vsub(projected,projected);

            // ri is the projected world position minus plane position
            r.ri.copy(projected);
            r.ri.vsub(planeBody.position, r.ri);

            r.rj.copy(v);
            r.rj.vsub(trimeshBody.position, r.rj);

            // Store result
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
    }
};

/**
 * @method sphereTrimesh
 * @param  {Shape}      sphereShape
 * @param  {Shape}      trimeshShape
 * @param  {Vec3}       spherePos
 * @param  {Vec3}       trimeshPos
 * @param  {Quaternion} sphereQuat
 * @param  {Quaternion} trimeshQuat
 * @param  {Body}       sphereBody
 * @param  {Body}       trimeshBody
 */
var sphereTrimesh_normal = new Vec3();
var sphereTrimesh_relpos = new Vec3();
var sphereTrimesh_projected = new Vec3();
var sphereTrimesh_v = new Vec3();
var sphereTrimesh_v2 = new Vec3();
var sphereTrimesh_edgeVertexA = new Vec3();
var sphereTrimesh_edgeVertexB = new Vec3();
var sphereTrimesh_edgeVector = new Vec3();
var sphereTrimesh_edgeVectorUnit = new Vec3();
var sphereTrimesh_localSpherePos = new Vec3();
var sphereTrimesh_tmp = new Vec3();
var sphereTrimesh_va = new Vec3();
var sphereTrimesh_vb = new Vec3();
var sphereTrimesh_vc = new Vec3();
var sphereTrimesh_localSphereAABB = new AABB();
var sphereTrimesh_triangles = [];
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.TRIMESH] =
Narrowphase.prototype.sphereTrimesh = function (
    sphereShape,
    trimeshShape,
    spherePos,
    trimeshPos,
    sphereQuat,
    trimeshQuat,
    sphereBody,
    trimeshBody,
    rsi,
    rsj
) {

    var edgeVertexA = sphereTrimesh_edgeVertexA;
    var edgeVertexB = sphereTrimesh_edgeVertexB;
    var edgeVector = sphereTrimesh_edgeVector;
    var edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
    var localSpherePos = sphereTrimesh_localSpherePos;
    var tmp = sphereTrimesh_tmp;
    var localSphereAABB = sphereTrimesh_localSphereAABB;
    var v2 = sphereTrimesh_v2;
    var relpos = sphereTrimesh_relpos;
    var triangles = sphereTrimesh_triangles;

    // Convert sphere position to local in the trimesh
    Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos);

    // Get the aabb of the sphere locally in the trimesh
    var sphereRadius = sphereShape.radius;
    localSphereAABB.lowerBound.set(
        localSpherePos.x - sphereRadius,
        localSpherePos.y - sphereRadius,
        localSpherePos.z - sphereRadius
    );
    localSphereAABB.upperBound.set(
        localSpherePos.x + sphereRadius,
        localSpherePos.y + sphereRadius,
        localSpherePos.z + sphereRadius
    );

    trimeshShape.getTrianglesInAABB(localSphereAABB, triangles);
    //for (var i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All

    // Vertices
    var v = sphereTrimesh_v;
    var radiusSquared = sphereShape.radius * sphereShape.radius;
    for(var i=0; i<triangles.length; i++){
        for (var j = 0; j < 3; j++) {

            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v);

            // Check vertex overlap in sphere
            v.vsub(localSpherePos, relpos);

            if(relpos.norm2() <= radiusSquared){

                // Safe up
                v2.copy(v);
                Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);

                v.vsub(spherePos, relpos);

                var r = this.createContactEquation(sphereBody,trimeshBody,sphereShape,trimeshShape,rsi,rsj);
                r.ni.copy(relpos);
                r.ni.normalize();

                // ri is the vector from sphere center to the sphere surface
                r.ri.copy(r.ni);
                r.ri.scale(sphereShape.radius, r.ri);
                r.ri.vadd(spherePos, r.ri);
                r.ri.vsub(sphereBody.position, r.ri);

                r.rj.copy(v);
                r.rj.vsub(trimeshBody.position, r.rj);

                // Store result
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
        }
    }

    // Check all edges
    for(var i=0; i<triangles.length; i++){
        for (var j = 0; j < 3; j++) {

            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);
            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + ((j+1)%3)], edgeVertexB);
            edgeVertexB.vsub(edgeVertexA, edgeVector);

            // Project sphere position to the edge
            localSpherePos.vsub(edgeVertexB, tmp);
            var positionAlongEdgeB = tmp.dot(edgeVector);

            localSpherePos.vsub(edgeVertexA, tmp);
            var positionAlongEdgeA = tmp.dot(edgeVector);

            if(positionAlongEdgeA > 0 && positionAlongEdgeB < 0){

                // Now check the orthogonal distance from edge to sphere center
                localSpherePos.vsub(edgeVertexA, tmp);

                edgeVectorUnit.copy(edgeVector);
                edgeVectorUnit.normalize();
                positionAlongEdgeA = tmp.dot(edgeVectorUnit);

                edgeVectorUnit.scale(positionAlongEdgeA, tmp);
                tmp.vadd(edgeVertexA, tmp);

                // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame
                var dist = tmp.distanceTo(localSpherePos);
                if(dist < sphereShape.radius){
                    var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape,rsi,rsj);

                    tmp.vsub(localSpherePos, r.ni);
                    r.ni.normalize();
                    r.ni.scale(sphereShape.radius, r.ri);

                    Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
                    tmp.vsub(trimeshBody.position, r.rj);

                    Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
                    Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);

                    this.result.push(r);
                    this.createFrictionEquationsFromContact(r, this.frictionResult);
                }
            }
        }
    }

    // Triangle faces
    var va = sphereTrimesh_va;
    var vb = sphereTrimesh_vb;
    var vc = sphereTrimesh_vc;
    var normal = sphereTrimesh_normal;
    for(var i=0, N = triangles.length; i !== N; i++){
        trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
        trimeshShape.getNormal(triangles[i], normal);
        localSpherePos.vsub(va, tmp);
        var dist = tmp.dot(normal);
        normal.scale(dist, tmp);
        localSpherePos.vsub(tmp, tmp);

        // tmp is now the sphere position projected to the triangle plane
        dist = tmp.distanceTo(localSpherePos);
        if(Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius){
            var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape,rsi,rsj);

            tmp.vsub(localSpherePos, r.ni);
            r.ni.normalize();
            r.ni.scale(sphereShape.radius, r.ri);

            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
            tmp.vsub(trimeshBody.position, r.rj);

            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);

            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
    }

    triangles.length = 0;
};

var point_on_plane_to_sphere = new Vec3();
var plane_to_sphere_ortho = new Vec3();

/**
 * @method spherePlane
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] =
Narrowphase.prototype.spherePlane = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj){
    // We will have one contact in this case
    var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);

    // Contact normal
    r.ni.set(0,0,1);
    qj.vmult(r.ni, r.ni);
    r.ni.negate(r.ni); // body i is the sphere, flip normal
    r.ni.normalize(); // Needed?

    // Vector from sphere center to contact point
    r.ni.mult(si.radius, r.ri);

    // Project down sphere on plane
    xi.vsub(xj, point_on_plane_to_sphere);
    r.ni.mult(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho,r.rj); // The sphere position projected to plane

    if(-point_on_plane_to_sphere.dot(r.ni) <= si.radius){

        // Make it relative to the body
        var ri = r.ri;
        var rj = r.rj;
        ri.vadd(xi, ri);
        ri.vsub(bi.position, ri);
        rj.vadd(xj, rj);
        rj.vsub(bj.position, rj);

        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
};

// See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html
var pointInPolygon_edge = new Vec3();
var pointInPolygon_edge_x_normal = new Vec3();
var pointInPolygon_vtp = new Vec3();
function pointInPolygon(verts, normal, p){
    var positiveResult = null;
    var N = verts.length;
    for(var i=0; i!==N; i++){
        var v = verts[i];

        // Get edge to the next vertex
        var edge = pointInPolygon_edge;
        verts[(i+1) % (N)].vsub(v,edge);

        // Get cross product between polygon normal and the edge
        var edge_x_normal = pointInPolygon_edge_x_normal;
        //var edge_x_normal = new Vec3();
        edge.cross(normal,edge_x_normal);

        // Get vector between point and current vertex
        var vertex_to_p = pointInPolygon_vtp;
        p.vsub(v,vertex_to_p);

        // This dot product determines which side of the edge the point is
        var r = edge_x_normal.dot(vertex_to_p);

        // If all such dot products have same sign, we are inside the polygon.
        if(positiveResult===null || (r>0 && positiveResult===true) || (r<=0 && positiveResult===false)){
            if(positiveResult===null){
                positiveResult = r>0;
            }
            continue;
        } else {
            return false; // Encountered some other sign. Exit.
        }
    }

    // If we got here, all dot products were of the same sign.
    return true;
}

var box_to_sphere = new Vec3();
var sphereBox_ns = new Vec3();
var sphereBox_ns1 = new Vec3();
var sphereBox_ns2 = new Vec3();
var sphereBox_sides = [new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3()];
var sphereBox_sphere_to_corner = new Vec3();
var sphereBox_side_ns = new Vec3();
var sphereBox_side_ns1 = new Vec3();
var sphereBox_side_ns2 = new Vec3();

/**
 * @method sphereBox
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] =
Narrowphase.prototype.sphereBox = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj){
    var v3pool = this.v3pool;

    // we refer to the box as body j
    var sides = sphereBox_sides;
    xi.vsub(xj,box_to_sphere);
    sj.getSideNormals(sides,qj);
    var R =     si.radius;
    var penetrating_sides = [];

    // Check side (plane) intersections
    var found = false;

    // Store the resulting side penetration info
    var side_ns = sphereBox_side_ns;
    var side_ns1 = sphereBox_side_ns1;
    var side_ns2 = sphereBox_side_ns2;
    var side_h = null;
    var side_penetrations = 0;
    var side_dot1 = 0;
    var side_dot2 = 0;
    var side_distance = null;
    for(var idx=0,nsides=sides.length; idx!==nsides && found===false; idx++){
        // Get the plane side normal (ns)
        var ns = sphereBox_ns;
        ns.copy(sides[idx]);

        var h = ns.norm();
        ns.normalize();

        // The normal/distance dot product tells which side of the plane we are
        var dot = box_to_sphere.dot(ns);

        if(dot<h+R && dot>0){
            // Intersects plane. Now check the other two dimensions
            var ns1 = sphereBox_ns1;
            var ns2 = sphereBox_ns2;
            ns1.copy(sides[(idx+1)%3]);
            ns2.copy(sides[(idx+2)%3]);
            var h1 = ns1.norm();
            var h2 = ns2.norm();
            ns1.normalize();
            ns2.normalize();
            var dot1 = box_to_sphere.dot(ns1);
            var dot2 = box_to_sphere.dot(ns2);
            if(dot1<h1 && dot1>-h1 && dot2<h2 && dot2>-h2){
                var dist = Math.abs(dot-h-R);
                if(side_distance===null || dist < side_distance){
                    side_distance = dist;
                    side_dot1 = dot1;
                    side_dot2 = dot2;
                    side_h = h;
                    side_ns.copy(ns);
                    side_ns1.copy(ns1);
                    side_ns2.copy(ns2);
                    side_penetrations++;
                }
            }
        }
    }
    if(side_penetrations){
        found = true;
        var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
        side_ns.mult(-R,r.ri); // Sphere r
        r.ni.copy(side_ns);
        r.ni.negate(r.ni); // Normal should be out of sphere
        side_ns.mult(side_h,side_ns);
        side_ns1.mult(side_dot1,side_ns1);
        side_ns.vadd(side_ns1,side_ns);
        side_ns2.mult(side_dot2,side_ns2);
        side_ns.vadd(side_ns2,r.rj);

        // Make relative to bodies
        r.ri.vadd(xi, r.ri);
        r.ri.vsub(bi.position, r.ri);
        r.rj.vadd(xj, r.rj);
        r.rj.vsub(bj.position, r.rj);

        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }

    // Check corners
    var rj = v3pool.get();
    var sphere_to_corner = sphereBox_sphere_to_corner;
    for(var j=0; j!==2 && !found; j++){
        for(var k=0; k!==2 && !found; k++){
            for(var l=0; l!==2 && !found; l++){
                rj.set(0,0,0);
                if(j){
                    rj.vadd(sides[0],rj);
                } else {
                    rj.vsub(sides[0],rj);
                }
                if(k){
                    rj.vadd(sides[1],rj);
                } else {
                    rj.vsub(sides[1],rj);
                }
                if(l){
                    rj.vadd(sides[2],rj);
                } else {
                    rj.vsub(sides[2],rj);
                }

                // World position of corner
                xj.vadd(rj,sphere_to_corner);
                sphere_to_corner.vsub(xi,sphere_to_corner);

                if(sphere_to_corner.norm2() < R*R){
                    found = true;
                    var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
                    r.ri.copy(sphere_to_corner);
                    r.ri.normalize();
                    r.ni.copy(r.ri);
                    r.ri.mult(R,r.ri);
                    r.rj.copy(rj);

                    // Make relative to bodies
                    r.ri.vadd(xi, r.ri);
                    r.ri.vsub(bi.position, r.ri);
                    r.rj.vadd(xj, r.rj);
                    r.rj.vsub(bj.position, r.rj);

                    this.result.push(r);
                    this.createFrictionEquationsFromContact(r, this.frictionResult);
                }
            }
        }
    }
    v3pool.release(rj);
    rj = null;

    // Check edges
    var edgeTangent = v3pool.get();
    var edgeCenter = v3pool.get();
    var r = v3pool.get(); // r = edge center to sphere center
    var orthogonal = v3pool.get();
    var dist = v3pool.get();
    var Nsides = sides.length;
    for(var j=0; j!==Nsides && !found; j++){
        for(var k=0; k!==Nsides && !found; k++){
            if(j%3 !== k%3){
                // Get edge tangent
                sides[k].cross(sides[j],edgeTangent);
                edgeTangent.normalize();
                sides[j].vadd(sides[k], edgeCenter);
                r.copy(xi);
                r.vsub(edgeCenter,r);
                r.vsub(xj,r);
                var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction
                edgeTangent.mult(orthonorm,orthogonal); // Vector from edge center to sphere center in the tangent direction

                // Find the third side orthogonal to this one
                var l = 0;
                while(l===j%3 || l===k%3){
                    l++;
                }

                // vec from edge center to sphere projected to the plane orthogonal to the edge tangent
                dist.copy(xi);
                dist.vsub(orthogonal,dist);
                dist.vsub(edgeCenter,dist);
                dist.vsub(xj,dist);

                // Distances in tangent direction and distance in the plane orthogonal to it
                var tdist = Math.abs(orthonorm);
                var ndist = dist.norm();

                if(tdist < sides[l].norm() && ndist<R){
                    found = true;
                    var res = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
                    edgeCenter.vadd(orthogonal,res.rj); // box rj
                    res.rj.copy(res.rj);
                    dist.negate(res.ni);
                    res.ni.normalize();

                    res.ri.copy(res.rj);
                    res.ri.vadd(xj,res.ri);
                    res.ri.vsub(xi,res.ri);
                    res.ri.normalize();
                    res.ri.mult(R,res.ri);

                    // Make relative to bodies
                    res.ri.vadd(xi, res.ri);
                    res.ri.vsub(bi.position, res.ri);
                    res.rj.vadd(xj, res.rj);
                    res.rj.vsub(bj.position, res.rj);

                    this.result.push(res);
                    this.createFrictionEquationsFromContact(res, this.frictionResult);
                }
            }
        }
    }
    v3pool.release(edgeTangent,edgeCenter,r,orthogonal,dist);
};

var convex_to_sphere = new Vec3();
var sphereConvex_edge = new Vec3();
var sphereConvex_edgeUnit = new Vec3();
var sphereConvex_sphereToCorner = new Vec3();
var sphereConvex_worldCorner = new Vec3();
var sphereConvex_worldNormal = new Vec3();
var sphereConvex_worldPoint = new Vec3();
var sphereConvex_worldSpherePointClosestToPlane = new Vec3();
var sphereConvex_penetrationVec = new Vec3();
var sphereConvex_sphereToWorldPoint = new Vec3();

/**
 * @method sphereConvex
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.sphereConvex = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj){
    var v3pool = this.v3pool;
    xi.vsub(xj,convex_to_sphere);
    var normals = sj.faceNormals;
    var faces = sj.faces;
    var verts = sj.vertices;
    var R =     si.radius;
    var penetrating_sides = [];

    // if(convex_to_sphere.norm2() > si.boundingSphereRadius + sj.boundingSphereRadius){
    //     return;
    // }

    // Check corners
    for(var i=0; i!==verts.length; i++){
        var v = verts[i];

        // World position of corner
        var worldCorner = sphereConvex_worldCorner;
        qj.vmult(v,worldCorner);
        xj.vadd(worldCorner,worldCorner);
        var sphere_to_corner = sphereConvex_sphereToCorner;
        worldCorner.vsub(xi, sphere_to_corner);
        if(sphere_to_corner.norm2() < R * R){
            found = true;
            var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
            r.ri.copy(sphere_to_corner);
            r.ri.normalize();
            r.ni.copy(r.ri);
            r.ri.mult(R,r.ri);
            worldCorner.vsub(xj,r.rj);

            // Should be relative to the body.
            r.ri.vadd(xi, r.ri);
            r.ri.vsub(bi.position, r.ri);

            // Should be relative to the body.
            r.rj.vadd(xj, r.rj);
            r.rj.vsub(bj.position, r.rj);

            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
            return;
        }
    }

    // Check side (plane) intersections
    var found = false;
    for(var i=0, nfaces=faces.length; i!==nfaces && found===false; i++){
        var normal = normals[i];
        var face = faces[i];

        // Get world-transformed normal of the face
        var worldNormal = sphereConvex_worldNormal;
        qj.vmult(normal,worldNormal);

        // Get a world vertex from the face
        var worldPoint = sphereConvex_worldPoint;
        qj.vmult(verts[face[0]],worldPoint);
        worldPoint.vadd(xj,worldPoint);

        // Get a point on the sphere, closest to the face normal
        var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
        worldNormal.mult(-R, worldSpherePointClosestToPlane);
        xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane);

        // Vector from a face point to the closest point on the sphere
        var penetrationVec = sphereConvex_penetrationVec;
        worldSpherePointClosestToPlane.vsub(worldPoint,penetrationVec);

        // The penetration. Negative value means overlap.
        var penetration = penetrationVec.dot(worldNormal);

        var worldPointToSphere = sphereConvex_sphereToWorldPoint;
        xi.vsub(worldPoint, worldPointToSphere);

        if(penetration < 0 && worldPointToSphere.dot(worldNormal)>0){
            // Intersects plane. Now check if the sphere is inside the face polygon
            var faceVerts = []; // Face vertices, in world coords
            for(var j=0, Nverts=face.length; j!==Nverts; j++){
                var worldVertex = v3pool.get();
                qj.vmult(verts[face[j]], worldVertex);
                xj.vadd(worldVertex,worldVertex);
                faceVerts.push(worldVertex);
            }

            if(pointInPolygon(faceVerts,worldNormal,xi)){ // Is the sphere center in the face polygon?
                found = true;
                var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);

                worldNormal.mult(-R, r.ri); // Contact offset, from sphere center to contact
                worldNormal.negate(r.ni); // Normal pointing out of sphere

                var penetrationVec2 = v3pool.get();
                worldNormal.mult(-penetration, penetrationVec2);
                var penetrationSpherePoint = v3pool.get();
                worldNormal.mult(-R, penetrationSpherePoint);

                //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);
                xi.vsub(xj,r.rj);
                r.rj.vadd(penetrationSpherePoint,r.rj);
                r.rj.vadd(penetrationVec2 , r.rj);

                // Should be relative to the body.
                r.rj.vadd(xj, r.rj);
                r.rj.vsub(bj.position, r.rj);

                // Should be relative to the body.
                r.ri.vadd(xi, r.ri);
                r.ri.vsub(bi.position, r.ri);

                v3pool.release(penetrationVec2);
                v3pool.release(penetrationSpherePoint);

                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);

                // Release world vertices
                for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
                    v3pool.release(faceVerts[j]);
                }

                return; // We only expect *one* face contact
            } else {
                // Edge?
                for(var j=0; j!==face.length; j++){

                    // Get two world transformed vertices
                    var v1 = v3pool.get();
                    var v2 = v3pool.get();
                    qj.vmult(verts[face[(j+1)%face.length]], v1);
                    qj.vmult(verts[face[(j+2)%face.length]], v2);
                    xj.vadd(v1, v1);
                    xj.vadd(v2, v2);

                    // Construct edge vector
                    var edge = sphereConvex_edge;
                    v2.vsub(v1,edge);

                    // Construct the same vector, but normalized
                    var edgeUnit = sphereConvex_edgeUnit;
                    edge.unit(edgeUnit);

                    // p is xi projected onto the edge
                    var p = v3pool.get();
                    var v1_to_xi = v3pool.get();
                    xi.vsub(v1, v1_to_xi);
                    var dot = v1_to_xi.dot(edgeUnit);
                    edgeUnit.mult(dot, p);
                    p.vadd(v1, p);

                    // Compute a vector from p to the center of the sphere
                    var xi_to_p = v3pool.get();
                    p.vsub(xi, xi_to_p);

                    // Collision if the edge-sphere distance is less than the radius
                    // AND if p is in between v1 and v2
                    if(dot > 0 && dot*dot<edge.norm2() && xi_to_p.norm2() < R*R){ // Collision if the edge-sphere distance is less than the radius
                        // Edge contact!
                        var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
                        p.vsub(xj,r.rj);

                        p.vsub(xi,r.ni);
                        r.ni.normalize();

                        r.ni.mult(R,r.ri);

                        // Should be relative to the body.
                        r.rj.vadd(xj, r.rj);
                        r.rj.vsub(bj.position, r.rj);

                        // Should be relative to the body.
                        r.ri.vadd(xi, r.ri);
                        r.ri.vsub(bi.position, r.ri);

                        this.result.push(r);
                        this.createFrictionEquationsFromContact(r, this.frictionResult);

                        // Release world vertices
                        for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
                            v3pool.release(faceVerts[j]);
                        }

                        v3pool.release(v1);
                        v3pool.release(v2);
                        v3pool.release(p);
                        v3pool.release(xi_to_p);
                        v3pool.release(v1_to_xi);

                        return;
                    }

                    v3pool.release(v1);
                    v3pool.release(v2);
                    v3pool.release(p);
                    v3pool.release(xi_to_p);
                    v3pool.release(v1_to_xi);
                }
            }

            // Release world vertices
            for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
                v3pool.release(faceVerts[j]);
            }
        }
    }
};

var planeBox_normal = new Vec3();
var plane_to_corner = new Vec3();

/**
 * @method planeBox
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] =
Narrowphase.prototype.planeBox = function(si,sj,xi,xj,qi,qj,bi,bj){
    sj.convexPolyhedronRepresentation.material = sj.material;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    sj.convexPolyhedronRepresentation.id = sj.id;
    this.planeConvex(si,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj);
};

var planeConvex_v = new Vec3();
var planeConvex_normal = new Vec3();
var planeConvex_relpos = new Vec3();
var planeConvex_projected = new Vec3();

/**
 * @method planeConvex
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.planeConvex = function(
    planeShape,
    convexShape,
    planePosition,
    convexPosition,
    planeQuat,
    convexQuat,
    planeBody,
    convexBody,
    si,
    sj
){
    // Simply return the points behind the plane.
    var worldVertex = planeConvex_v,
        worldNormal = planeConvex_normal;
    worldNormal.set(0,0,1);
    planeQuat.vmult(worldNormal,worldNormal); // Turn normal according to plane orientation

    var numContacts = 0;
    var relpos = planeConvex_relpos;
    for(var i = 0; i !== convexShape.vertices.length; i++){

        // Get world convex vertex
        worldVertex.copy(convexShape.vertices[i]);
        convexQuat.vmult(worldVertex, worldVertex);
        convexPosition.vadd(worldVertex, worldVertex);
        worldVertex.vsub(planePosition, relpos);

        var dot = worldNormal.dot(relpos);
        if(dot <= 0.0){

            var r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape, si, sj);

            // Get vertex position projected on plane
            var projected = planeConvex_projected;
            worldNormal.mult(worldNormal.dot(relpos),projected);
            worldVertex.vsub(projected, projected);
            projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane

            r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane

            // rj is now just the vector from the convex center to the vertex
            worldVertex.vsub(convexPosition, r.rj);

            // Make it relative to the body
            r.ri.vadd(planePosition, r.ri);
            r.ri.vsub(planeBody.position, r.ri);
            r.rj.vadd(convexPosition, r.rj);
            r.rj.vsub(convexBody.position, r.rj);

            this.result.push(r);
            numContacts++;
            if(!this.enableFrictionReduction){
                this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
        }
    }

    if(this.enableFrictionReduction && numContacts){
        this.createFrictionFromAverage(numContacts);
    }
};

var convexConvex_sepAxis = new Vec3();
var convexConvex_q = new Vec3();

/**
 * @method convexConvex
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.convexConvex = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){
    var sepAxis = convexConvex_sepAxis;

    if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
        return;
    }

    if(si.findSeparatingAxis(sj,xi,qi,xj,qj,sepAxis,faceListA,faceListB)){
        var res = [];
        var q = convexConvex_q;
        si.clipAgainstHull(xi,qi,sj,xj,qj,sepAxis,-100,100,res);
        var numContacts = 0;
        for(var j = 0; j !== res.length; j++){
            var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
                ri = r.ri,
                rj = r.rj;
            sepAxis.negate(r.ni);
            res[j].normal.negate(q);
            q.mult(res[j].depth, q);
            res[j].point.vadd(q, ri);
            rj.copy(res[j].point);

            // Contact points are in world coordinates. Transform back to relative
            ri.vsub(xi,ri);
            rj.vsub(xj,rj);

            // Make relative to bodies
            ri.vadd(xi, ri);
            ri.vsub(bi.position, ri);
            rj.vadd(xj, rj);
            rj.vsub(bj.position, rj);

            this.result.push(r);
            numContacts++;
            if(!this.enableFrictionReduction){
                this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
        }
        if(this.enableFrictionReduction && numContacts){
            this.createFrictionFromAverage(numContacts);
        }
    }
};


/**
 * @method convexTrimesh
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
// Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.TRIMESH] =
// Narrowphase.prototype.convexTrimesh = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){
//     var sepAxis = convexConvex_sepAxis;

//     if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
//         return;
//     }

//     // Construct a temp hull for each triangle
//     var hullB = new ConvexPolyhedron();

//     hullB.faces = [[0,1,2]];
//     var va = new Vec3();
//     var vb = new Vec3();
//     var vc = new Vec3();
//     hullB.vertices = [
//         va,
//         vb,
//         vc
//     ];

//     for (var i = 0; i < sj.indices.length / 3; i++) {

//         var triangleNormal = new Vec3();
//         sj.getNormal(i, triangleNormal);
//         hullB.faceNormals = [triangleNormal];

//         sj.getTriangleVertices(i, va, vb, vc);

//         var d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
//         if(!d){
//             triangleNormal.scale(-1, triangleNormal);
//             d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);

//             if(!d){
//                 continue;
//             }
//         }

//         var res = [];
//         var q = convexConvex_q;
//         si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
//         for(var j = 0; j !== res.length; j++){
//             var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
//                 ri = r.ri,
//                 rj = r.rj;
//             r.ni.copy(triangleNormal);
//             r.ni.negate(r.ni);
//             res[j].normal.negate(q);
//             q.mult(res[j].depth, q);
//             res[j].point.vadd(q, ri);
//             rj.copy(res[j].point);

//             // Contact points are in world coordinates. Transform back to relative
//             ri.vsub(xi,ri);
//             rj.vsub(xj,rj);

//             // Make relative to bodies
//             ri.vadd(xi, ri);
//             ri.vsub(bi.position, ri);
//             rj.vadd(xj, rj);
//             rj.vsub(bj.position, rj);

//             result.push(r);
//         }
//     }
// };

var particlePlane_normal = new Vec3();
var particlePlane_relpos = new Vec3();
var particlePlane_projected = new Vec3();

/**
 * @method particlePlane
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] =
Narrowphase.prototype.planeParticle = function(sj,si,xj,xi,qj,qi,bj,bi,rsi,rsj){
    var normal = particlePlane_normal;
    normal.set(0,0,1);
    bj.quaternion.vmult(normal,normal); // Turn normal according to plane orientation
    var relpos = particlePlane_relpos;
    xi.vsub(bj.position,relpos);
    var dot = normal.dot(relpos);
    if(dot <= 0.0){
        var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
        r.ni.copy(normal); // Contact normal is the plane normal
        r.ni.negate(r.ni);
        r.ri.set(0,0,0); // Center of particle

        // Get particle position projected on plane
        var projected = particlePlane_projected;
        normal.mult(normal.dot(xi),projected);
        xi.vsub(projected,projected);
        //projected.vadd(bj.position,projected);

        // rj is now the projected world position minus plane position
        r.rj.copy(projected);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
};

var particleSphere_normal = new Vec3();

/**
 * @method particleSphere
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] =
Narrowphase.prototype.sphereParticle = function(sj,si,xj,xi,qj,qi,bj,bi,rsi,rsj){
    // The normal is the unit vector from sphere center to particle center
    var normal = particleSphere_normal;
    normal.set(0,0,1);
    xi.vsub(xj,normal);
    var lengthSquared = normal.norm2();

    if(lengthSquared <= sj.radius * sj.radius){
        var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
        normal.normalize();
        r.rj.copy(normal);
        r.rj.mult(sj.radius,r.rj);
        r.ni.copy(normal); // Contact normal
        r.ni.negate(r.ni);
        r.ri.set(0,0,0); // Center of particle
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
};

// WIP
var cqj = new Quaternion();
var convexParticle_local = new Vec3();
var convexParticle_normal = new Vec3();
var convexParticle_penetratedFaceNormal = new Vec3();
var convexParticle_vertexToParticle = new Vec3();
var convexParticle_worldPenetrationVec = new Vec3();

/**
 * @method convexParticle
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.convexParticle = function(sj,si,xj,xi,qj,qi,bj,bi,rsi,rsj){
    var penetratedFaceIndex = -1;
    var penetratedFaceNormal = convexParticle_penetratedFaceNormal;
    var worldPenetrationVec = convexParticle_worldPenetrationVec;
    var minPenetration = null;
    var numDetectedFaces = 0;

    // Convert particle position xi to local coords in the convex
    var local = convexParticle_local;
    local.copy(xi);
    local.vsub(xj,local); // Convert position to relative the convex origin
    qj.conjugate(cqj);
    cqj.vmult(local,local);

    if(sj.pointIsInside(local)){

        if(sj.worldVerticesNeedsUpdate){
            sj.computeWorldVertices(xj,qj);
        }
        if(sj.worldFaceNormalsNeedsUpdate){
            sj.computeWorldFaceNormals(qj);
        }

        // For each world polygon in the polyhedra
        for(var i=0,nfaces=sj.faces.length; i!==nfaces; i++){

            // Construct world face vertices
            var verts = [ sj.worldVertices[ sj.faces[i][0] ] ];
            var normal = sj.worldFaceNormals[i];

            // Check how much the particle penetrates the polygon plane.
            xi.vsub(verts[0],convexParticle_vertexToParticle);
            var penetration = -normal.dot(convexParticle_vertexToParticle);
            if(minPenetration===null || Math.abs(penetration)<Math.abs(minPenetration)){
                minPenetration = penetration;
                penetratedFaceIndex = i;
                penetratedFaceNormal.copy(normal);
                numDetectedFaces++;
            }
        }

        if(penetratedFaceIndex!==-1){
            // Setup contact
            var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj);
            penetratedFaceNormal.mult(minPenetration, worldPenetrationVec);

            // rj is the particle position projected to the face
            worldPenetrationVec.vadd(xi,worldPenetrationVec);
            worldPenetrationVec.vsub(xj,worldPenetrationVec);
            r.rj.copy(worldPenetrationVec);
            //var projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
            //projectedToFace.copy(r.rj);

            //qj.vmult(r.rj,r.rj);
            penetratedFaceNormal.negate( r.ni ); // Contact normal
            r.ri.set(0,0,0); // Center of particle

            var ri = r.ri,
                rj = r.rj;

            // Make relative to bodies
            ri.vadd(xi, ri);
            ri.vsub(bi.position, ri);
            rj.vadd(xj, rj);
            rj.vsub(bj.position, rj);

            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
        } else {
            console.warn("Point found inside convex, but did not find penetrating face!");
        }
    }
};

Narrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] =
Narrowphase.prototype.boxHeightfield = function (si,sj,xi,xj,qi,qj,bi,bj){
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    this.convexHeightfield(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);
};

var convexHeightfield_tmp1 = new Vec3();
var convexHeightfield_tmp2 = new Vec3();
var convexHeightfield_faceList = [0];

/**
 * @method convexHeightfield
 */
Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] =
Narrowphase.prototype.convexHeightfield = function (
    convexShape,
    hfShape,
    convexPos,
    hfPos,
    convexQuat,
    hfQuat,
    convexBody,
    hfBody
){
    var data = hfShape.data,
        w = hfShape.elementSize,
        radius = convexShape.boundingSphereRadius,
        worldPillarOffset = convexHeightfield_tmp2,
        faceList = convexHeightfield_faceList;

    // Get sphere position to heightfield local!
    var localConvexPos = convexHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos);

    // Get the index of the data points to test against
    var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1,
        iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1,
        iMinY = Math.floor((localConvexPos.y - radius) / w) - 1,
        iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1;

    // Bail out if we are out of the terrain
    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length){
        return;
    }

    // Clamp index to edges
    if(iMinX < 0){ iMinX = 0; }
    if(iMaxX < 0){ iMaxX = 0; }
    if(iMinY < 0){ iMinY = 0; }
    if(iMaxY < 0){ iMaxY = 0; }
    if(iMinX >= data.length){ iMinX = data.length - 1; }
    if(iMaxX >= data.length){ iMaxX = data.length - 1; }
    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }
    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }

    var minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    var min = minMax[0];
    var max = minMax[1];

    // Bail out if we're cant touch the bounding height box
    if(localConvexPos.z - radius > max || localConvexPos.z + radius < min){
        return;
    }

    for(var i = iMinX; i < iMaxX; i++){
        for(var j = iMinY; j < iMaxY; j++){

            // Lower triangle
            hfShape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
                this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, faceList, null);
            }

            // Upper triangle
            hfShape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
                this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, faceList, null);
            }
        }
    }
};

var sphereHeightfield_tmp1 = new Vec3();
var sphereHeightfield_tmp2 = new Vec3();

/**
 * @method sphereHeightfield
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] =
Narrowphase.prototype.sphereHeightfield = function (
    sphereShape,
    hfShape,
    spherePos,
    hfPos,
    sphereQuat,
    hfQuat,
    sphereBody,
    hfBody
){
    var data = hfShape.data,
        radius = sphereShape.radius,
        w = hfShape.elementSize,
        worldPillarOffset = sphereHeightfield_tmp2;

    // Get sphere position to heightfield local!
    var localSpherePos = sphereHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos);

    // Get the index of the data points to test against
    var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1,
        iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1,
        iMinY = Math.floor((localSpherePos.y - radius) / w) - 1,
        iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1;

    // Bail out if we are out of the terrain
    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length){
        return;
    }

    // Clamp index to edges
    if(iMinX < 0){ iMinX = 0; }
    if(iMaxX < 0){ iMaxX = 0; }
    if(iMinY < 0){ iMinY = 0; }
    if(iMaxY < 0){ iMaxY = 0; }
    if(iMinX >= data.length){ iMinX = data.length - 1; }
    if(iMaxX >= data.length){ iMaxX = data.length - 1; }
    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }
    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }

    var minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    var min = minMax[0];
    var max = minMax[1];

    // Bail out if we're cant touch the bounding height box
    if(localSpherePos.z - radius > max || localSpherePos.z + radius < min){
        return;
    }

    var result = this.result;
    for(var i = iMinX; i < iMaxX; i++){
        for(var j = iMinY; j < iMaxY; j++){

            var numContactsBefore = result.length;

            // Lower triangle
            hfShape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
                this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);
            }

            // Upper triangle
            hfShape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
                this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);
            }

            var numContacts = result.length - numContactsBefore;

            if(numContacts > 2){
                return;
            }
            /*
            // Skip all but 1
            for (var k = 0; k < numContacts - 1; k++) {
                result.pop();
            }
            */
        }
    }
};

},{"../collision/AABB":6,"../collision/Ray":12,"../equations/ContactEquation":22,"../equations/FrictionEquation":24,"../math/Quaternion":31,"../math/Transform":32,"../math/Vec3":33,"../shapes/ConvexPolyhedron":41,"../shapes/Shape":46,"../solver/Solver":50,"../utils/Vec3Pool":57}],59:[function(require,module,exports){
/* global performance */

module.exports = World;

var Shape = require('../shapes/Shape');
var Vec3 = require('../math/Vec3');
var Quaternion = require('../math/Quaternion');
var GSSolver = require('../solver/GSSolver');
var ContactEquation = require('../equations/ContactEquation');
var FrictionEquation = require('../equations/FrictionEquation');
var Narrowphase = require('./Narrowphase');
var EventTarget = require('../utils/EventTarget');
var ArrayCollisionMatrix = require('../collision/ArrayCollisionMatrix');
var Material = require('../material/Material');
var ContactMaterial = require('../material/ContactMaterial');
var Body = require('../objects/Body');
var TupleDictionary = require('../utils/TupleDictionary');
var RaycastResult = require('../collision/RaycastResult');
var AABB = require('../collision/AABB');
var Ray = require('../collision/Ray');
var NaiveBroadphase = require('../collision/NaiveBroadphase');

/**
 * The physics world
 * @class World
 * @constructor
 * @extends EventTarget
 * @param {object} [options]
 * @param {Vec3} [options.gravity]
 * @param {boolean} [options.allowSleep]
 * @param {Broadphase} [options.broadphase]
 * @param {Solver} [options.solver]
 * @param {boolean} [options.quatNormalizeFast]
 * @param {number} [options.quatNormalizeSkip]
 */
function World(options){
    options = options || {};
    EventTarget.apply(this);

    /**
     * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
     * @property {Number} dt
     */
    this.dt = -1;

    /**
     * Makes bodies go to sleep when they've been inactive
     * @property allowSleep
     * @type {Boolean}
     * @default false
     */
    this.allowSleep = !!options.allowSleep;

    /**
     * All the current contacts (instances of ContactEquation) in the world.
     * @property contacts
     * @type {Array}
     */
    this.contacts = [];
    this.frictionEquations = [];

    /**
     * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
     * @property quatNormalizeSkip
     * @type {Number}
     * @default 0
     */
    this.quatNormalizeSkip = options.quatNormalizeSkip !== undefined ? options.quatNormalizeSkip : 0;

    /**
     * Set to true to use fast quaternion normalization. It is often enough accurate to use. If bodies tend to explode, set to false.
     * @property quatNormalizeFast
     * @type {Boolean}
     * @see Quaternion.normalizeFast
     * @see Quaternion.normalize
     * @default false
     */
    this.quatNormalizeFast = options.quatNormalizeFast !== undefined ? options.quatNormalizeFast : false;

    /**
     * The wall-clock time since simulation start
     * @property time
     * @type {Number}
     */
    this.time = 0.0;

    /**
     * Number of timesteps taken since start
     * @property stepnumber
     * @type {Number}
     */
    this.stepnumber = 0;

    /// Default and last timestep sizes
    this.default_dt = 1/60;

    this.nextId = 0;
    /**
     * @property gravity
     * @type {Vec3}
     */
    this.gravity = new Vec3();
    if(options.gravity){
        this.gravity.copy(options.gravity);
    }

    /**
     * The broadphase algorithm to use. Default is NaiveBroadphase
     * @property broadphase
     * @type {Broadphase}
     */
    this.broadphase = options.broadphase !== undefined ? options.broadphase : new NaiveBroadphase();

    /**
     * @property bodies
     * @type {Array}
     */
    this.bodies = [];

    /**
     * The solver algorithm to use. Default is GSSolver
     * @property solver
     * @type {Solver}
     */
    this.solver = options.solver !== undefined ? options.solver : new GSSolver();

    /**
     * @property constraints
     * @type {Array}
     */
    this.constraints = [];

    /**
     * @property narrowphase
     * @type {Narrowphase}
     */
    this.narrowphase = new Narrowphase(this);

    /**
     * @property {ArrayCollisionMatrix} collisionMatrix
	 * @type {ArrayCollisionMatrix}
	 */
	this.collisionMatrix = new ArrayCollisionMatrix();

    /**
     * CollisionMatrix from the previous step.
     * @property {ArrayCollisionMatrix} collisionMatrixPrevious
	 * @type {ArrayCollisionMatrix}
	 */
	this.collisionMatrixPrevious = new ArrayCollisionMatrix();

    /**
     * All added materials
     * @property materials
     * @type {Array}
     */
    this.materials = [];

    /**
     * @property contactmaterials
     * @type {Array}
     */
    this.contactmaterials = [];

    /**
     * Used to look up a ContactMaterial given two instances of Material.
     * @property {TupleDictionary} contactMaterialTable
     */
    this.contactMaterialTable = new TupleDictionary();

    this.defaultMaterial = new Material("default");

    /**
     * This contact material is used if no suitable contactmaterial is found for a contact.
     * @property defaultContactMaterial
     * @type {ContactMaterial}
     */
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, { friction: 0.3, restitution: 0.0 });

    /**
     * @property doProfiling
     * @type {Boolean}
     */
    this.doProfiling = false;

    /**
     * @property profile
     * @type {Object}
     */
    this.profile = {
        solve:0,
        makeContactConstraints:0,
        broadphase:0,
        integrate:0,
        narrowphase:0,
    };

    /**
     * Time accumulator for interpolation. See http://gafferongames.com/game-physics/fix-your-timestep/
     * @property {Number} accumulator
     */
    this.accumulator = 0;

    /**
     * @property subsystems
     * @type {Array}
     */
    this.subsystems = [];

    /**
     * Dispatched after a body has been added to the world.
     * @event addBody
     * @param {Body} body The body that has been added to the world.
     */
    this.addBodyEvent = {
        type:"addBody",
        body : null,
    };

    /**
     * Dispatched after a body has been removed from the world.
     * @event removeBody
     * @param {Body} body The body that has been removed from the world.
     */
    this.removeBodyEvent = {
        type:"removeBody",
        body : null,
    };

    this.broadphase.setWorld(this);
}
World.prototype = new EventTarget();

// Temp stuff
var tmpAABB1 = new AABB();
var tmpArray1 = [];
var tmpRay = new Ray();

/**
 * Get the contact material between materials m1 and m2
 * @method getContactMaterial
 * @param {Material} m1
 * @param {Material} m2
 * @return {ContactMaterial} The contact material if it was found.
 */
World.prototype.getContactMaterial = function(m1,m2){
    return this.contactMaterialTable.get(m1.id,m2.id); //this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];
};

/**
 * Get number of objects in the world.
 * @method numObjects
 * @return {Number}
 * @deprecated
 */
World.prototype.numObjects = function(){
    return this.bodies.length;
};

/**
 * Store old collision state info
 * @method collisionMatrixTick
 */
World.prototype.collisionMatrixTick = function(){
	var temp = this.collisionMatrixPrevious;
	this.collisionMatrixPrevious = this.collisionMatrix;
	this.collisionMatrix = temp;
	this.collisionMatrix.reset();
};

/**
 * Add a rigid body to the simulation.
 * @method add
 * @param {Body} body
 * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
 * @todo Adding an array of bodies should be possible. This would save some loops too
 * @deprecated Use .addBody instead
 */
World.prototype.add = World.prototype.addBody = function(body){
    if(this.bodies.indexOf(body) !== -1){
        return;
    }
    body.index = this.bodies.length;
    this.bodies.push(body);
    body.world = this;
    body.initPosition.copy(body.position);
    body.initVelocity.copy(body.velocity);
    body.timeLastSleepy = this.time;
    if(body instanceof Body){
        body.initAngularVelocity.copy(body.angularVelocity);
        body.initQuaternion.copy(body.quaternion);
    }
	this.collisionMatrix.setNumObjects(this.bodies.length);
    this.addBodyEvent.body = body;
    this.dispatchEvent(this.addBodyEvent);
};

/**
 * Add a constraint to the simulation.
 * @method addConstraint
 * @param {Constraint} c
 */
World.prototype.addConstraint = function(c){
    this.constraints.push(c);
};

/**
 * Removes a constraint
 * @method removeConstraint
 * @param {Constraint} c
 */
World.prototype.removeConstraint = function(c){
    var idx = this.constraints.indexOf(c);
    if(idx!==-1){
        this.constraints.splice(idx,1);
    }
};

/**
 * Raycast test
 * @method rayTest
 * @param {Vec3} from
 * @param {Vec3} to
 * @param {RaycastResult} result
 * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
 */
World.prototype.rayTest = function(from, to, result){
    if(result instanceof RaycastResult){
        // Do raycastclosest
        this.raycastClosest(from, to, {
            skipBackfaces: true
        }, result);
    } else {
        // Do raycastAll
        this.raycastAll(from, to, {
            skipBackfaces: true
        }, result);
    }
};

/**
 * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
 * @method raycastAll
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionFilterMask=-1]
 * @param  {number} [options.collisionFilterGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {Function} callback
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAll = function(from, to, options, callback){
    options.mode = Ray.ALL;
    options.from = from;
    options.to = to;
    options.callback = callback;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
 * @method raycastAny
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionFilterMask=-1]
 * @param  {number} [options.collisionFilterGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAny = function(from, to, options, result){
    options.mode = Ray.ANY;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and return information of the closest hit.
 * @method raycastClosest
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionFilterMask=-1]
 * @param  {number} [options.collisionFilterGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastClosest = function(from, to, options, result){
    options.mode = Ray.CLOSEST;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Remove a rigid body from the simulation.
 * @method remove
 * @param {Body} body
 * @deprecated Use .removeBody instead
 */
World.prototype.remove = function(body){
    body.world = null;
    var n = this.bodies.length - 1,
        bodies = this.bodies,
        idx = bodies.indexOf(body);
    if(idx !== -1){
        bodies.splice(idx, 1); // Todo: should use a garbage free method

        // Recompute index
        for(var i=0; i!==bodies.length; i++){
            bodies[i].index = i;
        }

        this.collisionMatrix.setNumObjects(n);
        this.removeBodyEvent.body = body;
        this.dispatchEvent(this.removeBodyEvent);
    }
};

/**
 * Remove a rigid body from the simulation.
 * @method removeBody
 * @param {Body} body
 */
World.prototype.removeBody = World.prototype.remove;

/**
 * Adds a material to the World.
 * @method addMaterial
 * @param {Material} m
 * @todo Necessary?
 */
World.prototype.addMaterial = function(m){
    this.materials.push(m);
};

/**
 * Adds a contact material to the World
 * @method addContactMaterial
 * @param {ContactMaterial} cmat
 */
World.prototype.addContactMaterial = function(cmat) {

    // Add contact material
    this.contactmaterials.push(cmat);

    // Add current contact material to the material table
    this.contactMaterialTable.set(cmat.materials[0].id,cmat.materials[1].id,cmat);
};

// performance.now()
if(typeof performance === 'undefined'){
    performance = {};
}
if(!performance.now){
    var nowOffset = Date.now();
    if (performance.timing && performance.timing.navigationStart){
        nowOffset = performance.timing.navigationStart;
    }
    performance.now = function(){
        return Date.now() - nowOffset;
    };
}

var step_tmp1 = new Vec3();

/**
 * Step the physics world forward in time.
 *
 * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
 *
 * @method step
 * @param {Number} dt                       The fixed time step size to use.
 * @param {Number} [timeSinceLastCalled]    The time elapsed since the function was last called.
 * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
 *
 * @example
 *     // fixed timestepping without interpolation
 *     world.step(1/60);
 *
 * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
 */
World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps){
    maxSubSteps = maxSubSteps || 10;
    timeSinceLastCalled = timeSinceLastCalled || 0;

    if(timeSinceLastCalled === 0){ // Fixed, simple stepping

        this.internalStep(dt);

        // Increment time
        this.time += dt;

    } else {

        this.accumulator += timeSinceLastCalled;
        var substeps = 0;
        while (this.accumulator >= dt && substeps < maxSubSteps) {
            // Do fixed steps to catch up
            this.internalStep(dt);
            this.accumulator -= dt;
            substeps++;
        }

        var t = (this.accumulator % dt) / dt;
        for(var j=0; j !== this.bodies.length; j++){
            var b = this.bodies[j];
            b.previousPosition.lerp(b.position, t, b.interpolatedPosition);
            b.previousQuaternion.slerp(b.quaternion, t, b.interpolatedQuaternion);
            b.previousQuaternion.normalize();
        }
        this.time += timeSinceLastCalled;
    }
};

var
    /**
     * Dispatched after the world has stepped forward in time.
     * @event postStep
     */
    World_step_postStepEvent = {type:"postStep"}, // Reusable event objects to save memory
    /**
     * Dispatched before the world steps forward in time.
     * @event preStep
     */
    World_step_preStepEvent = {type:"preStep"},
    World_step_collideEvent = {type:Body.COLLIDE_EVENT_NAME, body:null, contact:null },
    World_step_oldContacts = [], // Pools for unused objects
    World_step_frictionEquationPool = [],
    World_step_p1 = [], // Reusable arrays for collision pairs
    World_step_p2 = [],
    World_step_gvec = new Vec3(), // Temporary vectors and quats
    World_step_vi = new Vec3(),
    World_step_vj = new Vec3(),
    World_step_wi = new Vec3(),
    World_step_wj = new Vec3(),
    World_step_t1 = new Vec3(),
    World_step_t2 = new Vec3(),
    World_step_rixn = new Vec3(),
    World_step_rjxn = new Vec3(),
    World_step_step_q = new Quaternion(),
    World_step_step_w = new Quaternion(),
    World_step_step_wq = new Quaternion(),
    invI_tau_dt = new Vec3();
World.prototype.internalStep = function(dt){
    this.dt = dt;

    var world = this,
        that = this,
        contacts = this.contacts,
        p1 = World_step_p1,
        p2 = World_step_p2,
        N = this.numObjects(),
        bodies = this.bodies,
        solver = this.solver,
        gravity = this.gravity,
        doProfiling = this.doProfiling,
        profile = this.profile,
        DYNAMIC = Body.DYNAMIC,
        profilingStart,
        constraints = this.constraints,
        frictionEquationPool = World_step_frictionEquationPool,
        gnorm = gravity.norm(),
        gx = gravity.x,
        gy = gravity.y,
        gz = gravity.z,
        i=0;

    if(doProfiling){
        profilingStart = performance.now();
    }

    // Add gravity to all objects
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi.type === DYNAMIC){ // Only for dynamic bodies
            var f = bi.force, m = bi.mass;
            f.x += m*gx;
            f.y += m*gy;
            f.z += m*gz;
        }
    }

    // Update subsystems
    for(var i=0, Nsubsystems=this.subsystems.length; i!==Nsubsystems; i++){
        this.subsystems[i].update();
    }

    // Collision detection
    if(doProfiling){ profilingStart = performance.now(); }
    p1.length = 0; // Clean up pair arrays from last step
    p2.length = 0;
    this.broadphase.collisionPairs(this,p1,p2);
    if(doProfiling){ profile.broadphase = performance.now() - profilingStart; }

    // Remove constrained pairs with collideConnected == false
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        var c = constraints[i];
        if(!c.collideConnected){
            for(var j = p1.length-1; j>=0; j-=1){
                if( (c.bodyA === p1[j] && c.bodyB === p2[j]) ||
                    (c.bodyB === p1[j] && c.bodyA === p2[j])){
                    p1.splice(j, 1);
                    p2.splice(j, 1);
                }
            }
        }
    }

    this.collisionMatrixTick();

    // Generate contacts
    if(doProfiling){ profilingStart = performance.now(); }
    var oldcontacts = World_step_oldContacts;
    var NoldContacts = contacts.length;

    for(i=0; i!==NoldContacts; i++){
        oldcontacts.push(contacts[i]);
    }
    contacts.length = 0;

    // Transfer FrictionEquation from current list to the pool for reuse
    var NoldFrictionEquations = this.frictionEquations.length;
    for(i=0; i!==NoldFrictionEquations; i++){
        frictionEquationPool.push(this.frictionEquations[i]);
    }
    this.frictionEquations.length = 0;

    this.narrowphase.getContacts(
        p1,
        p2,
        this,
        contacts,
        oldcontacts, // To be reused
        this.frictionEquations,
        frictionEquationPool
    );

    if(doProfiling){
        profile.narrowphase = performance.now() - profilingStart;
    }

    // Loop over all collisions
    if(doProfiling){
        profilingStart = performance.now();
    }

    // Add all friction eqs
    for (var i = 0; i < this.frictionEquations.length; i++) {
        solver.addEquation(this.frictionEquations[i]);
    }

    var ncontacts = contacts.length;
    for(var k=0; k!==ncontacts; k++){

        // Current contact
        var c = contacts[k];

        // Get current collision indeces
        var bi = c.bi,
            bj = c.bj,
            si = c.si,
            sj = c.sj;

        // Get collision properties
        var cm;
        if(bi.material && bj.material){
            cm = this.getContactMaterial(bi.material,bj.material) || this.defaultContactMaterial;
        } else {
            cm = this.defaultContactMaterial;
        }

        // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

        var mu = cm.friction;
        // c.restitution = cm.restitution;

        // If friction or restitution were specified in the material, use them
        if(bi.material && bj.material){
            if(bi.material.friction >= 0 && bj.material.friction >= 0){
                mu = bi.material.friction * bj.material.friction;
            }

            if(bi.material.restitution >= 0 && bj.material.restitution >= 0){
                c.restitution = bi.material.restitution * bj.material.restitution;
            }
        }

		// c.setSpookParams(
  //           cm.contactEquationStiffness,
  //           cm.contactEquationRelaxation,
  //           dt
  //       );

		solver.addEquation(c);

		// // Add friction constraint equation
		// if(mu > 0){

		// 	// Create 2 tangent equations
		// 	var mug = mu * gnorm;
		// 	var reducedMass = (bi.invMass + bj.invMass);
		// 	if(reducedMass > 0){
		// 		reducedMass = 1/reducedMass;
		// 	}
		// 	var pool = frictionEquationPool;
		// 	var c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
		// 	var c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
		// 	this.frictionEquations.push(c1, c2);

		// 	c1.bi = c2.bi = bi;
		// 	c1.bj = c2.bj = bj;
		// 	c1.minForce = c2.minForce = -mug*reducedMass;
		// 	c1.maxForce = c2.maxForce = mug*reducedMass;

		// 	// Copy over the relative vectors
		// 	c1.ri.copy(c.ri);
		// 	c1.rj.copy(c.rj);
		// 	c2.ri.copy(c.ri);
		// 	c2.rj.copy(c.rj);

		// 	// Construct tangents
		// 	c.ni.tangents(c1.t, c2.t);

  //           // Set spook params
  //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
  //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);

  //           c1.enabled = c2.enabled = c.enabled;

		// 	// Add equations to solver
		// 	solver.addEquation(c1);
		// 	solver.addEquation(c2);
		// }

        if( bi.allowSleep &&
            bi.type === Body.DYNAMIC &&
            bi.sleepState  === Body.SLEEPING &&
            bj.sleepState  === Body.AWAKE &&
            bj.type !== Body.STATIC
        ){
            var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();
            var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);
            if(speedSquaredB >= speedLimitSquaredB*2){
                bi._wakeUpAfterNarrowphase = true;
            }
        }

        if( bj.allowSleep &&
            bj.type === Body.DYNAMIC &&
            bj.sleepState  === Body.SLEEPING &&
            bi.sleepState  === Body.AWAKE &&
            bi.type !== Body.STATIC
        ){
            var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();
            var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);
            if(speedSquaredA >= speedLimitSquaredA*2){
                bj._wakeUpAfterNarrowphase = true;
            }
        }

        // Now we know that i and j are in contact. Set collision matrix state
		this.collisionMatrix.set(bi, bj, true);

        if (!this.collisionMatrixPrevious.get(bi, bj)) {
            // First contact!
            // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
            World_step_collideEvent.body = bj;
            World_step_collideEvent.contact = c;
            bi.dispatchEvent(World_step_collideEvent);

            World_step_collideEvent.body = bi;
            bj.dispatchEvent(World_step_collideEvent);
        }
    }
    if(doProfiling){
        profile.makeContactConstraints = performance.now() - profilingStart;
        profilingStart = performance.now();
    }

    // Wake up bodies
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi._wakeUpAfterNarrowphase){
            bi.wakeUp();
            bi._wakeUpAfterNarrowphase = false;
        }
    }

    // Add user-added constraints
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        var c = constraints[i];
        c.update();
        for(var j=0, Neq=c.equations.length; j!==Neq; j++){
            var eq = c.equations[j];
            solver.addEquation(eq);
        }
    }

    // Solve the constrained system
    solver.solve(dt,this);

    if(doProfiling){
        profile.solve = performance.now() - profilingStart;
    }

    // Remove all contacts from solver
    solver.removeAllEquations();

    // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details
    var pow = Math.pow;
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi.type & DYNAMIC){ // Only for dynamic bodies
            var ld = pow(1.0 - bi.linearDamping,dt);
            var v = bi.velocity;
            v.mult(ld,v);
            var av = bi.angularVelocity;
            if(av){
                var ad = pow(1.0 - bi.angularDamping,dt);
                av.mult(ad,av);
            }
        }
    }

    this.dispatchEvent(World_step_preStepEvent);

    // Invoke pre-step callbacks
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi.preStep){
            bi.preStep.call(bi);
        }
    }

    // Leap frog
    // vnew = v + h*f/m
    // xnew = x + h*vnew
    if(doProfiling){
        profilingStart = performance.now();
    }
    var stepnumber = this.stepnumber;
    var quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) === 0;
    var quatNormalizeFast = this.quatNormalizeFast;

    for(i=0; i!==N; i++){
        bodies[i].integrate(dt, quatNormalize, quatNormalizeFast);
    }
    this.clearForces();

    this.broadphase.dirty = true;

    if(doProfiling){
        profile.integrate = performance.now() - profilingStart;
    }

    // Update world time
    this.time += dt;
    this.stepnumber += 1;

    this.dispatchEvent(World_step_postStepEvent);

    // Invoke post-step callbacks
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        var postStep = bi.postStep;
        if(postStep){
            postStep.call(bi);
        }
    }

    // Sleeping update
    if(this.allowSleep){
        for(i=0; i!==N; i++){
            bodies[i].sleepTick(this.time);
        }
    }
};

/**
 * Sets all body forces in the world to zero.
 * @method clearForces
 */
World.prototype.clearForces = function(){
    var bodies = this.bodies;
    var N = bodies.length;
    for(var i=0; i !== N; i++){
        var b = bodies[i],
            force = b.force,
            tau = b.torque;

        b.force.set(0,0,0);
        b.torque.set(0,0,0);
    }
};

},{"../collision/AABB":6,"../collision/ArrayCollisionMatrix":7,"../collision/NaiveBroadphase":10,"../collision/Ray":12,"../collision/RaycastResult":13,"../equations/ContactEquation":22,"../equations/FrictionEquation":24,"../material/ContactMaterial":27,"../material/Material":28,"../math/Quaternion":31,"../math/Vec3":33,"../objects/Body":34,"../shapes/Shape":46,"../solver/GSSolver":49,"../utils/EventTarget":52,"../utils/TupleDictionary":55,"./Narrowphase":58}]},{},[3])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvaG9tZS9hZGEvZ2l0V29ya2luZ0Rpci9jYXJkYm9hcmQyL2FwcC9zY3JpcHRzL2xpYi9mZXRjaEpTT04uanMiLCIvaG9tZS9hZGEvZ2l0V29ya2luZ0Rpci9jYXJkYm9hcmQyL2FwcC9zY3JpcHRzL2xpYi9maXhHZW9tZXRyeS5qcyIsIi9ob21lL2FkYS9naXRXb3JraW5nRGlyL2NhcmRib2FyZDIvYXBwL3NjcmlwdHMvcGh5c2ljcy5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvQ2Fubm9uLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvY29sbGlzaW9uL0FBQkIuanMiLCJub2RlX21vZHVsZXMvY2Fubm9uL3NyYy9jb2xsaXNpb24vQXJyYXlDb2xsaXNpb25NYXRyaXguanMiLCJub2RlX21vZHVsZXMvY2Fubm9uL3NyYy9jb2xsaXNpb24vQnJvYWRwaGFzZS5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL2NvbGxpc2lvbi9HcmlkQnJvYWRwaGFzZS5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2UuanMiLCJub2RlX21vZHVsZXMvY2Fubm9uL3NyYy9jb2xsaXNpb24vT2JqZWN0Q29sbGlzaW9uTWF0cml4LmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvY29sbGlzaW9uL1JheS5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0LmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvY29sbGlzaW9uL1NBUEJyb2FkcGhhc2UuanMiLCJub2RlX21vZHVsZXMvY2Fubm9uL3NyYy9jb25zdHJhaW50cy9Db25lVHdpc3RDb25zdHJhaW50LmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvY29uc3RyYWludHMvQ29uc3RyYWludC5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL2NvbnN0cmFpbnRzL0Rpc3RhbmNlQ29uc3RyYWludC5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL2NvbnN0cmFpbnRzL0hpbmdlQ29uc3RyYWludC5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50LmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvY29uc3RyYWludHMvUG9pbnRUb1BvaW50Q29uc3RyYWludC5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL2VxdWF0aW9ucy9Db25lRXF1YXRpb24uanMiLCJub2RlX21vZHVsZXMvY2Fubm9uL3NyYy9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvZXF1YXRpb25zL0VxdWF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24uanMiLCJub2RlX21vZHVsZXMvY2Fubm9uL3NyYy9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvZXF1YXRpb25zL1JvdGF0aW9uYWxNb3RvckVxdWF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvbWF0ZXJpYWwvTWF0ZXJpYWwuanMiLCJub2RlX21vZHVsZXMvY2Fubm9uL3NyYy9tYXRoL0phY29iaWFuRWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL21hdGgvTWF0My5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL21hdGgvUXVhdGVybmlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL21hdGgvVHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvbWF0aC9WZWMzLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvb2JqZWN0cy9Cb2R5LmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvb2JqZWN0cy9SYXljYXN0VmVoaWNsZS5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL29iamVjdHMvUmlnaWRWZWhpY2xlLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvb2JqZWN0cy9TUEhTeXN0ZW0uanMiLCJub2RlX21vZHVsZXMvY2Fubm9uL3NyYy9vYmplY3RzL1NwcmluZy5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL29iamVjdHMvV2hlZWxJbmZvLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvc2hhcGVzL0JveC5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL3NoYXBlcy9Db252ZXhQb2x5aGVkcm9uLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvc2hhcGVzL0N5bGluZGVyLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvc2hhcGVzL0hlaWdodGZpZWxkLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvc2hhcGVzL1BhcnRpY2xlLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvc2hhcGVzL1BsYW5lLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvc2hhcGVzL1NoYXBlLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvc2hhcGVzL1NwaGVyZS5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL3NoYXBlcy9UcmltZXNoLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvc29sdmVyL0dTU29sdmVyLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvc29sdmVyL1NvbHZlci5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL3NvbHZlci9TcGxpdFNvbHZlci5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL3V0aWxzL0V2ZW50VGFyZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvdXRpbHMvT2N0cmVlLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvdXRpbHMvUG9vbC5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL3V0aWxzL1R1cGxlRGljdGlvbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL3V0aWxzL1V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm5vbi9zcmMvdXRpbHMvVmVjM1Bvb2wuanMiLCJub2RlX21vZHVsZXMvY2Fubm9uL3NyYy93b3JsZC9OYXJyb3dwaGFzZS5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ub24vc3JjL3dvcmxkL1dvcmxkLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQ0NBLFlBQVksQ0FBQzs7QUFFYixTQUFTLFNBQVMsQ0FBQyxHQUFHLEVBQUUsT0FBTyxFQUFFO0FBQ2hDLFFBQU8sS0FBSyxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FDeEIsSUFBSSxDQUFDLFVBQVUsUUFBUSxFQUFFO0FBQUUsU0FBTyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7RUFBRSxDQUFDLENBQ3JELElBQUksQ0FBQyxVQUFVLE1BQU0sRUFBRTtBQUFFLFNBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztFQUFFLENBQUMsQ0FBQztDQUN6RDs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQzs7OztBQ1IzQixZQUFZLENBQUM7O0FBRWIsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEdBQUcsVUFBVSxPQUFPLEVBQUU7QUFDekMsS0FBTSxNQUFNLEdBQUcsSUFBSSxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUM7QUFDeEMsS0FBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNwQyxRQUFPLEtBQUssQ0FBQztDQUNiLENBQUM7OztBQUdGLE1BQU0sQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsVUFBVSxLQUFLLEVBQUU7QUFDbEQsS0FBTSxLQUFLLEdBQUcsRUFBRSxDQUFDO0FBQ2pCLE1BQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFVBQUEsSUFBSSxFQUFJO0FBQzlCLE1BQUksSUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLEVBQUUsT0FBTztBQUNqQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQ3ZDLE1BQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztBQUNwQixNQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztBQUN6QixNQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUNuQyxNQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN0QyxNQUFNLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDekIsUUFBTSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ25DLFVBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQztVQUFJLENBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztHQUFBLENBQUMsQ0FBQztBQUM3RCxPQUFLLENBQUMsSUFBSSxDQUFDLEVBQUMsUUFBUSxFQUFSLFFBQVEsRUFBRSxNQUFNLEVBQU4sTUFBTSxFQUFDLENBQUMsQ0FBQztFQUMvQixDQUFDLENBQUM7QUFDSCxRQUFPLEtBQUssQ0FBQztDQUNiLENBQUM7Ozs7O0FDdkJGLFlBQVksQ0FBQzs7QUFFYixhQUFhLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUNoQyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDakMsSUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFDaEQsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDLENBQUM7O0FBRWpELElBQU0sS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQ2pDLElBQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQzs7QUFFekIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzdCLEtBQUssQ0FBQyxVQUFVLEdBQUcsSUFBSSxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUM7QUFDaEQsS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDOztBQUU1QixJQUFJLElBQUksR0FBRyxDQUFDLENBQUM7QUFDYixTQUFTLE9BQU8sR0FBRzs7QUFFbEIsS0FBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ3JCLEtBQU0sRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQSxHQUFJLElBQUksQ0FBQzs7QUFFN0IsTUFBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNmLEtBQUksR0FBRyxDQUFDLENBQUM7Q0FDVDs7O0FBR0QsU0FBUyxNQUFNLENBQUMsQ0FBQyxFQUFFO0FBQ2xCLFFBQU87QUFDTixHQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDTixHQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDTixHQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7RUFDTixDQUFDO0NBQ0Y7O0FBRUQsU0FBUyxTQUFTLENBQUMsSUFBVSxFQUFFO0tBQVgsRUFBRSxHQUFILElBQVUsQ0FBVCxFQUFFO0tBQUUsSUFBSSxHQUFULElBQVUsQ0FBTCxJQUFJOztBQUUzQixLQUFJLENBQUMsSUFBSSxFQUFFLElBQUksR0FBRyxDQUFDLENBQUM7QUFDcEIsUUFBTyxTQUFTLENBQUMsWUFBWSxHQUFHLEVBQUUsR0FBRyxPQUFPLENBQUMsQ0FDNUMsSUFBSSxDQUFDLFVBQUEsS0FBSyxFQUFJOztBQUVkLE1BQU0sU0FBUyxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksRUFBSixJQUFJLEVBQUUsQ0FBQyxDQUFDOztBQUU1QyxNQUFNLFFBQVEsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDOztBQUUxQyxhQUFXLENBQ1YsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQzFCLE9BQU8sQ0FBQyxVQUFDLEtBQWtCLEVBQUs7T0FBdEIsUUFBUSxHQUFULEtBQWtCLENBQWpCLFFBQVE7T0FBRSxNQUFNLEdBQWpCLEtBQWtCLENBQVAsTUFBTTs7O0FBRzFCLE9BQU0sU0FBUyxHQUFHLElBQUksTUFBTSxDQUFDLGdCQUFnQixDQUM1QyxRQUFRLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUM7V0FBSSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQ3pDLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUNmLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUNmLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUNmO0lBQUEsQ0FBQyxFQUNGLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQUEsQ0FBQztXQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFBQSxDQUFDLENBQ3hDLENBQUM7O0FBRUYsWUFBUyxDQUFDLGtCQUFrQixDQUFDLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7OztBQUcvRSxZQUFTLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0dBQzlCLENBQUMsQ0FBQzs7OztBQUlILFNBQU8sU0FBUyxDQUFDO0VBQ2pCLENBQUMsQ0FBQztDQUNIOzs7QUFHRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLFVBQVMsS0FBSyxFQUFFO0FBQy9DLFFBQU8sQ0FBQyxPQUFPLEVBQUUsQ0FDaEIsSUFBSSxDQUFDLFlBQVk7O0FBRWpCLFVBQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNO0FBQ3ZCLFFBQUssTUFBTTs7QUFFVixTQUFLLENBQUMsc0JBQXNCLENBQUMsd0JBQXdCLEdBQUcsR0FBRyxDQUFDO0FBQzVELFNBQUssQ0FBQyxzQkFBc0IsQ0FBQyx5QkFBeUIsR0FBRyxDQUFDLENBQUM7QUFDM0QsV0FBTzs7QUFBQSxBQUVSLFFBQUssY0FBYztBQUNsQixXQUFPLEVBQUUsQ0FBQztBQUNWLFNBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLGFBQWEsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDO1lBQUs7OztBQUc5QyxjQUFRLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7QUFDNUIsZ0JBQVUsRUFBRSxDQUFDLENBQUMsVUFBVTtBQUN4QixVQUFJLEVBQUUsQ0FBQyxDQUFDLElBQUk7QUFDWixRQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUU7TUFDUjtLQUFDLENBQUMsQ0FBQztBQUNKLFdBQU87O0FBQUEsQUFFUixRQUFLLFdBQVc7QUFDZixXQUFPLFNBQVMsQ0FBQztBQUNoQixPQUFFLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRTtBQUN6QixTQUFJLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUM7S0FDbEMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFBLEtBQUssRUFBSTtBQUNoQixTQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDOUMsVUFBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQyxVQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxLQUFLLENBQUMsRUFBRSxDQUFDO0FBQ3pCLGtCQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzFCLFVBQUssQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztBQUMzQyxVQUFLLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxlQUFlLENBQUM7QUFDbEMsVUFBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNyQixVQUFLLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLFlBQVc7O01BRTVDLENBQUMsQ0FBQztLQUNILENBQUMsQ0FBQzs7QUFBQSxBQUVKLFFBQUssVUFBVTtBQUNkLFFBQU0sS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQztBQUM3QixTQUFJLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSTtBQUNsQyxhQUFRLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQztBQUNsRCxhQUFRLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQztLQUNsRCxDQUFDLENBQUM7QUFDSCxTQUFLLENBQUMsUUFBUSxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ2xFLFNBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDckIsaUJBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDMUIsU0FBSyxDQUFDLElBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDO0FBQ2hELFNBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztBQUMxQixTQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUM7O0FBRW5ELFNBQUssQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO0FBQzNCLFdBQU87O0FBQUEsQUFFUjtBQUNDLFVBQU0sS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFBQSxHQUMvQjtFQUNELENBQUMsQ0FDRCxJQUFJLENBQUMsWUFBWTtBQUNqQixPQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7RUFDMUIsRUFBRSxVQUFVLEdBQUcsRUFBRTtBQUNqQixTQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ25CLE9BQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztBQUMzQixNQUFJLEdBQUcsRUFBRTtBQUNSLFFBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLEdBQUcsQ0FBQyxPQUFPLEdBQUcsR0FBRyxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7R0FDckQ7RUFDRCxDQUFDLENBQ0QsSUFBSSxDQUFDLFlBQVk7QUFDakIsT0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0VBQ3ZDLENBQUMsQ0FBQztDQUNKLENBQUMsQ0FBQzs7O0FDaEpIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3h6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3g0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOTVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnREQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKmdsb2JhbCBmZXRjaCovXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGZldGNoSlNPTih1cmwsIG9wdGlvbnMpIHtcblx0cmV0dXJuIGZldGNoKHVybCwgb3B0aW9ucylcblx0XHQudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTsgfSlcblx0XHQudGhlbihmdW5jdGlvbiAoc3RyaW5nKSB7IHJldHVybiBKU09OLnBhcnNlKHN0cmluZyk7IH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZldGNoSlNPTjtcbiIsIi8qZ2xvYmFsIFRIUkVFKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc2NlbmVJbikge1xuXHRjb25zdCBsb2FkZXIgPSBuZXcgVEhSRUUuT2JqZWN0TG9hZGVyKCk7XG5cdGNvbnN0IHNjZW5lID0gbG9hZGVyLnBhcnNlKHNjZW5lSW4pO1xuXHRyZXR1cm4gc2NlbmU7XG59O1xuXG4vLyB1c2VkIGZvciBwb3B1bGF0aW5nIGNhbm5vblxubW9kdWxlLmV4cG9ydHMuZ2V0R2VvbUZyb21TY2VuZSA9IGZ1bmN0aW9uIChzY2VuZSkge1xuXHRjb25zdCBnZW9tcyA9IFtdO1xuXHRzY2VuZS5jaGlsZHJlbi5mb3JFYWNoKG1lc2ggPT4ge1xuXHRcdGlmIChtZXNoLnR5cGUgIT09ICdNZXNoJykgcmV0dXJuO1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeS5jbG9uZSgpO1xuXHRcdG1lc2gudXBkYXRlTWF0cml4KCk7XG5cdFx0bWVzaC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXHRcdGNvbnN0IHBvc01hdCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdFx0bWVzaC5tYXRyaXhXb3JsZC5jb3B5UG9zaXRpb24ocG9zTWF0KTtcblx0XHRjb25zdCBjZW50ZXIgPSBbMCwgMCwgMF07XG5cdFx0cG9zTWF0LmFwcGx5VG9WZWN0b3IzQXJyYXkoY2VudGVyKTtcblx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5tYXAodiA9PiB2LmFwcGx5TWF0cml4NChtZXNoLm1hdHJpeFdvcmxkKSk7XG5cdFx0Z2VvbXMucHVzaCh7Z2VvbWV0cnksIGNlbnRlcn0pO1xuXHR9KTtcblx0cmV0dXJuIGdlb21zO1xufTtcbiIsIi8qanNoaW50IHdvcmtlcjp0cnVlKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnRTY3JpcHRzKCcuL3RocmVlLm1pbi5qcycpOyAvLyBsb2FkZWQgZnJvbSB2ZW5kb3IgZGlyXG5jb25zdCBDYW5ub24gPSByZXF1aXJlKCdjYW5ub24nKTtcbmNvbnN0IGZldGNoSlNPTiA9IHJlcXVpcmUoJy4vbGliL2ZldGNoSlNPTi5qcycpO1xuY29uc3QgZml4R2VvbWV0cnkgPSByZXF1aXJlKCcuL2xpYi9maXhHZW9tZXRyeScpO1xuXG5jb25zdCB3b3JsZCA9IG5ldyBDYW5ub24uV29ybGQoKTtcbmNvbnN0IGN1c3RvbU9iamVjdHMgPSBbXTtcblxud29ybGQuZ3Jhdml0eS5zZXQoMCwgLTEwLCAwKTtcbndvcmxkLmJyb2FkcGhhc2UgPSBuZXcgQ2Fubm9uLk5haXZlQnJvYWRwaGFzZSgpO1xud29ybGQuc29sdmVyLml0ZXJhdGlvbnMgPSA4O1xuXG5sZXQgb2xkVCA9IDA7XG5mdW5jdGlvbiBhbmltYXRlKCkge1xuXG5cdGNvbnN0IHQgPSBEYXRlLm5vdygpO1xuXHRjb25zdCBkVCA9ICh0IC0gb2xkVCkgLyAxMDAwO1xuXG5cdHdvcmxkLnN0ZXAoZFQpO1xuXHRvbGRUID0gdDtcbn1cblxuLy8gc3dhcCB5LHpcbmZ1bmN0aW9uIHN3YXBZWih2KSB7XG5cdHJldHVybiB7XG5cdFx0eDogdi54LFxuXHRcdHk6IHYueSxcblx0XHR6OiB2Lnpcblx0fTtcbn1cblxuZnVuY3Rpb24gZ2V0T2JqZWN0KHtpZCwgbWFzc30pIHtcblxuXHRpZiAoIW1hc3MpIG1hc3MgPSAwO1xuXHRyZXR1cm4gZmV0Y2hKU09OKCcuLi9tb2RlbHMvJyArIGlkICsgJy5qc29uJylcblx0LnRoZW4oc2NlbmUgPT4ge1xuXG5cdFx0Y29uc3QgbW9kZWxCb2R5ID0gbmV3IENhbm5vbi5Cb2R5KHsgbWFzcyB9KTtcblxuXHRcdGNvbnN0IG5ld1NjZW5lID0gZml4R2VvbWV0cnkucGFyc2Uoc2NlbmUpO1xuXG5cdFx0Zml4R2VvbWV0cnlcblx0XHQuZ2V0R2VvbUZyb21TY2VuZShuZXdTY2VuZSlcblx0XHQuZm9yRWFjaCgoe2dlb21ldHJ5LCBjZW50ZXJ9KSA9PiB7XG5cblx0XHRcdC8vIENvbnN0cnVjdCBwb2x5aGVkcm9uXG5cdFx0XHRjb25zdCBtb2RlbFBhcnQgPSBuZXcgQ2Fubm9uLkNvbnZleFBvbHloZWRyb24oXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLm1hcCh2ID0+IG5ldyBDYW5ub24uVmVjMyhcblx0XHRcdFx0XHR2LnggLSBjZW50ZXJbMF0sXG5cdFx0XHRcdFx0di55IC0gY2VudGVyWzFdLFxuXHRcdFx0XHRcdHYueiAtIGNlbnRlclsyXVxuXHRcdFx0XHQpKSxcblx0XHRcdFx0Z2VvbWV0cnkuZmFjZXMubWFwKGYgPT4gW2YuYSwgZi5iLCBmLmNdKVxuXHRcdFx0KTtcblxuXHRcdFx0bW9kZWxQYXJ0LnRyYW5zZm9ybUFsbFBvaW50cyhuZXcgQ2Fubm9uLlZlYzMoY2VudGVyWzBdLCBjZW50ZXJbMV0sIGNlbnRlclsyXSkpO1xuXG5cdFx0XHQvLyBBZGQgdG8gY29tcG91bmRcblx0XHRcdG1vZGVsQm9keS5hZGRTaGFwZShtb2RlbFBhcnQpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gQ3JlYXRlIGJvZHlcblx0XHQvLyBtb2RlbEJvZHkucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBDYW5ub24uVmVjMygxLCAwLCAwKSwgTWF0aC5QSSAvIDIpO1xuXHRcdHJldHVybiBtb2RlbEJvZHk7XG5cdH0pO1xufVxuXG4vLyBSZWNpZXZlIG1lc3NhZ2VzIGZyb20gdGhlIGNsaWVudCBhbmQgcmVwbHkgYmFjayBvbnRoZSBzYW1lIHBvcnRcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0UHJvbWlzZS5yZXNvbHZlKClcblx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHN3aXRjaChldmVudC5kYXRhLmFjdGlvbikge1xuXHRcdFx0XHRjYXNlICdpbml0JzpcblxuXHRcdFx0XHRcdHdvcmxkLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzID0gNWU3O1xuXHRcdFx0XHRcdHdvcmxkLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwuY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbiA9IDQ7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdGNhc2UgJ2dldE1vZGVsRGF0YSc6XG5cdFx0XHRcdFx0YW5pbWF0ZSgpO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEubW9kZWxEYXRhID0gY3VzdG9tT2JqZWN0cy5tYXAocCA9PiAoe1xuXG5cdFx0XHRcdFx0XHQvLyBzd2FwIHkseiBmb3IgZXhwb3J0aW5nXG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogc3dhcFlaKHAucG9zaXRpb24pLFxuXHRcdFx0XHRcdFx0cXVhdGVybmlvbjogcC5xdWF0ZXJuaW9uLFxuXHRcdFx0XHRcdFx0bWV0YTogcC5tZXRhLFxuXHRcdFx0XHRcdFx0aWQ6IHAuaWRcblx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdGNhc2UgJ2FkZE9iamVjdCc6XG5cdFx0XHRcdFx0cmV0dXJuIGdldE9iamVjdCh7XG5cdFx0XHRcdFx0XHRpZDogZXZlbnQuZGF0YS5vcHRpb25zLmlkLFxuXHRcdFx0XHRcdFx0bWFzczogZXZlbnQuZGF0YS5vcHRpb25zLm1hc3MgfHwgMFxuXHRcdFx0XHRcdH0pLnRoZW4oYm9keTIgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgcCA9IHN3YXBZWihldmVudC5kYXRhLm9wdGlvbnMucG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0Ym9keTIucG9zaXRpb24uc2V0KHAueCwgcC55LCBwLnopO1xuXHRcdFx0XHRcdFx0ZXZlbnQuZGF0YS5pZCA9IGJvZHkyLmlkO1xuXHRcdFx0XHRcdFx0Y3VzdG9tT2JqZWN0cy5wdXNoKGJvZHkyKTtcblx0XHRcdFx0XHRcdGJvZHkyLm1ldGEgPSBldmVudC5kYXRhLm9wdGlvbnMubWV0YSB8fCB7fTtcblx0XHRcdFx0XHRcdGJvZHkyLm1ldGEudHlwZSA9ICdnZW5lcmljT2JqZWN0Jztcblx0XHRcdFx0XHRcdHdvcmxkLmFkZEJvZHkoYm9keTIpO1xuXHRcdFx0XHRcdFx0Ym9keTIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbGxpZGVcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiQ29udGFjdCBiZXR3ZWVuIGJvZGllczpcIixlLmNvbnRhY3QpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Y2FzZSAnYWRkUG9pbnQnOlxuXHRcdFx0XHRcdGNvbnN0IGJvZHkxID0gbmV3IENhbm5vbi5Cb2R5KHtcblx0XHRcdFx0XHRcdG1hc3M6IGV2ZW50LmRhdGEucG9pbnRPcHRpb25zLm1hc3MsXG5cdFx0XHRcdFx0XHR2ZWxvY2l0eTogc3dhcFlaKGV2ZW50LmRhdGEucG9pbnRPcHRpb25zLnZlbG9jaXR5KSxcblx0XHRcdFx0XHRcdHBvc2l0aW9uOiBzd2FwWVooZXZlbnQuZGF0YS5wb2ludE9wdGlvbnMucG9zaXRpb24pXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Ym9keTEuYWRkU2hhcGUobmV3IENhbm5vbi5TcGhlcmUoZXZlbnQuZGF0YS5wb2ludE9wdGlvbnMucmFkaXVzKSk7XG5cdFx0XHRcdFx0d29ybGQuYWRkQm9keShib2R5MSk7XG5cdFx0XHRcdFx0Y3VzdG9tT2JqZWN0cy5wdXNoKGJvZHkxKTtcblx0XHRcdFx0XHRib2R5MS5tZXRhID0gZXZlbnQuZGF0YS5wb2ludE9wdGlvbnMubWV0YSB8fCB7fTtcblx0XHRcdFx0XHRib2R5MS5tZXRhLnR5cGUgPSAncG9pbnQnO1xuXHRcdFx0XHRcdGJvZHkxLm1ldGEucmFkaXVzID0gZXZlbnQuZGF0YS5wb2ludE9wdGlvbnMucmFkaXVzO1xuXG5cdFx0XHRcdFx0Ym9keTEubGluZWFyRGFtcGluZyA9IDAuMDE7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgQWN0aW9uJyk7XG5cdFx0XHR9XG5cdFx0fSlcblx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRldmVudC5kYXRhLnN1Y2Nlc3MgPSB0cnVlO1xuXHRcdH0sIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyKTtcblx0XHRcdGV2ZW50LmRhdGEuc3VjY2VzcyA9IGZhbHNlO1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRldmVudC5kYXRhLm1lc3NhZ2UgPSBlcnIubWVzc2FnZSA/IGVyci5tZXNzYWdlIDogZXJyO1xuXHRcdFx0fVxuXHRcdH0pXG5cdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0ZXZlbnQucG9ydHNbMF0ucG9zdE1lc3NhZ2UoZXZlbnQuZGF0YSk7XG5cdFx0fSk7XG59KTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfYXJnc1wiOiBbXG4gICAgW1xuICAgICAgXCJjYW5ub25AZ2l0aHViOnNjaHRlcHBlL2Nhbm5vbi5qc1wiLFxuICAgICAgXCIvaG9tZS9hZGEvZ2l0V29ya2luZ0Rpci9jYXJkYm9hcmQyXCJcbiAgICBdXG4gIF0sXG4gIFwiX2Zyb21cIjogXCJzY2h0ZXBwZS9jYW5ub24uanNcIixcbiAgXCJfaWRcIjogXCJjYW5ub25AMC42LjJcIixcbiAgXCJfaW5DYWNoZVwiOiB0cnVlLFxuICBcIl9sb2NhdGlvblwiOiBcIi9jYW5ub25cIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwiaG9zdGVkXCI6IHtcbiAgICAgIFwiZGlyZWN0VXJsXCI6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3NjaHRlcHBlL2Nhbm5vbi5qcy9tYXN0ZXIvcGFja2FnZS5qc29uXCIsXG4gICAgICBcImdpdFVybFwiOiBcImdpdDovL2dpdGh1Yi5jb20vc2NodGVwcGUvY2Fubm9uLmpzLmdpdFwiLFxuICAgICAgXCJodHRwc1VybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvY2Fubm9uLmpzLmdpdFwiLFxuICAgICAgXCJzaG9ydGN1dFwiOiBcImdpdGh1YjpzY2h0ZXBwZS9jYW5ub24uanNcIixcbiAgICAgIFwic3NoXCI6IFwiZ2l0QGdpdGh1Yi5jb206c2NodGVwcGUvY2Fubm9uLmpzLmdpdFwiLFxuICAgICAgXCJzc2hVcmxcIjogXCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb20vc2NodGVwcGUvY2Fubm9uLmpzLmdpdFwiLFxuICAgICAgXCJ0eXBlXCI6IFwiZ2l0aHViXCJcbiAgICB9LFxuICAgIFwibmFtZVwiOiBcImNhbm5vblwiLFxuICAgIFwicmF3XCI6IFwiY2Fubm9uQGdpdGh1YjpzY2h0ZXBwZS9jYW5ub24uanNcIixcbiAgICBcInJhd1NwZWNcIjogXCJnaXRodWI6c2NodGVwcGUvY2Fubm9uLmpzXCIsXG4gICAgXCJzY29wZVwiOiBudWxsLFxuICAgIFwic3BlY1wiOiBcImdpdGh1YjpzY2h0ZXBwZS9jYW5ub24uanNcIixcbiAgICBcInR5cGVcIjogXCJob3N0ZWRcIlxuICB9LFxuICBcIl9yZXF1aXJlZEJ5XCI6IFtcbiAgICBcIi9cIlxuICBdLFxuICBcIl9yZXNvbHZlZFwiOiBcImdpdDovL2dpdGh1Yi5jb20vc2NodGVwcGUvY2Fubm9uLmpzLmdpdCM2NzkxMDJhNDg1YzdkZDQzNjZhYmQ3YTJiMGNjYzFjN2FlYjI2YmQxXCIsXG4gIFwiX3NoYXN1bVwiOiBcIjZiNmNiZWQ2NmEzZGEwM2I2NGQyZGI0MGY4NmUxYTZiOGY4YzY3NDdcIixcbiAgXCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuICBcIl9zcGVjXCI6IFwiY2Fubm9uQGdpdGh1YjpzY2h0ZXBwZS9jYW5ub24uanNcIixcbiAgXCJfd2hlcmVcIjogXCIvaG9tZS9hZGEvZ2l0V29ya2luZ0Rpci9jYXJkYm9hcmQyXCIsXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcImVtYWlsXCI6IFwic2NodGVwcGVAZ21haWwuY29tXCIsXG4gICAgXCJuYW1lXCI6IFwiU3RlZmFuIEhlZG1hblwiLFxuICAgIFwidXJsXCI6IFwiaHR0cDovL3N0ZWZmZS5zZVwiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvY2Fubm9uLmpzL2lzc3Vlc1wiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBsaWdodHdlaWdodCAzRCBwaHlzaWNzIGVuZ2luZSB3cml0dGVuIGluIEphdmFTY3JpcHQuXCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJyb3dzZXJpZnlcIjogXCIqXCIsXG4gICAgXCJncnVudFwiOiBcIn4wLjQuMFwiLFxuICAgIFwiZ3J1bnQtYnJvd3NlcmlmeVwiOiBcIl4yLjEuNFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1jb25jYXRcIjogXCJ+MC4xLjNcIixcbiAgICBcImdydW50LWNvbnRyaWItanNoaW50XCI6IFwifjAuMS4xXCIsXG4gICAgXCJncnVudC1jb250cmliLW5vZGV1bml0XCI6IFwiXjAuNC4xXCIsXG4gICAgXCJncnVudC1jb250cmliLXVnbGlmeVwiOiBcIl4wLjUuMVwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi15dWlkb2NcIjogXCJeMC41LjJcIixcbiAgICBcImpzaGludFwiOiBcImxhdGVzdFwiLFxuICAgIFwibm9kZXVuaXRcIjogXCJeMC45LjBcIixcbiAgICBcInVnbGlmeS1qc1wiOiBcImxhdGVzdFwiXG4gIH0sXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiKlwiXG4gIH0sXG4gIFwiZ2l0SGVhZFwiOiBcIjY3OTEwMmE0ODVjN2RkNDM2NmFiZDdhMmIwY2NjMWM3YWViMjZiZDFcIixcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZS9jYW5ub24uanNcIixcbiAgXCJpbnN0YWxsYWJsZVwiOiB0cnVlLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcIjNkXCIsXG4gICAgXCJjYW5ub25cIixcbiAgICBcImNhbm5vbi5qc1wiLFxuICAgIFwiZW5naW5lXCIsXG4gICAgXCJwaHlzaWNzXCJcbiAgXSxcbiAgXCJsaWNlbnNlc1wiOiBbXG4gICAge1xuICAgICAgXCJ0eXBlXCI6IFwiTUlUXCJcbiAgICB9XG4gIF0sXG4gIFwibWFpblwiOiBcIi4vc3JjL0Nhbm5vbi5qc1wiLFxuICBcIm5hbWVcIjogXCJjYW5ub25cIixcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7fSxcbiAgXCJyZWFkbWVcIjogXCIjIGNhbm5vbi5qc1xcblxcbiMjIyBMaWdodHdlaWdodCAzRCBwaHlzaWNzIGZvciB0aGUgd2ViXFxuSW5zcGlyZWQgYnkgW3RocmVlLmpzXShodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzKSBhbmQgW2FtbW8uanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlwa2VuL2FtbW8uanMpLCBhbmQgZHJpdmVuIGJ5IHRoZSBmYWN0IHRoYXQgdGhlIHdlYiBsYWNrcyBhIHBoeXNpY3MgZW5naW5lLCBoZXJlIGNvbWVzIGNhbm5vbi5qcy5cXG5UaGUgcmlnaWQgYm9keSBwaHlzaWNzIGVuZ2luZSBpbmNsdWRlcyBzaW1wbGUgY29sbGlzaW9uIGRldGVjdGlvbiwgdmFyaW91cyBib2R5IHNoYXBlcywgY29udGFjdHMsIGZyaWN0aW9uIGFuZCBjb25zdHJhaW50cy5cXG5cXG5bRGVtb3NdKGh0dHA6Ly9zY2h0ZXBwZS5naXRodWIuY29tL2Nhbm5vbi5qcykgLSBbRG9jdW1lbnRhdGlvbl0oaHR0cDovL3NjaHRlcHBlLmdpdGh1Yi5jb20vY2Fubm9uLmpzL2RvY3MpIC0gW1JlbmRlcmluZyBoaW50c10oaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL2Nhbm5vbi5qcy90cmVlL21hc3Rlci9leGFtcGxlcykgLSBbTlBNIHBhY2thZ2VdKGh0dHBzOi8vbnBtanMub3JnL3BhY2thZ2UvY2Fubm9uKSAtIFtDRE5dKGh0dHBzOi8vY2RuanMuY29tL2xpYnJhcmllcy9jYW5ub24uanMpXFxuXFxuIyMjIEJyb3dzZXIgaW5zdGFsbFxcblxcbkp1c3QgaW5jbHVkZSBbY2Fubm9uLmpzXShodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvY2Fubm9uLmpzL3JlbGVhc2VzL2Rvd25sb2FkL3YwLjYuMi9jYW5ub24uanMpIG9yIFtjYW5ub24ubWluLmpzXShodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGUvY2Fubm9uLmpzL3JlbGVhc2VzL2Rvd25sb2FkL3YwLjYuMi9jYW5ub24ubWluLmpzKSBpbiB5b3VyIGh0bWwgYW5kIHlvdSdyZSBkb25lOlxcblxcbmBgYGh0bWxcXG48c2NyaXB0IHNyYz1cXFwiY2Fubm9uLm1pbi5qc1xcXCI+PC9zY3JpcHQ+XFxuYGBgXFxuXFxuIyMjIE5vZGUuanMgaW5zdGFsbFxcblxcbkluc3RhbGwgdGhlIGNhbm5vbiBwYWNrYWdlIHZpYSBOUE06XFxuXFxuYGBgYmFzaFxcbm5wbSBpbnN0YWxsIC0tc2F2ZSBjYW5ub25cXG5gYGBcXG5cXG5BbHRlcm5hdGl2ZWx5LCBwb2ludCB0byB0aGUgR2l0aHViIHJlcG8gZGlyZWN0bHkgdG8gZ2V0IHRoZSB2ZXJ5IGxhdGVzdCB2ZXJzaW9uOlxcblxcbmBgYGJhc2hcXG5ucG0gaW5zdGFsbCAtLXNhdmUgc2NodGVwcGUvY2Fubm9uLmpzXFxuYGBgXFxuXFxuIyMjIEV4YW1wbGVcXG5cXG5UaGUgc2FtcGxlIGNvZGUgYmVsb3cgY3JlYXRlcyBhIHNwaGVyZSBvbiBhIHBsYW5lLCBzdGVwcyB0aGUgc2ltdWxhdGlvbiwgYW5kIHByaW50cyB0aGUgc3BoZXJlIHNpbXVsYXRpb24gdG8gdGhlIGNvbnNvbGUuIE5vdGUgdGhhdCBDYW5ub24uanMgdXNlcyBbU0kgdW5pdHNdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50ZXJuYXRpb25hbF9TeXN0ZW1fb2ZfVW5pdHMpIChtZXRyZSwga2lsb2dyYW0sIHNlY29uZCwgZXRjLikuXFxuXFxuYGBgamF2YXNjcmlwdFxcbi8vIFNldHVwIG91ciB3b3JsZFxcbnZhciB3b3JsZCA9IG5ldyBDQU5OT04uV29ybGQoKTtcXG53b3JsZC5ncmF2aXR5LnNldCgwLCAwLCAtOS44Mik7IC8vIG0vc8KyXFxuXFxuLy8gQ3JlYXRlIGEgc3BoZXJlXFxudmFyIHJhZGl1cyA9IDE7IC8vIG1cXG52YXIgc3BoZXJlQm9keSA9IG5ldyBDQU5OT04uQm9keSh7XFxuICAgbWFzczogNSwgLy8ga2dcXG4gICBwb3NpdGlvbjogbmV3IENBTk5PTi5WZWMzKDAsIDAsIDEwKSwgLy8gbVxcbiAgIHNoYXBlOiBuZXcgQ0FOTk9OLlNwaGVyZShyYWRpdXMpXFxufSk7XFxud29ybGQuYWRkQm9keShzcGhlcmVCb2R5KTtcXG5cXG4vLyBDcmVhdGUgYSBwbGFuZVxcbnZhciBncm91bmRCb2R5ID0gbmV3IENBTk5PTi5Cb2R5KHtcXG4gICAgbWFzczogMCAvLyBtYXNzID09IDAgbWFrZXMgdGhlIGJvZHkgc3RhdGljXFxufSk7XFxudmFyIGdyb3VuZFNoYXBlID0gbmV3IENBTk5PTi5QbGFuZSgpO1xcbmdyb3VuZEJvZHkuYWRkU2hhcGUoZ3JvdW5kU2hhcGUpO1xcbndvcmxkLmFkZEJvZHkoZ3JvdW5kQm9keSk7XFxuXFxudmFyIGZpeGVkVGltZVN0ZXAgPSAxLjAgLyA2MC4wOyAvLyBzZWNvbmRzXFxudmFyIG1heFN1YlN0ZXBzID0gMztcXG5cXG4vLyBTdGFydCB0aGUgc2ltdWxhdGlvbiBsb29wXFxudmFyIGxhc3RUaW1lO1xcbihmdW5jdGlvbiBzaW1sb29wKHRpbWUpe1xcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNpbWxvb3ApO1xcbiAgaWYobGFzdFRpbWUgIT09IHVuZGVmaW5lZCl7XFxuICAgICB2YXIgZHQgPSAodGltZSAtIGxhc3RUaW1lKSAvIDEwMDA7XFxuICAgICB3b3JsZC5zdGVwKGZpeGVkVGltZVN0ZXAsIGR0LCBtYXhTdWJTdGVwcyk7XFxuICB9XFxuICBjb25zb2xlLmxvZyhcXFwiU3BoZXJlIHogcG9zaXRpb246IFxcXCIgKyBzcGhlcmVCb2R5LnBvc2l0aW9uLnopO1xcbiAgbGFzdFRpbWUgPSB0aW1lO1xcbn0pKCk7XFxuYGBgXFxuXFxuSWYgeW91IHdhbnQgdG8ga25vdyBob3cgdG8gdXNlIGNhbm5vbi5qcyB3aXRoIGEgcmVuZGVyaW5nIGVuZ2luZSwgZm9yIGV4YW1wbGUgVGhyZWUuanMsIHNlZSB0aGUgW0V4YW1wbGVzXShleGFtcGxlcykuXFxuXFxuIyMjIEZlYXR1cmVzXFxuKiBSaWdpZCBib2R5IGR5bmFtaWNzXFxuKiBEaXNjcmV0ZSBjb2xsaXNpb24gZGV0ZWN0aW9uXFxuKiBDb250YWN0cywgZnJpY3Rpb24gYW5kIHJlc3RpdHV0aW9uXFxuKiBDb25zdHJhaW50c1xcbiAgICogUG9pbnRUb1BvaW50IChhLmsuYS4gYmFsbC9zb2NrZXQgam9pbnQpXFxuICAgKiBEaXN0YW5jZVxcbiAgICogSGluZ2UgKHdpdGggb3B0aW9uYWwgbW90b3IpXFxuICAgKiBMb2NrXFxuICAgKiBDb25lVHdpc3RcXG4qIEdhdXNzLVNlaWRlbCBjb25zdHJhaW50IHNvbHZlciBhbmQgYW4gaXNsYW5kIHNwbGl0IGFsZ29yaXRobVxcbiogQ29sbGlzaW9uIGZpbHRlcnNcXG4qIEJvZHkgc2xlZXBpbmdcXG4qIEV4cGVyaW1lbnRhbCBTUEggLyBmbHVpZCBzdXBwb3J0XFxuKiBWYXJpb3VzIHNoYXBlcyBhbmQgY29sbGlzaW9uIGFsZ29yaXRobXMgKHNlZSB0YWJsZSBiZWxvdylcXG5cXG58ICAgICAgICAgICAgIHwgW1NwaGVyZV0oaHR0cDovL3NjaHRlcHBlLmdpdGh1Yi5pby9jYW5ub24uanMvZG9jcy9jbGFzc2VzL1NwaGVyZS5odG1sKSB8IFtQbGFuZV0oaHR0cDovL3NjaHRlcHBlLmdpdGh1Yi5pby9jYW5ub24uanMvZG9jcy9jbGFzc2VzL1BsYW5lLmh0bWwpIHwgW0JveF0oaHR0cDovL3NjaHRlcHBlLmdpdGh1Yi5pby9jYW5ub24uanMvZG9jcy9jbGFzc2VzL0JveC5odG1sKSB8IFtDb252ZXhdKGh0dHA6Ly9zY2h0ZXBwZS5naXRodWIuaW8vY2Fubm9uLmpzL2RvY3MvY2xhc3Nlcy9Db252ZXhQb2x5aGVkcm9uLmh0bWwpIHwgW1BhcnRpY2xlXShodHRwOi8vc2NodGVwcGUuZ2l0aHViLmlvL2Nhbm5vbi5qcy9kb2NzL2NsYXNzZXMvUGFydGljbGUuaHRtbCkgfCBbSGVpZ2h0ZmllbGRdKGh0dHA6Ly9zY2h0ZXBwZS5naXRodWIuaW8vY2Fubm9uLmpzL2RvY3MvY2xhc3Nlcy9IZWlnaHRmaWVsZC5odG1sKSB8IFtUcmltZXNoXShodHRwOi8vc2NodGVwcGUuZ2l0aHViLmlvL2Nhbm5vbi5qcy9kb2NzL2NsYXNzZXMvVHJpbWVzaC5odG1sKSB8XFxufCA6LS0tLS0tLS0tLS18Oi0tLS0tLTp8Oi0tLS0tOnw6LS0tOnw6LS0tLS0tOnw6LS0tLS0tLS06fDotLS0tLS0tLS0tLTp8Oi0tLS0tLS06fFxcbnwgU3BoZXJlICAgICAgfCBZZXMgICAgfCBZZXMgICB8IFllcyB8IFllcyAgICB8IFllcyAgICAgIHwgWWVzICAgICAgICAgfCBZZXMgICAgIHxcXG58IFBsYW5lICAgICAgIHwgLSAgICAgIHwgLSAgICAgfCBZZXMgfCBZZXMgICAgfCBZZXMgICAgICB8IC0gICAgICAgICAgIHwgWWVzICAgICB8XFxufCBCb3ggICAgICAgICB8IC0gICAgICB8IC0gICAgIHwgWWVzIHwgWWVzICAgIHwgWWVzICAgICAgfCBZZXMgICAgICAgICB8ICh0b2RvKSAgfFxcbnwgQ3lsaW5kZXIgICAgfCAtICAgICAgfCAtICAgICB8IFllcyB8IFllcyAgICB8IFllcyAgICAgIHwgWWVzICAgICAgICAgfCAodG9kbykgIHxcXG58IENvbnZleCAgICAgIHwgLSAgICAgIHwgLSAgICAgfCAtICAgfCBZZXMgICAgfCBZZXMgICAgICB8IFllcyAgICAgICAgIHwgKHRvZG8pICB8XFxufCBQYXJ0aWNsZSAgICB8IC0gICAgICB8IC0gICAgIHwgLSAgIHwgLSAgICAgIHwgLSAgICAgICAgfCAodG9kbykgICAgICB8ICh0b2RvKSAgfFxcbnwgSGVpZ2h0ZmllbGQgfCAtICAgICAgfCAtICAgICB8IC0gICB8IC0gICAgICB8IC0gICAgICAgIHwgLSAgICAgICAgICAgfCAodG9kbykgIHxcXG58IFRyaW1lc2ggICAgIHwgLSAgICAgIHwgLSAgICAgfCAtICAgfCAtICAgICAgfCAtICAgICAgICB8IC0gICAgICAgICAgIHwgLSAgICAgICB8XFxuXFxuIyMjIFRvZG9cXG5UaGUgc2ltcGxlciB0b2RvcyBhcmUgbWFya2VkIHdpdGggYGBgQHRvZG9gYGAgaW4gdGhlIGNvZGUuIEdpdGh1YiBJc3N1ZXMgY2FuIGFuZCBzaG91bGQgYWxzbyBiZSB1c2VkIGZvciB0b2Rvcy5cXG5cXG4jIyMgSGVscFxcbkNyZWF0ZSBhbiBbaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZS9jYW5ub24uanMvaXNzdWVzKSBpZiB5b3UgbmVlZCBoZWxwLlxcblwiLFxuICBcInJlYWRtZUZpbGVuYW1lXCI6IFwiUkVBRE1FLm1hcmtkb3duXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL2Nhbm5vbi5qcy5naXRcIlxuICB9LFxuICBcInZlcnNpb25cIjogXCIwLjYuMlwiXG59XG4iLCIvLyBFeHBvcnQgY2xhc3Nlc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdmVyc2lvbiA6ICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uLFxuXG4gICAgQUFCQiA6ICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbGxpc2lvbi9BQUJCJyksXG4gICAgQXJyYXlDb2xsaXNpb25NYXRyaXggOiAgICAgICAgICByZXF1aXJlKCcuL2NvbGxpc2lvbi9BcnJheUNvbGxpc2lvbk1hdHJpeCcpLFxuICAgIEJvZHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9vYmplY3RzL0JvZHknKSxcbiAgICBCb3ggOiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhcGVzL0JveCcpLFxuICAgIEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxuICAgIENvbnN0cmFpbnQgOiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb25zdHJhaW50cy9Db25zdHJhaW50JyksXG4gICAgQ29udGFjdEVxdWF0aW9uIDogICAgICAgICAgICAgICByZXF1aXJlKCcuL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKSxcbiAgICBOYXJyb3dwaGFzZSA6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vd29ybGQvTmFycm93cGhhc2UnKSxcbiAgICBDb25lVHdpc3RDb25zdHJhaW50IDogICAgICAgICAgIHJlcXVpcmUoJy4vY29uc3RyYWludHMvQ29uZVR3aXN0Q29uc3RyYWludCcpLFxuICAgIENvbnRhY3RNYXRlcmlhbCA6ICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9tYXRlcmlhbC9Db250YWN0TWF0ZXJpYWwnKSxcbiAgICBDb252ZXhQb2x5aGVkcm9uIDogICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhcGVzL0NvbnZleFBvbHloZWRyb24nKSxcbiAgICBDeWxpbmRlciA6ICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhcGVzL0N5bGluZGVyJyksXG4gICAgRGlzdGFuY2VDb25zdHJhaW50IDogICAgICAgICAgICByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0Rpc3RhbmNlQ29uc3RyYWludCcpLFxuICAgIEVxdWF0aW9uIDogICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9lcXVhdGlvbnMvRXF1YXRpb24nKSxcbiAgICBFdmVudFRhcmdldCA6ICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vdXRpbHMvRXZlbnRUYXJnZXQnKSxcbiAgICBGcmljdGlvbkVxdWF0aW9uIDogICAgICAgICAgICAgIHJlcXVpcmUoJy4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKSxcbiAgICBHU1NvbHZlciA6ICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc29sdmVyL0dTU29sdmVyJyksXG4gICAgR3JpZEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbGxpc2lvbi9HcmlkQnJvYWRwaGFzZScpLFxuICAgIEhlaWdodGZpZWxkIDogICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zaGFwZXMvSGVpZ2h0ZmllbGQnKSxcbiAgICBIaW5nZUNvbnN0cmFpbnQgOiAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50JyksXG4gICAgTG9ja0NvbnN0cmFpbnQgOiAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50JyksXG4gICAgTWF0MyA6ICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL21hdGgvTWF0MycpLFxuICAgIE1hdGVyaWFsIDogICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9tYXRlcmlhbC9NYXRlcmlhbCcpLFxuICAgIE5haXZlQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyksXG4gICAgT2JqZWN0Q29sbGlzaW9uTWF0cml4IDogICAgICAgICByZXF1aXJlKCcuL2NvbGxpc2lvbi9PYmplY3RDb2xsaXNpb25NYXRyaXgnKSxcbiAgICBQb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vdXRpbHMvUG9vbCcpLFxuICAgIFBhcnRpY2xlIDogICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zaGFwZXMvUGFydGljbGUnKSxcbiAgICBQbGFuZSA6ICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc2hhcGVzL1BsYW5lJyksXG4gICAgUG9pbnRUb1BvaW50Q29uc3RyYWludCA6ICAgICAgICByZXF1aXJlKCcuL2NvbnN0cmFpbnRzL1BvaW50VG9Qb2ludENvbnN0cmFpbnQnKSxcbiAgICBRdWF0ZXJuaW9uIDogICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vbWF0aC9RdWF0ZXJuaW9uJyksXG4gICAgUmF5IDogICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2NvbGxpc2lvbi9SYXknKSxcbiAgICBSYXljYXN0VmVoaWNsZSA6ICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vb2JqZWN0cy9SYXljYXN0VmVoaWNsZScpLFxuICAgIFJheWNhc3RSZXN1bHQgOiAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpLFxuICAgIFJpZ2lkVmVoaWNsZSA6ICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9vYmplY3RzL1JpZ2lkVmVoaWNsZScpLFxuICAgIFJvdGF0aW9uYWxFcXVhdGlvbiA6ICAgICAgICAgICAgcmVxdWlyZSgnLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyksXG4gICAgUm90YXRpb25hbE1vdG9yRXF1YXRpb24gOiAgICAgICByZXF1aXJlKCcuL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbicpLFxuICAgIFNBUEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9jb2xsaXNpb24vU0FQQnJvYWRwaGFzZScpLFxuICAgIFNQSFN5c3RlbSA6ICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9vYmplY3RzL1NQSFN5c3RlbScpLFxuICAgIFNoYXBlIDogICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zaGFwZXMvU2hhcGUnKSxcbiAgICBTb2x2ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vc29sdmVyL1NvbHZlcicpLFxuICAgIFNwaGVyZSA6ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zaGFwZXMvU3BoZXJlJyksXG4gICAgU3BsaXRTb2x2ZXIgOiAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3NvbHZlci9TcGxpdFNvbHZlcicpLFxuICAgIFNwcmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9vYmplY3RzL1NwcmluZycpLFxuICAgIFRyYW5zZm9ybSA6ICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9tYXRoL1RyYW5zZm9ybScpLFxuICAgIFRyaW1lc2ggOiAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9zaGFwZXMvVHJpbWVzaCcpLFxuICAgIFZlYzMgOiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9tYXRoL1ZlYzMnKSxcbiAgICBWZWMzUG9vbCA6ICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vdXRpbHMvVmVjM1Bvb2wnKSxcbiAgICBXb3JsZCA6ICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vd29ybGQvV29ybGQnKSxcbn07XG4iLCJ2YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBQUJCO1xuXG4vKipcbiAqIEF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggY2xhc3MuXG4gKiBAY2xhc3MgQUFCQlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge1ZlYzN9ICAgW29wdGlvbnMudXBwZXJCb3VuZF1cbiAqIEBwYXJhbSB7VmVjM30gICBbb3B0aW9ucy5sb3dlckJvdW5kXVxuICovXG5mdW5jdGlvbiBBQUJCKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHByb3BlcnR5IGxvd2VyQm91bmRcbiAgICAgKiBAdHlwZSB7VmVjM31cbiAgICAgKi9cbiAgICB0aGlzLmxvd2VyQm91bmQgPSBuZXcgVmVjMygpO1xuICAgIGlmKG9wdGlvbnMubG93ZXJCb3VuZCl7XG4gICAgICAgIHRoaXMubG93ZXJCb3VuZC5jb3B5KG9wdGlvbnMubG93ZXJCb3VuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHVwcGVyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICogQHByb3BlcnR5IHVwcGVyQm91bmRcbiAgICAgKiBAdHlwZSB7VmVjM31cbiAgICAgKi9cbiAgICB0aGlzLnVwcGVyQm91bmQgPSBuZXcgVmVjMygpO1xuICAgIGlmKG9wdGlvbnMudXBwZXJCb3VuZCl7XG4gICAgICAgIHRoaXMudXBwZXJCb3VuZC5jb3B5KG9wdGlvbnMudXBwZXJCb3VuZCk7XG4gICAgfVxufVxuXG52YXIgdG1wID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBTZXQgdGhlIEFBQkIgYm91bmRzIGZyb20gYSBzZXQgb2YgcG9pbnRzLlxuICogQG1ldGhvZCBzZXRGcm9tUG9pbnRzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgQW4gYXJyYXkgb2YgVmVjMydzLlxuICogQHBhcmFtIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge251bWJlcn0gc2tpblNpemVcbiAqIEByZXR1cm4ge0FBQkJ9IFRoZSBzZWxmIG9iamVjdFxuICovXG5BQUJCLnByb3RvdHlwZS5zZXRGcm9tUG9pbnRzID0gZnVuY3Rpb24ocG9pbnRzLCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2tpblNpemUpe1xuICAgIHZhciBsID0gdGhpcy5sb3dlckJvdW5kLFxuICAgICAgICB1ID0gdGhpcy51cHBlckJvdW5kLFxuICAgICAgICBxID0gcXVhdGVybmlvbjtcblxuICAgIC8vIFNldCB0byB0aGUgZmlyc3QgcG9pbnRcbiAgICBsLmNvcHkocG9pbnRzWzBdKTtcbiAgICBpZihxKXtcbiAgICAgICAgcS52bXVsdChsLCBsKTtcbiAgICB9XG4gICAgdS5jb3B5KGwpO1xuXG4gICAgZm9yKHZhciBpID0gMTsgaTxwb2ludHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcblxuICAgICAgICBpZihxKXtcbiAgICAgICAgICAgIHEudm11bHQocCwgdG1wKTtcbiAgICAgICAgICAgIHAgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZihwLnggPiB1LngpeyB1LnggPSBwLng7IH1cbiAgICAgICAgaWYocC54IDwgbC54KXsgbC54ID0gcC54OyB9XG4gICAgICAgIGlmKHAueSA+IHUueSl7IHUueSA9IHAueTsgfVxuICAgICAgICBpZihwLnkgPCBsLnkpeyBsLnkgPSBwLnk7IH1cbiAgICAgICAgaWYocC56ID4gdS56KXsgdS56ID0gcC56OyB9XG4gICAgICAgIGlmKHAueiA8IGwueil7IGwueiA9IHAuejsgfVxuICAgIH1cblxuICAgIC8vIEFkZCBvZmZzZXRcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgcG9zaXRpb24udmFkZChsLCBsKTtcbiAgICAgICAgcG9zaXRpb24udmFkZCh1LCB1KTtcbiAgICB9XG5cbiAgICBpZihza2luU2l6ZSl7XG4gICAgICAgIGwueCAtPSBza2luU2l6ZTtcbiAgICAgICAgbC55IC09IHNraW5TaXplO1xuICAgICAgICBsLnogLT0gc2tpblNpemU7XG4gICAgICAgIHUueCArPSBza2luU2l6ZTtcbiAgICAgICAgdS55ICs9IHNraW5TaXplO1xuICAgICAgICB1LnogKz0gc2tpblNpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvcHkgYm91bmRzIGZyb20gYW4gQUFCQiB0byB0aGlzIEFBQkJcbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtICB7QUFCQn0gYWFiYiBTb3VyY2UgdG8gY29weSBmcm9tXG4gKiBAcmV0dXJuIHtBQUJCfSBUaGUgdGhpcyBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHlcbiAqL1xuQUFCQi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHRoaXMubG93ZXJCb3VuZC5jb3B5KGFhYmIubG93ZXJCb3VuZCk7XG4gICAgdGhpcy51cHBlckJvdW5kLmNvcHkoYWFiYi51cHBlckJvdW5kKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvbmUgYW4gQUFCQlxuICogQG1ldGhvZCBjbG9uZVxuICovXG5BQUJCLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5ldyBBQUJCKCkuY29weSh0aGlzKTtcbn07XG5cbi8qKlxuICogRXh0ZW5kIHRoaXMgQUFCQiBzbyB0aGF0IGl0IGNvdmVycyB0aGUgZ2l2ZW4gQUFCQiB0b28uXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICovXG5BQUJCLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbihhYWJiKXtcbiAgICB0aGlzLmxvd2VyQm91bmQueCA9IE1hdGgubWluKHRoaXMubG93ZXJCb3VuZC54LCBhYWJiLmxvd2VyQm91bmQueCk7XG4gICAgdGhpcy51cHBlckJvdW5kLnggPSBNYXRoLm1heCh0aGlzLnVwcGVyQm91bmQueCwgYWFiYi51cHBlckJvdW5kLngpO1xuICAgIHRoaXMubG93ZXJCb3VuZC55ID0gTWF0aC5taW4odGhpcy5sb3dlckJvdW5kLnksIGFhYmIubG93ZXJCb3VuZC55KTtcbiAgICB0aGlzLnVwcGVyQm91bmQueSA9IE1hdGgubWF4KHRoaXMudXBwZXJCb3VuZC55LCBhYWJiLnVwcGVyQm91bmQueSk7XG4gICAgdGhpcy5sb3dlckJvdW5kLnogPSBNYXRoLm1pbih0aGlzLmxvd2VyQm91bmQueiwgYWFiYi5sb3dlckJvdW5kLnopO1xuICAgIHRoaXMudXBwZXJCb3VuZC56ID0gTWF0aC5tYXgodGhpcy51cHBlckJvdW5kLnosIGFhYmIudXBwZXJCb3VuZC56KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBBQUJCIG92ZXJsYXBzIHRoaXMgQUFCQi5cbiAqIEBtZXRob2Qgb3ZlcmxhcHNcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkFBQkIucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24oYWFiYil7XG4gICAgdmFyIGwxID0gdGhpcy5sb3dlckJvdW5kLFxuICAgICAgICB1MSA9IHRoaXMudXBwZXJCb3VuZCxcbiAgICAgICAgbDIgPSBhYWJiLmxvd2VyQm91bmQsXG4gICAgICAgIHUyID0gYWFiYi51cHBlckJvdW5kO1xuXG4gICAgLy8gICAgICBsMiAgICAgICAgdTJcbiAgICAvLyAgICAgIHwtLS0tLS0tLS18XG4gICAgLy8gfC0tLS0tLS0tfFxuICAgIC8vIGwxICAgICAgIHUxXG5cbiAgICB2YXIgb3ZlcmxhcHNYID0gKChsMi54IDw9IHUxLnggJiYgdTEueCA8PSB1Mi54KSB8fCAobDEueCA8PSB1Mi54ICYmIHUyLnggPD0gdTEueCkpO1xuICAgIHZhciBvdmVybGFwc1kgPSAoKGwyLnkgPD0gdTEueSAmJiB1MS55IDw9IHUyLnkpIHx8IChsMS55IDw9IHUyLnkgJiYgdTIueSA8PSB1MS55KSk7XG4gICAgdmFyIG92ZXJsYXBzWiA9ICgobDIueiA8PSB1MS56ICYmIHUxLnogPD0gdTIueikgfHwgKGwxLnogPD0gdTIueiAmJiB1Mi56IDw9IHUxLnopKTtcblxuICAgIHJldHVybiBvdmVybGFwc1ggJiYgb3ZlcmxhcHNZICYmIG92ZXJsYXBzWjtcbn07XG5cbi8vIE1vc3RseSBmb3IgZGVidWdnaW5nXG5BQUJCLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBsID0gdGhpcy5sb3dlckJvdW5kLFxuICAgICAgICB1ID0gdGhpcy51cHBlckJvdW5kO1xuICAgIHJldHVybiAodS54IC0gbC54KSAqICh1LnkgLSBsLnkpICogKHUueiAtIGwueik7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBBQUJCIGlzIGZ1bGx5IGNvbnRhaW5lZCBpbiB0aGlzIEFBQkIuXG4gKiBAbWV0aG9kIGNvbnRhaW5zXG4gKiBAcGFyYW0ge0FBQkJ9IGFhYmJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkFBQkIucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oYWFiYil7XG4gICAgdmFyIGwxID0gdGhpcy5sb3dlckJvdW5kLFxuICAgICAgICB1MSA9IHRoaXMudXBwZXJCb3VuZCxcbiAgICAgICAgbDIgPSBhYWJiLmxvd2VyQm91bmQsXG4gICAgICAgIHUyID0gYWFiYi51cHBlckJvdW5kO1xuXG4gICAgLy8gICAgICBsMiAgICAgICAgdTJcbiAgICAvLyAgICAgIHwtLS0tLS0tLS18XG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyBsMSAgICAgICAgICAgICAgdTFcblxuICAgIHJldHVybiAoXG4gICAgICAgIChsMS54IDw9IGwyLnggJiYgdTEueCA+PSB1Mi54KSAmJlxuICAgICAgICAobDEueSA8PSBsMi55ICYmIHUxLnkgPj0gdTIueSkgJiZcbiAgICAgICAgKGwxLnogPD0gbDIueiAmJiB1MS56ID49IHUyLnopXG4gICAgKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXRDb3JuZXJzXG4gKiBAcGFyYW0ge1ZlYzN9IGFcbiAqIEBwYXJhbSB7VmVjM30gYlxuICogQHBhcmFtIHtWZWMzfSBjXG4gKiBAcGFyYW0ge1ZlYzN9IGRcbiAqIEBwYXJhbSB7VmVjM30gZVxuICogQHBhcmFtIHtWZWMzfSBmXG4gKiBAcGFyYW0ge1ZlYzN9IGdcbiAqIEBwYXJhbSB7VmVjM30gaFxuICovXG5BQUJCLnByb3RvdHlwZS5nZXRDb3JuZXJzID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZiwgZywgaCl7XG4gICAgdmFyIGwgPSB0aGlzLmxvd2VyQm91bmQsXG4gICAgICAgIHUgPSB0aGlzLnVwcGVyQm91bmQ7XG5cbiAgICBhLmNvcHkobCk7XG4gICAgYi5zZXQoIHUueCwgbC55LCBsLnogKTtcbiAgICBjLnNldCggdS54LCB1LnksIGwueiApO1xuICAgIGQuc2V0KCBsLngsIHUueSwgdS56ICk7XG4gICAgZS5zZXQoIHUueCwgbC55LCBsLnogKTtcbiAgICBmLnNldCggbC54LCB1LnksIGwueiApO1xuICAgIGcuc2V0KCBsLngsIGwueSwgdS56ICk7XG4gICAgaC5jb3B5KHUpO1xufTtcblxudmFyIHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzID0gW1xuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKVxuXTtcblxuLyoqXG4gKiBHZXQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFBQkIgaW4gYW5vdGhlciBmcmFtZS5cbiAqIEBtZXRob2QgdG9Mb2NhbEZyYW1lXG4gKiBAcGFyYW0gIHtUcmFuc2Zvcm19IGZyYW1lXG4gKiBAcGFyYW0gIHtBQUJCfSB0YXJnZXRcbiAqIEByZXR1cm4ge0FBQkJ9IFRoZSBcInRhcmdldFwiIEFBQkIgb2JqZWN0LlxuICovXG5BQUJCLnByb3RvdHlwZS50b0xvY2FsRnJhbWUgPSBmdW5jdGlvbihmcmFtZSwgdGFyZ2V0KXtcblxuICAgIHZhciBjb3JuZXJzID0gdHJhbnNmb3JtSW50b0ZyYW1lX2Nvcm5lcnM7XG4gICAgdmFyIGEgPSBjb3JuZXJzWzBdO1xuICAgIHZhciBiID0gY29ybmVyc1sxXTtcbiAgICB2YXIgYyA9IGNvcm5lcnNbMl07XG4gICAgdmFyIGQgPSBjb3JuZXJzWzNdO1xuICAgIHZhciBlID0gY29ybmVyc1s0XTtcbiAgICB2YXIgZiA9IGNvcm5lcnNbNV07XG4gICAgdmFyIGcgPSBjb3JuZXJzWzZdO1xuICAgIHZhciBoID0gY29ybmVyc1s3XTtcblxuICAgIC8vIEdldCBjb3JuZXJzIGluIGN1cnJlbnQgZnJhbWVcbiAgICB0aGlzLmdldENvcm5lcnMoYSwgYiwgYywgZCwgZSwgZiwgZywgaCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gdGhlbSB0byBuZXcgbG9jYWwgZnJhbWVcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gODsgaSsrKXtcbiAgICAgICAgdmFyIGNvcm5lciA9IGNvcm5lcnNbaV07XG4gICAgICAgIGZyYW1lLnBvaW50VG9Mb2NhbChjb3JuZXIsIGNvcm5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldC5zZXRGcm9tUG9pbnRzKGNvcm5lcnMpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFBQkIgaW4gdGhlIGdsb2JhbCBmcmFtZS5cbiAqIEBtZXRob2QgdG9Xb3JsZEZyYW1lXG4gKiBAcGFyYW0gIHtUcmFuc2Zvcm19IGZyYW1lXG4gKiBAcGFyYW0gIHtBQUJCfSB0YXJnZXRcbiAqIEByZXR1cm4ge0FBQkJ9IFRoZSBcInRhcmdldFwiIEFBQkIgb2JqZWN0LlxuICovXG5BQUJCLnByb3RvdHlwZS50b1dvcmxkRnJhbWUgPSBmdW5jdGlvbihmcmFtZSwgdGFyZ2V0KXtcblxuICAgIHZhciBjb3JuZXJzID0gdHJhbnNmb3JtSW50b0ZyYW1lX2Nvcm5lcnM7XG4gICAgdmFyIGEgPSBjb3JuZXJzWzBdO1xuICAgIHZhciBiID0gY29ybmVyc1sxXTtcbiAgICB2YXIgYyA9IGNvcm5lcnNbMl07XG4gICAgdmFyIGQgPSBjb3JuZXJzWzNdO1xuICAgIHZhciBlID0gY29ybmVyc1s0XTtcbiAgICB2YXIgZiA9IGNvcm5lcnNbNV07XG4gICAgdmFyIGcgPSBjb3JuZXJzWzZdO1xuICAgIHZhciBoID0gY29ybmVyc1s3XTtcblxuICAgIC8vIEdldCBjb3JuZXJzIGluIGN1cnJlbnQgZnJhbWVcbiAgICB0aGlzLmdldENvcm5lcnMoYSwgYiwgYywgZCwgZSwgZiwgZywgaCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gdGhlbSB0byBuZXcgbG9jYWwgZnJhbWVcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gODsgaSsrKXtcbiAgICAgICAgdmFyIGNvcm5lciA9IGNvcm5lcnNbaV07XG4gICAgICAgIGZyYW1lLnBvaW50VG9Xb3JsZChjb3JuZXIsIGNvcm5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldC5zZXRGcm9tUG9pbnRzKGNvcm5lcnMpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgQUFCQiBpcyBoaXQgYnkgYSByYXkuXG4gKiBAcGFyYW0gIHtSYXl9IHJheVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5BQUJCLnByb3RvdHlwZS5vdmVybGFwc1JheSA9IGZ1bmN0aW9uKHJheSl7XG4gICAgdmFyIHQgPSAwO1xuXG4gICAgLy8gcmF5LmRpcmVjdGlvbiBpcyB1bml0IGRpcmVjdGlvbiB2ZWN0b3Igb2YgcmF5XG4gICAgdmFyIGRpckZyYWNYID0gMSAvIHJheS5fZGlyZWN0aW9uLng7XG4gICAgdmFyIGRpckZyYWNZID0gMSAvIHJheS5fZGlyZWN0aW9uLnk7XG4gICAgdmFyIGRpckZyYWNaID0gMSAvIHJheS5fZGlyZWN0aW9uLno7XG5cbiAgICAvLyB0aGlzLmxvd2VyQm91bmQgaXMgdGhlIGNvcm5lciBvZiBBQUJCIHdpdGggbWluaW1hbCBjb29yZGluYXRlcyAtIGxlZnQgYm90dG9tLCBydCBpcyBtYXhpbWFsIGNvcm5lclxuICAgIHZhciB0MSA9ICh0aGlzLmxvd2VyQm91bmQueCAtIHJheS5mcm9tLngpICogZGlyRnJhY1g7XG4gICAgdmFyIHQyID0gKHRoaXMudXBwZXJCb3VuZC54IC0gcmF5LmZyb20ueCkgKiBkaXJGcmFjWDtcbiAgICB2YXIgdDMgPSAodGhpcy5sb3dlckJvdW5kLnkgLSByYXkuZnJvbS55KSAqIGRpckZyYWNZO1xuICAgIHZhciB0NCA9ICh0aGlzLnVwcGVyQm91bmQueSAtIHJheS5mcm9tLnkpICogZGlyRnJhY1k7XG4gICAgdmFyIHQ1ID0gKHRoaXMubG93ZXJCb3VuZC56IC0gcmF5LmZyb20ueikgKiBkaXJGcmFjWjtcbiAgICB2YXIgdDYgPSAodGhpcy51cHBlckJvdW5kLnogLSByYXkuZnJvbS56KSAqIGRpckZyYWNaO1xuXG4gICAgLy8gdmFyIHRtaW4gPSBNYXRoLm1heChNYXRoLm1heChNYXRoLm1pbih0MSwgdDIpLCBNYXRoLm1pbih0MywgdDQpKSk7XG4gICAgLy8gdmFyIHRtYXggPSBNYXRoLm1pbihNYXRoLm1pbihNYXRoLm1heCh0MSwgdDIpLCBNYXRoLm1heCh0MywgdDQpKSk7XG4gICAgdmFyIHRtaW4gPSBNYXRoLm1heChNYXRoLm1heChNYXRoLm1pbih0MSwgdDIpLCBNYXRoLm1pbih0MywgdDQpKSwgTWF0aC5taW4odDUsIHQ2KSk7XG4gICAgdmFyIHRtYXggPSBNYXRoLm1pbihNYXRoLm1pbihNYXRoLm1heCh0MSwgdDIpLCBNYXRoLm1heCh0MywgdDQpKSwgTWF0aC5tYXgodDUsIHQ2KSk7XG5cbiAgICAvLyBpZiB0bWF4IDwgMCwgcmF5IChsaW5lKSBpcyBpbnRlcnNlY3RpbmcgQUFCQiwgYnV0IHdob2xlIEFBQkIgaXMgYmVoaW5nIHVzXG4gICAgaWYgKHRtYXggPCAwKXtcbiAgICAgICAgLy90ID0gdG1heDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGlmIHRtaW4gPiB0bWF4LCByYXkgZG9lc24ndCBpbnRlcnNlY3QgQUFCQlxuICAgIGlmICh0bWluID4gdG1heCl7XG4gICAgICAgIC8vdCA9IHRtYXg7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheUNvbGxpc2lvbk1hdHJpeDtcblxuLyoqXG4gKiBDb2xsaXNpb24gXCJtYXRyaXhcIi4gSXQncyBhY3R1YWxseSBhIHRyaWFuZ3VsYXItc2hhcGVkIGFycmF5IG9mIHdoZXRoZXIgdHdvIGJvZGllcyBhcmUgdG91Y2hpbmcgdGhpcyBzdGVwLCBmb3IgcmVmZXJlbmNlIG5leHQgc3RlcFxuICogQGNsYXNzIEFycmF5Q29sbGlzaW9uTWF0cml4XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQXJyYXlDb2xsaXNpb25NYXRyaXgoKSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF0cml4IHN0b3JhZ2VcbiAgICAgKiBAcHJvcGVydHkgbWF0cml4XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuXHR0aGlzLm1hdHJpeCA9IFtdO1xufVxuXG4vKipcbiAqIEdldCBhbiBlbGVtZW50XG4gKiBAbWV0aG9kIGdldFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQXJyYXlDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGksIGopIHtcblx0aSA9IGkuaW5kZXg7XG5cdGogPSBqLmluZGV4O1xuICAgIGlmIChqID4gaSkge1xuICAgICAgICB2YXIgdGVtcCA9IGo7XG4gICAgICAgIGogPSBpO1xuICAgICAgICBpID0gdGVtcDtcbiAgICB9XG5cdHJldHVybiB0aGlzLm1hdHJpeFsoaSooaSArIDEpPj4xKSArIGotMV07XG59O1xuXG4vKipcbiAqIFNldCBhbiBlbGVtZW50XG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSB7TnVtYmVyfSBqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqL1xuQXJyYXlDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGksIGosIHZhbHVlKSB7XG5cdGkgPSBpLmluZGV4O1xuXHRqID0gai5pbmRleDtcbiAgICBpZiAoaiA+IGkpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgaSA9IHRlbXA7XG4gICAgfVxuXHR0aGlzLm1hdHJpeFsoaSooaSArIDEpPj4xKSArIGotMV0gPSB2YWx1ZSA/IDEgOiAwO1xufTtcblxuLyoqXG4gKiBTZXRzIGFsbCBlbGVtZW50cyB0byB6ZXJvXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cbkFycmF5Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHRmb3IgKHZhciBpPTAsIGw9dGhpcy5tYXRyaXgubGVuZ3RoOyBpIT09bDsgaSsrKSB7XG5cdFx0dGhpcy5tYXRyaXhbaV09MDtcblx0fVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXggbnVtYmVyIG9mIG9iamVjdHNcbiAqIEBtZXRob2Qgc2V0TnVtT2JqZWN0c1xuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqL1xuQXJyYXlDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnNldE51bU9iamVjdHMgPSBmdW5jdGlvbihuKSB7XG5cdHRoaXMubWF0cml4Lmxlbmd0aCA9IG4qKG4tMSk+PjE7XG59O1xuIiwidmFyIEJvZHkgPSByZXF1aXJlKCcuLi9vYmplY3RzL0JvZHknKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFNoYXBlID0gcmVxdWlyZSgnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgUGxhbmUgPSByZXF1aXJlKCcuLi9zaGFwZXMvUGxhbmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcm9hZHBoYXNlO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGJyb2FkcGhhc2UgaW1wbGVtZW50YXRpb25zXG4gKiBAY2xhc3MgQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIEJyb2FkcGhhc2UoKXtcbiAgICAvKipcbiAgICAqIFRoZSB3b3JsZCB0byBzZWFyY2ggZm9yIGNvbGxpc2lvbnMgaW4uXG4gICAgKiBAcHJvcGVydHkgd29ybGRcbiAgICAqIEB0eXBlIHtXb3JsZH1cbiAgICAqL1xuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSBicm9hZHBoYXNlIHVzZXMgYm91bmRpbmcgYm94ZXMgZm9yIGludGVyc2VjdGlvbiB0ZXN0LCBlbHNlIGl0IHVzZXMgYm91bmRpbmcgc3BoZXJlcy5cbiAgICAgKiBAcHJvcGVydHkgdXNlQm91bmRpbmdCb3hlc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXNlQm91bmRpbmdCb3hlcyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgdGhlIG9iamVjdHMgaW4gdGhlIHdvcmxkIG1vdmVkLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGlydHlcbiAgICAgKi9cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvbGxpc2lvbiBwYWlycyBmcm9tIHRoZSB3b3JsZFxuICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xuICogQHBhcmFtIHtXb3JsZH0gd29ybGQgVGhlIHdvcmxkIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIHtBcnJheX0gcDEgRW1wdHkgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggYm9keSBvYmplY3RzXG4gKiBAcGFyYW0ge0FycmF5fSBwMiBFbXB0eSBhcnJheSB0byBiZSBmaWxsZWQgd2l0aCBib2R5IG9iamVjdHNcbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuY29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCxwMSxwMil7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uUGFpcnMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIEJyb2FkUGhhc2UgY2xhc3MhXCIpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGJvZHkgcGFpciBuZWVkcyB0byBiZSBpbnRlcnNlY3Rpb24gdGVzdGVkIGF0IGFsbC5cbiAqIEBtZXRob2QgbmVlZEJyb2FkcGhhc2VDb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cbnZhciBCcm9hZHBoYXNlX25lZWRCcm9hZHBoYXNlQ29sbGlzaW9uX1NUQVRJQ19PUl9LSU5FTUFUSUMgPSBCb2R5LlNUQVRJQyB8IEJvZHkuS0lORU1BVElDO1xuQnJvYWRwaGFzZS5wcm90b3R5cGUubmVlZEJyb2FkcGhhc2VDb2xsaXNpb24gPSBmdW5jdGlvbihib2R5QSxib2R5Qil7XG5cbiAgICAvLyBDaGVjayBjb2xsaXNpb24gZmlsdGVyIG1hc2tzXG4gICAgaWYoIChib2R5QS5jb2xsaXNpb25GaWx0ZXJHcm91cCAmIGJvZHlCLmNvbGxpc2lvbkZpbHRlck1hc2spPT09MCB8fCAoYm9keUIuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiBib2R5QS5jb2xsaXNpb25GaWx0ZXJNYXNrKT09PTApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdHlwZXNcbiAgICBpZigoKGJvZHlBLnR5cGUgJiBCcm9hZHBoYXNlX25lZWRCcm9hZHBoYXNlQ29sbGlzaW9uX1NUQVRJQ19PUl9LSU5FTUFUSUMpIT09MCB8fCBib2R5QS5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HKSAmJlxuICAgICAgICgoYm9keUIudHlwZSAmIEJyb2FkcGhhc2VfbmVlZEJyb2FkcGhhc2VDb2xsaXNpb25fU1RBVElDX09SX0tJTkVNQVRJQykhPT0wIHx8IGJvZHlCLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpKSB7XG4gICAgICAgIC8vIEJvdGggYm9kaWVzIGFyZSBzdGF0aWMsIGtpbmVtYXRpYyBvciBzbGVlcGluZy4gU2tpcC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgdm9sdW1lcyBvZiB0d28gYm9kaWVzIGludGVyc2VjdC5cbiAqIEBtZXRob2QgaW50ZXJzZWN0aW9uVGVzdFxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHthcnJheX0gcGFpcnMxXG4gKiBAcGFyYW0ge2FycmF5fSBwYWlyczJcbiAgKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLmludGVyc2VjdGlvblRlc3QgPSBmdW5jdGlvbihib2R5QSwgYm9keUIsIHBhaXJzMSwgcGFpcnMyKXtcbiAgICBpZih0aGlzLnVzZUJvdW5kaW5nQm94ZXMpe1xuICAgICAgICB0aGlzLmRvQm91bmRpbmdCb3hCcm9hZHBoYXNlKGJvZHlBLGJvZHlCLHBhaXJzMSxwYWlyczIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZG9Cb3VuZGluZ1NwaGVyZUJyb2FkcGhhc2UoYm9keUEsYm9keUIscGFpcnMxLHBhaXJzMik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgc3BoZXJlcyBvZiB0d28gYm9kaWVzIGFyZSBpbnRlcnNlY3RpbmcuXG4gKiBAbWV0aG9kIGRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczEgYm9keUEgaXMgYXBwZW5kZWQgdG8gdGhpcyBhcnJheSBpZiBpbnRlcnNlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMiBib2R5QiBpcyBhcHBlbmRlZCB0byB0aGlzIGFycmF5IGlmIGludGVyc2VjdGlvblxuICovXG52YXIgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19yID0gbmV3IFZlYzMoKSwgLy8gVGVtcCBvYmplY3RzXG4gICAgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19ub3JtYWwgPSAgbmV3IFZlYzMoKSxcbiAgICBCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX3F1YXQgPSAgbmV3IFF1YXRlcm5pb24oKSxcbiAgICBCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX3JlbHBvcyAgPSAgbmV3IFZlYzMoKTtcbkJyb2FkcGhhc2UucHJvdG90eXBlLmRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlID0gZnVuY3Rpb24oYm9keUEsYm9keUIscGFpcnMxLHBhaXJzMil7XG4gICAgdmFyIHIgPSBCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX3I7XG4gICAgYm9keUIucG9zaXRpb24udnN1Yihib2R5QS5wb3NpdGlvbixyKTtcbiAgICB2YXIgYm91bmRpbmdSYWRpdXNTdW0yID0gTWF0aC5wb3coYm9keUEuYm91bmRpbmdSYWRpdXMgKyBib2R5Qi5ib3VuZGluZ1JhZGl1cywgMik7XG4gICAgdmFyIG5vcm0yID0gci5ub3JtMigpO1xuICAgIGlmKG5vcm0yIDwgYm91bmRpbmdSYWRpdXNTdW0yKXtcbiAgICAgICAgcGFpcnMxLnB1c2goYm9keUEpO1xuICAgICAgICBwYWlyczIucHVzaChib2R5Qik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgYm94ZXMgb2YgdHdvIGJvZGllcyBhcmUgaW50ZXJzZWN0aW5nLlxuICogQG1ldGhvZCBkb0JvdW5kaW5nQm94QnJvYWRwaGFzZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczJcbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuZG9Cb3VuZGluZ0JveEJyb2FkcGhhc2UgPSBmdW5jdGlvbihib2R5QSxib2R5QixwYWlyczEscGFpcnMyKXtcbiAgICBpZihib2R5QS5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICBib2R5QS5jb21wdXRlQUFCQigpO1xuICAgIH1cbiAgICBpZihib2R5Qi5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICBib2R5Qi5jb21wdXRlQUFCQigpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIEFBQkIgLyBBQUJCXG4gICAgaWYoYm9keUEuYWFiYi5vdmVybGFwcyhib2R5Qi5hYWJiKSl7XG4gICAgICAgIHBhaXJzMS5wdXNoKGJvZHlBKTtcbiAgICAgICAgcGFpcnMyLnB1c2goYm9keUIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGUgcGFpcnMgZnJvbSB0aGUgcGFpciBhcnJheXMuXG4gKiBAbWV0aG9kIG1ha2VQYWlyc1VuaXF1ZVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczJcbiAqL1xudmFyIEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3RlbXAgPSB7IGtleXM6W10gfSxcbiAgICBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV9wMSA9IFtdLFxuICAgIEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AyID0gW107XG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5tYWtlUGFpcnNVbmlxdWUgPSBmdW5jdGlvbihwYWlyczEscGFpcnMyKXtcbiAgICB2YXIgdCA9IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3RlbXAsXG4gICAgICAgIHAxID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDEsXG4gICAgICAgIHAyID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDIsXG4gICAgICAgIE4gPSBwYWlyczEubGVuZ3RoO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICBwMVtpXSA9IHBhaXJzMVtpXTtcbiAgICAgICAgcDJbaV0gPSBwYWlyczJbaV07XG4gICAgfVxuXG4gICAgcGFpcnMxLmxlbmd0aCA9IDA7XG4gICAgcGFpcnMyLmxlbmd0aCA9IDA7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBpZDEgPSBwMVtpXS5pZCxcbiAgICAgICAgICAgIGlkMiA9IHAyW2ldLmlkO1xuICAgICAgICB2YXIga2V5ID0gaWQxIDwgaWQyID8gaWQxK1wiLFwiK2lkMiA6ICBpZDIrXCIsXCIraWQxO1xuICAgICAgICB0W2tleV0gPSBpO1xuICAgICAgICB0LmtleXMucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGZvcih2YXIgaT0wOyBpIT09dC5rZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGtleSA9IHQua2V5cy5wb3AoKSxcbiAgICAgICAgICAgIHBhaXJJbmRleCA9IHRba2V5XTtcbiAgICAgICAgcGFpcnMxLnB1c2gocDFbcGFpckluZGV4XSk7XG4gICAgICAgIHBhaXJzMi5wdXNoKHAyW3BhaXJJbmRleF0pO1xuICAgICAgICBkZWxldGUgdFtrZXldO1xuICAgIH1cbn07XG5cbi8qKlxuICogVG8gYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2Fzc2VzXG4gKiBAbWV0aG9kIHNldFdvcmxkXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICovXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5zZXRXb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHNwaGVyZXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCBib3VuZGluZ1NwaGVyZUNoZWNrXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgYnNjX2Rpc3QgPSBuZXcgVmVjMygpO1xuQnJvYWRwaGFzZS5ib3VuZGluZ1NwaGVyZUNoZWNrID0gZnVuY3Rpb24oYm9keUEsYm9keUIpe1xuICAgIHZhciBkaXN0ID0gYnNjX2Rpc3Q7XG4gICAgYm9keUEucG9zaXRpb24udnN1Yihib2R5Qi5wb3NpdGlvbixkaXN0KTtcbiAgICByZXR1cm4gTWF0aC5wb3coYm9keUEuc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBib2R5Qi5zaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cywyKSA+IGRpc3Qubm9ybTIoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gdGhlIEFBQkIuXG4gKiBAbWV0aG9kIGFhYmJRdWVyeVxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24od29ybGQsIGFhYmIsIHJlc3VsdCl7XG4gICAgY29uc29sZS53YXJuKCcuYWFiYlF1ZXJ5IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIEJyb2FkcGhhc2Ugc3ViY2xhc3MuJyk7XG4gICAgcmV0dXJuIFtdO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IEdyaWRCcm9hZHBoYXNlO1xuXG52YXIgQnJvYWRwaGFzZSA9IHJlcXVpcmUoJy4vQnJvYWRwaGFzZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBTaGFwZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9TaGFwZScpO1xuXG4vKipcbiAqIEF4aXMgYWxpZ25lZCB1bmlmb3JtIGdyaWQgYnJvYWRwaGFzZS5cbiAqIEBjbGFzcyBHcmlkQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXG4gKiBAdG9kbyBOZWVkcyBzdXBwb3J0IGZvciBtb3JlIHRoYW4ganVzdCBwbGFuZXMgYW5kIHNwaGVyZXMuXG4gKiBAcGFyYW0ge1ZlYzN9IGFhYmJNaW5cbiAqIEBwYXJhbSB7VmVjM30gYWFiYk1heFxuICogQHBhcmFtIHtOdW1iZXJ9IG54IE51bWJlciBvZiBib3hlcyBhbG9uZyB4XG4gKiBAcGFyYW0ge051bWJlcn0gbnkgTnVtYmVyIG9mIGJveGVzIGFsb25nIHlcbiAqIEBwYXJhbSB7TnVtYmVyfSBueiBOdW1iZXIgb2YgYm94ZXMgYWxvbmcgelxuICovXG5mdW5jdGlvbiBHcmlkQnJvYWRwaGFzZShhYWJiTWluLGFhYmJNYXgsbngsbnksbnope1xuICAgIEJyb2FkcGhhc2UuYXBwbHkodGhpcyk7XG4gICAgdGhpcy5ueCA9IG54IHx8IDEwO1xuICAgIHRoaXMubnkgPSBueSB8fCAxMDtcbiAgICB0aGlzLm56ID0gbnogfHwgMTA7XG4gICAgdGhpcy5hYWJiTWluID0gYWFiYk1pbiB8fCBuZXcgVmVjMygxMDAsMTAwLDEwMCk7XG4gICAgdGhpcy5hYWJiTWF4ID0gYWFiYk1heCB8fCBuZXcgVmVjMygtMTAwLC0xMDAsLTEwMCk7XG5cdHZhciBuYmlucyA9IHRoaXMubnggKiB0aGlzLm55ICogdGhpcy5uejtcblx0aWYgKG5iaW5zIDw9IDApIHtcblx0XHR0aHJvdyBcIkdyaWRCcm9hZHBoYXNlOiBFYWNoIGRpbWVuc2lvbidzIG4gbXVzdCBiZSA+MFwiO1xuXHR9XG4gICAgdGhpcy5iaW5zID0gW107XG5cdHRoaXMuYmluTGVuZ3RocyA9IFtdOyAvL1JhdGhlciB0aGFuIGNvbnRpbnVhbGx5IHJlc2l6aW5nIGFycmF5cyAodGhyYXNoaW5nIHRoZSBtZW1vcnkpLCBqdXN0IHJlY29yZCBsZW5ndGggYW5kIGFsbG93IHRoZW0gdG8gZ3Jvd1xuXHR0aGlzLmJpbnMubGVuZ3RoID0gbmJpbnM7XG5cdHRoaXMuYmluTGVuZ3Rocy5sZW5ndGggPSBuYmlucztcblx0Zm9yICh2YXIgaT0wO2k8bmJpbnM7aSsrKSB7XG5cdFx0dGhpcy5iaW5zW2ldPVtdO1xuXHRcdHRoaXMuYmluTGVuZ3Roc1tpXT0wO1xuXHR9XG59XG5HcmlkQnJvYWRwaGFzZS5wcm90b3R5cGUgPSBuZXcgQnJvYWRwaGFzZSgpO1xuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR3JpZEJyb2FkcGhhc2U7XG5cbi8qKlxuICogR2V0IGFsbCB0aGUgY29sbGlzaW9uIHBhaXJzIGluIHRoZSBwaHlzaWNzIHdvcmxkXG4gKiBAbWV0aG9kIGNvbGxpc2lvblBhaXJzXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczJcbiAqL1xudmFyIEdyaWRCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX2QgPSBuZXcgVmVjMygpO1xudmFyIEdyaWRCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX2JpblBvcyA9IG5ldyBWZWMzKCk7XG5HcmlkQnJvYWRwaGFzZS5wcm90b3R5cGUuY29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCxwYWlyczEscGFpcnMyKXtcbiAgICB2YXIgTiA9IHdvcmxkLm51bU9iamVjdHMoKSxcbiAgICAgICAgYm9kaWVzID0gd29ybGQuYm9kaWVzO1xuXG4gICAgdmFyIG1heCA9IHRoaXMuYWFiYk1heCxcbiAgICAgICAgbWluID0gdGhpcy5hYWJiTWluLFxuICAgICAgICBueCA9IHRoaXMubngsXG4gICAgICAgIG55ID0gdGhpcy5ueSxcbiAgICAgICAgbnogPSB0aGlzLm56O1xuXG5cdHZhciB4c3RlcCA9IG55Km56O1xuXHR2YXIgeXN0ZXAgPSBuejtcblx0dmFyIHpzdGVwID0gMTtcblxuICAgIHZhciB4bWF4ID0gbWF4LngsXG4gICAgICAgIHltYXggPSBtYXgueSxcbiAgICAgICAgem1heCA9IG1heC56LFxuICAgICAgICB4bWluID0gbWluLngsXG4gICAgICAgIHltaW4gPSBtaW4ueSxcbiAgICAgICAgem1pbiA9IG1pbi56O1xuXG4gICAgdmFyIHhtdWx0ID0gbnggLyAoeG1heC14bWluKSxcbiAgICAgICAgeW11bHQgPSBueSAvICh5bWF4LXltaW4pLFxuICAgICAgICB6bXVsdCA9IG56IC8gKHptYXgtem1pbik7XG5cbiAgICB2YXIgYmluc2l6ZVggPSAoeG1heCAtIHhtaW4pIC8gbngsXG4gICAgICAgIGJpbnNpemVZID0gKHltYXggLSB5bWluKSAvIG55LFxuICAgICAgICBiaW5zaXplWiA9ICh6bWF4IC0gem1pbikgLyBuejtcblxuXHR2YXIgYmluUmFkaXVzID0gTWF0aC5zcXJ0KGJpbnNpemVYKmJpbnNpemVYICsgYmluc2l6ZVkqYmluc2l6ZVkgKyBiaW5zaXplWipiaW5zaXplWikgKiAwLjU7XG5cbiAgICB2YXIgdHlwZXMgPSBTaGFwZS50eXBlcztcbiAgICB2YXIgU1BIRVJFID0gICAgICAgICAgICB0eXBlcy5TUEhFUkUsXG4gICAgICAgIFBMQU5FID0gICAgICAgICAgICAgdHlwZXMuUExBTkUsXG4gICAgICAgIEJPWCA9ICAgICAgICAgICAgICAgdHlwZXMuQk9YLFxuICAgICAgICBDT01QT1VORCA9ICAgICAgICAgIHR5cGVzLkNPTVBPVU5ELFxuICAgICAgICBDT05WRVhQT0xZSEVEUk9OID0gIHR5cGVzLkNPTlZFWFBPTFlIRURST047XG5cbiAgICB2YXIgYmlucz10aGlzLmJpbnMsXG5cdFx0YmluTGVuZ3Rocz10aGlzLmJpbkxlbmd0aHMsXG4gICAgICAgIE5iaW5zPXRoaXMuYmlucy5sZW5ndGg7XG5cbiAgICAvLyBSZXNldCBiaW5zXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYmluczsgaSsrKXtcbiAgICAgICAgYmluTGVuZ3Roc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGNlaWwgPSBNYXRoLmNlaWw7XG5cdHZhciBtaW4gPSBNYXRoLm1pbjtcblx0dmFyIG1heCA9IE1hdGgubWF4O1xuXG5cdGZ1bmN0aW9uIGFkZEJveFRvQmlucyh4MCx5MCx6MCx4MSx5MSx6MSxiaSkge1xuXHRcdHZhciB4b2ZmMCA9ICgoeDAgLSB4bWluKSAqIHhtdWx0KXwwLFxuXHRcdFx0eW9mZjAgPSAoKHkwIC0geW1pbikgKiB5bXVsdCl8MCxcblx0XHRcdHpvZmYwID0gKCh6MCAtIHptaW4pICogem11bHQpfDAsXG5cdFx0XHR4b2ZmMSA9IGNlaWwoKHgxIC0geG1pbikgKiB4bXVsdCksXG5cdFx0XHR5b2ZmMSA9IGNlaWwoKHkxIC0geW1pbikgKiB5bXVsdCksXG5cdFx0XHR6b2ZmMSA9IGNlaWwoKHoxIC0gem1pbikgKiB6bXVsdCk7XG5cblx0XHRpZiAoeG9mZjAgPCAwKSB7IHhvZmYwID0gMDsgfSBlbHNlIGlmICh4b2ZmMCA+PSBueCkgeyB4b2ZmMCA9IG54IC0gMTsgfVxuXHRcdGlmICh5b2ZmMCA8IDApIHsgeW9mZjAgPSAwOyB9IGVsc2UgaWYgKHlvZmYwID49IG55KSB7IHlvZmYwID0gbnkgLSAxOyB9XG5cdFx0aWYgKHpvZmYwIDwgMCkgeyB6b2ZmMCA9IDA7IH0gZWxzZSBpZiAoem9mZjAgPj0gbnopIHsgem9mZjAgPSBueiAtIDE7IH1cblx0XHRpZiAoeG9mZjEgPCAwKSB7IHhvZmYxID0gMDsgfSBlbHNlIGlmICh4b2ZmMSA+PSBueCkgeyB4b2ZmMSA9IG54IC0gMTsgfVxuXHRcdGlmICh5b2ZmMSA8IDApIHsgeW9mZjEgPSAwOyB9IGVsc2UgaWYgKHlvZmYxID49IG55KSB7IHlvZmYxID0gbnkgLSAxOyB9XG5cdFx0aWYgKHpvZmYxIDwgMCkgeyB6b2ZmMSA9IDA7IH0gZWxzZSBpZiAoem9mZjEgPj0gbnopIHsgem9mZjEgPSBueiAtIDE7IH1cblxuXHRcdHhvZmYwICo9IHhzdGVwO1xuXHRcdHlvZmYwICo9IHlzdGVwO1xuXHRcdHpvZmYwICo9IHpzdGVwO1xuXHRcdHhvZmYxICo9IHhzdGVwO1xuXHRcdHlvZmYxICo9IHlzdGVwO1xuXHRcdHpvZmYxICo9IHpzdGVwO1xuXG5cdFx0Zm9yICh2YXIgeG9mZiA9IHhvZmYwOyB4b2ZmIDw9IHhvZmYxOyB4b2ZmICs9IHhzdGVwKSB7XG5cdFx0XHRmb3IgKHZhciB5b2ZmID0geW9mZjA7IHlvZmYgPD0geW9mZjE7IHlvZmYgKz0geXN0ZXApIHtcblx0XHRcdFx0Zm9yICh2YXIgem9mZiA9IHpvZmYwOyB6b2ZmIDw9IHpvZmYxOyB6b2ZmICs9IHpzdGVwKSB7XG5cdFx0XHRcdFx0dmFyIGlkeCA9IHhvZmYreW9mZit6b2ZmO1xuXHRcdFx0XHRcdGJpbnNbaWR4XVtiaW5MZW5ndGhzW2lkeF0rK10gPSBiaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG4gICAgLy8gUHV0IGFsbCBib2RpZXMgaW50byB0aGUgYmluc1xuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICB2YXIgc2kgPSBiaS5zaGFwZTtcblxuICAgICAgICBzd2l0Y2goc2kudHlwZSl7XG4gICAgICAgIGNhc2UgU1BIRVJFOlxuICAgICAgICAgICAgLy8gUHV0IGluIGJpblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgb3ZlcmxhcCB3aXRoIG90aGVyIGJpbnNcbiAgICAgICAgICAgIHZhciB4ID0gYmkucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICB5ID0gYmkucG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICB6ID0gYmkucG9zaXRpb24uejtcbiAgICAgICAgICAgIHZhciByID0gc2kucmFkaXVzO1xuXG5cdFx0XHRhZGRCb3hUb0JpbnMoeC1yLCB5LXIsIHotciwgeCtyLCB5K3IsIHorciwgYmkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQTEFORTpcbiAgICAgICAgICAgIGlmKHNpLndvcmxkTm9ybWFsTmVlZHNVcGRhdGUpe1xuICAgICAgICAgICAgICAgIHNpLmNvbXB1dGVXb3JsZE5vcm1hbChiaS5xdWF0ZXJuaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwbGFuZU5vcm1hbCA9IHNpLndvcmxkTm9ybWFsO1xuXG5cdFx0XHQvL1JlbGF0aXZlIHBvc2l0aW9uIGZyb20gb3JpZ2luIG9mIHBsYW5lIG9iamVjdCB0byB0aGUgZmlyc3QgYmluXG5cdFx0XHQvL0luY3JlbWVudGVkIGFzIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgYmluc1xuXHRcdFx0dmFyIHhyZXNldCA9IHhtaW4gKyBiaW5zaXplWCowLjUgLSBiaS5wb3NpdGlvbi54LFxuXHRcdFx0XHR5cmVzZXQgPSB5bWluICsgYmluc2l6ZVkqMC41IC0gYmkucG9zaXRpb24ueSxcblx0XHRcdFx0enJlc2V0ID0gem1pbiArIGJpbnNpemVaKjAuNSAtIGJpLnBvc2l0aW9uLno7XG5cbiAgICAgICAgICAgIHZhciBkID0gR3JpZEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfZDtcblx0XHRcdGQuc2V0KHhyZXNldCwgeXJlc2V0LCB6cmVzZXQpO1xuXG5cdFx0XHRmb3IgKHZhciB4aSA9IDAsIHhvZmYgPSAwOyB4aSAhPT0gbng7IHhpKyssIHhvZmYgKz0geHN0ZXAsIGQueSA9IHlyZXNldCwgZC54ICs9IGJpbnNpemVYKSB7XG5cdFx0XHRcdGZvciAodmFyIHlpID0gMCwgeW9mZiA9IDA7IHlpICE9PSBueTsgeWkrKywgeW9mZiArPSB5c3RlcCwgZC56ID0genJlc2V0LCBkLnkgKz0gYmluc2l6ZVkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciB6aSA9IDAsIHpvZmYgPSAwOyB6aSAhPT0gbno7IHppKyssIHpvZmYgKz0genN0ZXAsIGQueiArPSBiaW5zaXplWikge1xuXHRcdFx0XHRcdFx0aWYgKGQuZG90KHBsYW5lTm9ybWFsKSA8IGJpblJhZGl1cykge1xuXHRcdFx0XHRcdFx0XHR2YXIgaWR4ID0geG9mZiArIHlvZmYgKyB6b2ZmO1xuXHRcdFx0XHRcdFx0XHRiaW5zW2lkeF1bYmluTGVuZ3Roc1tpZHhdKytdID0gYmk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuXHRcdFx0aWYgKGJpLmFhYmJOZWVkc1VwZGF0ZSkge1xuXHRcdFx0XHRiaS5jb21wdXRlQUFCQigpO1xuXHRcdFx0fVxuXG5cdFx0XHRhZGRCb3hUb0JpbnMoXG5cdFx0XHRcdGJpLmFhYmIubG93ZXJCb3VuZC54LFxuXHRcdFx0XHRiaS5hYWJiLmxvd2VyQm91bmQueSxcblx0XHRcdFx0YmkuYWFiYi5sb3dlckJvdW5kLnosXG5cdFx0XHRcdGJpLmFhYmIudXBwZXJCb3VuZC54LFxuXHRcdFx0XHRiaS5hYWJiLnVwcGVyQm91bmQueSxcblx0XHRcdFx0YmkuYWFiYi51cHBlckJvdW5kLnosXG5cdFx0XHRcdGJpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZWFjaCBiaW5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU5iaW5zOyBpKyspe1xuXHRcdHZhciBiaW5MZW5ndGggPSBiaW5MZW5ndGhzW2ldO1xuXHRcdC8vU2tpcCBiaW5zIHdpdGggbm8gcG90ZW50aWFsIGNvbGxpc2lvbnNcblx0XHRpZiAoYmluTGVuZ3RoID4gMSkge1xuXHRcdFx0dmFyIGJpbiA9IGJpbnNbaV07XG5cblx0XHRcdC8vIERvIE5eMiBicm9hZHBoYXNlIGluc2lkZVxuXHRcdFx0Zm9yKHZhciB4aT0wOyB4aSE9PWJpbkxlbmd0aDsgeGkrKyl7XG5cdFx0XHRcdHZhciBiaSA9IGJpblt4aV07XG5cdFx0XHRcdGZvcih2YXIgeWk9MDsgeWkhPT14aTsgeWkrKyl7XG5cdFx0XHRcdFx0dmFyIGJqID0gYmluW3lpXTtcblx0XHRcdFx0XHRpZih0aGlzLm5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uKGJpLGJqKSl7XG5cdFx0XHRcdFx0XHR0aGlzLmludGVyc2VjdGlvblRlc3QoYmksYmoscGFpcnMxLHBhaXJzMik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuICAgIH1cblxuLy9cdGZvciAodmFyIHppID0gMCwgem9mZj0wOyB6aSA8IG56OyB6aSsrLCB6b2ZmKz0genN0ZXApIHtcbi8vXHRcdGNvbnNvbGUubG9nKFwibGF5ZXIgXCIremkpO1xuLy9cdFx0Zm9yICh2YXIgeWkgPSAwLCB5b2ZmPTA7IHlpIDwgbnk7IHlpKyssIHlvZmYgKz0geXN0ZXApIHtcbi8vXHRcdFx0dmFyIHJvdyA9ICcnO1xuLy9cdFx0XHRmb3IgKHZhciB4aSA9IDAsIHhvZmY9MDsgeGkgPCBueDsgeGkrKywgeG9mZiArPSB4c3RlcCkge1xuLy9cdFx0XHRcdHZhciBpZHggPSB4b2ZmICsgeW9mZiArIHpvZmY7XG4vL1x0XHRcdFx0cm93ICs9ICcgJyArIGJpbkxlbmd0aHNbaWR4XTtcbi8vXHRcdFx0fVxuLy9cdFx0XHRjb25zb2xlLmxvZyhyb3cpO1xuLy9cdFx0fVxuLy9cdH1cblxuICAgIHRoaXMubWFrZVBhaXJzVW5pcXVlKHBhaXJzMSxwYWlyczIpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gTmFpdmVCcm9hZHBoYXNlO1xuXG52YXIgQnJvYWRwaGFzZSA9IHJlcXVpcmUoJy4vQnJvYWRwaGFzZScpO1xudmFyIEFBQkIgPSByZXF1aXJlKCcuL0FBQkInKTtcblxuLyoqXG4gKiBOYWl2ZSBicm9hZHBoYXNlIGltcGxlbWVudGF0aW9uLCB1c2VkIGluIGxhY2sgb2YgYmV0dGVyIG9uZXMuXG4gKiBAY2xhc3MgTmFpdmVCcm9hZHBoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjcmlwdGlvbiBUaGUgbmFpdmUgYnJvYWRwaGFzZSBsb29rcyBhdCBhbGwgcG9zc2libGUgcGFpcnMgd2l0aG91dCByZXN0cmljdGlvbiwgdGhlcmVmb3JlIGl0IGhhcyBjb21wbGV4aXR5IE5eMiAod2hpY2ggaXMgYmFkKVxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxuICovXG5mdW5jdGlvbiBOYWl2ZUJyb2FkcGhhc2UoKXtcbiAgICBCcm9hZHBoYXNlLmFwcGx5KHRoaXMpO1xufVxuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZSA9IG5ldyBCcm9hZHBoYXNlKCk7XG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTmFpdmVCcm9hZHBoYXNlO1xuXG4vKipcbiAqIEdldCBhbGwgdGhlIGNvbGxpc2lvbiBwYWlycyBpbiB0aGUgcGh5c2ljcyB3b3JsZFxuICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMyXG4gKi9cbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuY29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCxwYWlyczEscGFpcnMyKXtcbiAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICBuID0gYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgaSxqLGJpLGJqO1xuXG4gICAgLy8gTmFpdmUgTl4yIGZ0dyFcbiAgICBmb3IoaT0wOyBpIT09bjsgaSsrKXtcbiAgICAgICAgZm9yKGo9MDsgaiE9PWk7IGorKyl7XG5cbiAgICAgICAgICAgIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgYmogPSBib2RpZXNbal07XG5cbiAgICAgICAgICAgIGlmKCF0aGlzLm5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uKGJpLGJqKSl7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uVGVzdChiaSxiaixwYWlyczEscGFpcnMyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciB0bXBBQUJCID0gbmV3IEFBQkIoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxuICogQG1ldGhvZCBhYWJiUXVlcnlcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbih3b3JsZCwgYWFiYiwgcmVzdWx0KXtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgd29ybGQuYm9kaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSB3b3JsZC5ib2RpZXNbaV07XG5cbiAgICAgICAgaWYoYi5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICAgICAgYi5jb21wdXRlQUFCQigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVWdseSBoYWNrIHVudGlsIEJvZHkgZ2V0cyBhYWJiXG4gICAgICAgIGlmKGIuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gT2JqZWN0Q29sbGlzaW9uTWF0cml4O1xuXG4vKipcbiAqIFJlY29yZHMgd2hhdCBvYmplY3RzIGFyZSBjb2xsaWRpbmcgd2l0aCBlYWNoIG90aGVyXG4gKiBAY2xhc3MgT2JqZWN0Q29sbGlzaW9uTWF0cml4XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gT2JqZWN0Q29sbGlzaW9uTWF0cml4KCkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hdHJpeCBzdG9yYWdlXG4gICAgICogQHByb3BlcnR5IG1hdHJpeFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cdHRoaXMubWF0cml4ID0ge307XG59XG5cbi8qKlxuICogQG1ldGhvZCBnZXRcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSBqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbk9iamVjdENvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaSwgaikge1xuXHRpID0gaS5pZDtcblx0aiA9IGouaWQ7XG4gICAgaWYgKGogPiBpKSB7XG4gICAgICAgIHZhciB0ZW1wID0gajtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIGkgPSB0ZW1wO1xuICAgIH1cblx0cmV0dXJuIGkrJy0nK2ogaW4gdGhpcy5tYXRyaXg7XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKi9cbk9iamVjdENvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaSwgaiwgdmFsdWUpIHtcblx0aSA9IGkuaWQ7XG5cdGogPSBqLmlkO1xuICAgIGlmIChqID4gaSkge1xuICAgICAgICB2YXIgdGVtcCA9IGo7XG4gICAgICAgIGogPSBpO1xuICAgICAgICBpID0gdGVtcDtcblx0fVxuXHRpZiAodmFsdWUpIHtcblx0XHR0aGlzLm1hdHJpeFtpKyctJytqXSA9IHRydWU7XG5cdH1cblx0ZWxzZSB7XG5cdFx0ZGVsZXRlIHRoaXMubWF0cml4W2krJy0nK2pdO1xuXHR9XG59O1xuXG4vKipcbiAqIEVtcHR5IHRoZSBtYXRyaXhcbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuT2JqZWN0Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLm1hdHJpeCA9IHt9O1xufTtcblxuLyoqXG4gKiBTZXQgbWF4IG51bWJlciBvZiBvYmplY3RzXG4gKiBAbWV0aG9kIHNldE51bU9iamVjdHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKi9cbk9iamVjdENvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuc2V0TnVtT2JqZWN0cyA9IGZ1bmN0aW9uKG4pIHtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFJheTtcblxudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gcmVxdWlyZSgnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcbnZhciBDb252ZXhQb2x5aGVkcm9uID0gcmVxdWlyZSgnLi4vc2hhcGVzL0NvbnZleFBvbHloZWRyb24nKTtcbnZhciBCb3ggPSByZXF1aXJlKCcuLi9zaGFwZXMvQm94Jyk7XG52YXIgUmF5Y2FzdFJlc3VsdCA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0Jyk7XG52YXIgU2hhcGUgPSByZXF1aXJlKCcuLi9zaGFwZXMvU2hhcGUnKTtcbnZhciBBQUJCID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL0FBQkInKTtcblxuLyoqXG4gKiBBIGxpbmUgaW4gM0Qgc3BhY2UgdGhhdCBpbnRlcnNlY3RzIGJvZGllcyBhbmQgcmV0dXJuIHBvaW50cy5cbiAqIEBjbGFzcyBSYXlcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0ge1ZlYzN9IHRvXG4gKi9cbmZ1bmN0aW9uIFJheShmcm9tLCB0byl7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBmcm9tXG4gICAgICovXG4gICAgdGhpcy5mcm9tID0gZnJvbSA/IGZyb20uY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHRvXG4gICAgICovXG4gICAgdGhpcy50byA9IHRvID8gdG8uY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gX2RpcmVjdGlvblxuICAgICAqL1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlY2lzaW9uIG9mIHRoZSByYXkuIFVzZWQgd2hlbiBjaGVja2luZyBwYXJhbGxlbGl0eSBldGMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHByZWNpc2lvblxuICAgICAqL1xuICAgIHRoaXMucHJlY2lzaW9uID0gMC4wMDAxO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdGhlIFJheSB0byB0YWtlIC5jb2xsaXNpb25SZXNwb25zZSBmbGFncyBpbnRvIGFjY291bnQgb24gYm9kaWVzIGFuZCBzaGFwZXMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjaGVja0NvbGxpc2lvblJlc3BvbnNlXG4gICAgICovXG4gICAgdGhpcy5jaGVja0NvbGxpc2lvblJlc3BvbnNlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgcmF5IHNraXBzIGFueSBoaXRzIHdpdGggbm9ybWFsLmRvdChyYXlEaXJlY3Rpb24pIDwgMC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNraXBCYWNrZmFjZXNcbiAgICAgKi9cbiAgICB0aGlzLnNraXBCYWNrZmFjZXMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJNYXNrXG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2sgPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJHcm91cFxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVyc2VjdGlvbiBtb2RlLiBTaG91bGQgYmUgUmF5LkFOWSwgUmF5LkFMTCBvciBSYXkuQ0xPU0VTVC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW9kZVxuICAgICAqL1xuICAgIHRoaXMubW9kZSA9IFJheS5BTlk7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHJlc3VsdCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGJlIHNldCB0byB0cnVlIGR1cmluZyBpbnRlcnNlY3RXb3JsZCgpIGlmIHRoZSByYXkgaGl0IGFueXRoaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaGFzSGl0XG4gICAgICovXG4gICAgdGhpcy5oYXNIaXQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQsIHVzZXItcHJvdmlkZWQgcmVzdWx0IGNhbGxiYWNrLiBXaWxsIGJlIHVzZWQgaWYgbW9kZSBpcyBSYXkuQUxMLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgdGhpcy5jYWxsYmFjayA9IGZ1bmN0aW9uKHJlc3VsdCl7fTtcbn1cblJheS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYXk7XG5cblJheS5DTE9TRVNUID0gMTtcblJheS5BTlkgPSAyO1xuUmF5LkFMTCA9IDQ7XG5cbnZhciB0bXBBQUJCID0gbmV3IEFBQkIoKTtcbnZhciB0bXBBcnJheSA9IFtdO1xuXG4vKipcbiAqIERvIGl0ZXJzZWN0aW9uIGFnYWluc3QgYWxsIGJvZGllcyBpbiB0aGUgZ2l2ZW4gV29ybGQuXG4gKiBAbWV0aG9kIGludGVyc2VjdFdvcmxkXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmF5IGhpdCBhbnl0aGluZywgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFdvcmxkID0gZnVuY3Rpb24gKHdvcmxkLCBvcHRpb25zKSB7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IFJheS5BTlk7XG4gICAgdGhpcy5yZXN1bHQgPSBvcHRpb25zLnJlc3VsdCB8fCBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xuICAgIHRoaXMuc2tpcEJhY2tmYWNlcyA9ICEhb3B0aW9ucy5za2lwQmFja2ZhY2VzO1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IHR5cGVvZihvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2spICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayA6IC0xO1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2Yob3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCA6IC0xO1xuICAgIGlmKG9wdGlvbnMuZnJvbSl7XG4gICAgICAgIHRoaXMuZnJvbS5jb3B5KG9wdGlvbnMuZnJvbSk7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMudG8pe1xuICAgICAgICB0aGlzLnRvLmNvcHkob3B0aW9ucy50byk7XG4gICAgfVxuICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCl7fTtcbiAgICB0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXG4gICAgdGhpcy5yZXN1bHQucmVzZXQoKTtcbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oKTtcblxuICAgIHRoaXMuZ2V0QUFCQih0bXBBQUJCKTtcbiAgICB0bXBBcnJheS5sZW5ndGggPSAwO1xuICAgIHdvcmxkLmJyb2FkcGhhc2UuYWFiYlF1ZXJ5KHdvcmxkLCB0bXBBQUJCLCB0bXBBcnJheSk7XG4gICAgdGhpcy5pbnRlcnNlY3RCb2RpZXModG1wQXJyYXkpO1xuXG4gICAgcmV0dXJuIHRoaXMuaGFzSGl0O1xufTtcblxudmFyIHYxID0gbmV3IFZlYzMoKSxcbiAgICB2MiA9IG5ldyBWZWMzKCk7XG5cbi8qXG4gKiBBcyBwZXIgXCJCYXJ5Y2VudHJpYyBUZWNobmlxdWVcIiBhcyBuYW1lZCBoZXJlIGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWwgQnV0IHdpdGhvdXQgdGhlIGRpdmlzaW9uXG4gKi9cblJheS5wb2ludEluVHJpYW5nbGUgPSBwb2ludEluVHJpYW5nbGU7XG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUocCwgYSwgYiwgYykge1xuICAgIGMudnN1YihhLHYwKTtcbiAgICBiLnZzdWIoYSx2MSk7XG4gICAgcC52c3ViKGEsdjIpO1xuXG4gICAgdmFyIGRvdDAwID0gdjAuZG90KCB2MCApO1xuICAgIHZhciBkb3QwMSA9IHYwLmRvdCggdjEgKTtcbiAgICB2YXIgZG90MDIgPSB2MC5kb3QoIHYyICk7XG4gICAgdmFyIGRvdDExID0gdjEuZG90KCB2MSApO1xuICAgIHZhciBkb3QxMiA9IHYxLmRvdCggdjIgKTtcblxuICAgIHZhciB1LHY7XG5cbiAgICByZXR1cm4gICggKHUgPSBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMikgPj0gMCApICYmXG4gICAgICAgICAgICAoICh2ID0gZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIpID49IDAgKSAmJlxuICAgICAgICAgICAgKCB1ICsgdiA8ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKSApO1xufVxuXG4vKipcbiAqIFNob290IGEgcmF5IGF0IGEgYm9keSwgZ2V0IGJhY2sgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdC5cbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm9keVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtSYXljYXN0UmVzdWx0fSBbcmVzdWx0XSBEZXByZWNhdGVkIC0gc2V0IHRoZSByZXN1bHQgcHJvcGVydHkgb2YgdGhlIFJheSBpbnN0ZWFkLlxuICovXG52YXIgaW50ZXJzZWN0Qm9keV94aSA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0Qm9keV9xaSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZHkgPSBmdW5jdGlvbiAoYm9keSwgcmVzdWx0KSB7XG4gICAgaWYocmVzdWx0KXtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigpO1xuICAgIH1cbiAgICB2YXIgY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZTtcblxuICAgIGlmKGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgJiYgIWJvZHkuY29sbGlzaW9uUmVzcG9uc2Upe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoKHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiBib2R5LmNvbGxpc2lvbkZpbHRlck1hc2spPT09MCB8fCAoYm9keS5jb2xsaXNpb25GaWx0ZXJHcm91cCAmIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayk9PT0wKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB4aSA9IGludGVyc2VjdEJvZHlfeGk7XG4gICAgdmFyIHFpID0gaW50ZXJzZWN0Qm9keV9xaTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBOID0gYm9keS5zaGFwZXMubGVuZ3RoOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgIHZhciBzaGFwZSA9IGJvZHkuc2hhcGVzW2ldO1xuXG4gICAgICAgIGlmKGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgJiYgIXNoYXBlLmNvbGxpc2lvblJlc3BvbnNlKXtcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwXG4gICAgICAgIH1cblxuICAgICAgICBib2R5LnF1YXRlcm5pb24ubXVsdChib2R5LnNoYXBlT3JpZW50YXRpb25zW2ldLCBxaSk7XG4gICAgICAgIGJvZHkucXVhdGVybmlvbi52bXVsdChib2R5LnNoYXBlT2Zmc2V0c1tpXSwgeGkpO1xuICAgICAgICB4aS52YWRkKGJvZHkucG9zaXRpb24sIHhpKTtcblxuICAgICAgICB0aGlzLmludGVyc2VjdFNoYXBlKFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBxaSxcbiAgICAgICAgICAgIHhpLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICApO1xuXG4gICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdEJvZGllc1xuICogQHBhcmFtIHtBcnJheX0gYm9kaWVzIEFuIGFycmF5IG9mIEJvZHkgb2JqZWN0cy5cbiAqIEBwYXJhbSB7UmF5Y2FzdFJlc3VsdH0gW3Jlc3VsdF0gRGVwcmVjYXRlZFxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZGllcyA9IGZ1bmN0aW9uIChib2RpZXMsIHJlc3VsdCkge1xuICAgIGlmKHJlc3VsdCl7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oKTtcbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBib2RpZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuX3Nob3VsZFN0b3AgJiYgaSA8IGw7IGkgKysgKSB7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0Qm9keShib2RpZXNbaV0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgX2RpcmVjdGlvbiB2ZWN0b3IuXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBfdXBkYXRlRGlyZWN0aW9uXG4gKi9cblJheS5wcm90b3R5cGUuX3VwZGF0ZURpcmVjdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy50by52c3ViKHRoaXMuZnJvbSwgdGhpcy5fZGlyZWN0aW9uKTtcbiAgICB0aGlzLl9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0U2hhcGVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0ge1ZlYzN9IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG5cblxuICAgIC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlXG4gICAgdmFyIGRpc3RhbmNlID0gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uKGZyb20sIHRoaXMuX2RpcmVjdGlvbiwgcG9zaXRpb24pO1xuICAgIGlmICggZGlzdGFuY2UgPiBzaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cyApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnRlcnNlY3RNZXRob2QgPSB0aGlzW3NoYXBlLnR5cGVdO1xuICAgIGlmKGludGVyc2VjdE1ldGhvZCl7XG4gICAgICAgIGludGVyc2VjdE1ldGhvZC5jYWxsKHRoaXMsIHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgc2hhcGUpO1xuICAgIH1cbn07XG5cbnZhciB2ZWN0b3IgPSBuZXcgVmVjMygpO1xudmFyIG5vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0UG9pbnQgPSBuZXcgVmVjMygpO1xuXG52YXIgYSA9IG5ldyBWZWMzKCk7XG52YXIgYiA9IG5ldyBWZWMzKCk7XG52YXIgYyA9IG5ldyBWZWMzKCk7XG52YXIgZCA9IG5ldyBWZWMzKCk7XG5cbnZhciB0bXBSYXljYXN0UmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdEJveFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICogQHBhcmFtICB7VmVjM30gcG9zaXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RCb3ggPSBmdW5jdGlvbihzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHksIHJlcG9ydGVkU2hhcGUpe1xuICAgIHJldHVybiB0aGlzLmludGVyc2VjdENvbnZleChzaGFwZS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHF1YXQsIHBvc2l0aW9uLCBib2R5LCByZXBvcnRlZFNoYXBlKTtcbn07XG5SYXkucHJvdG90eXBlW1NoYXBlLnR5cGVzLkJPWF0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdEJveDtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFBsYW5lXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0gIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFBsYW5lID0gZnVuY3Rpb24oc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5LCByZXBvcnRlZFNoYXBlKXtcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb247XG5cbiAgICAvLyBHZXQgcGxhbmUgbm9ybWFsXG4gICAgdmFyIHdvcmxkTm9ybWFsID0gbmV3IFZlYzMoMCwgMCwgMSk7XG4gICAgcXVhdC52bXVsdCh3b3JsZE5vcm1hbCwgd29ybGROb3JtYWwpO1xuXG4gICAgdmFyIGxlbiA9IG5ldyBWZWMzKCk7XG4gICAgZnJvbS52c3ViKHBvc2l0aW9uLCBsZW4pO1xuICAgIHZhciBwbGFuZVRvRnJvbSA9IGxlbi5kb3Qod29ybGROb3JtYWwpO1xuICAgIHRvLnZzdWIocG9zaXRpb24sIGxlbik7XG4gICAgdmFyIHBsYW5lVG9UbyA9IGxlbi5kb3Qod29ybGROb3JtYWwpO1xuXG4gICAgaWYocGxhbmVUb0Zyb20gKiBwbGFuZVRvVG8gPiAwKXtcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBhcmUgb24gdGhlIHNhbWUgc2lkZSBvZiB0aGUgcGxhbmUuLi4gYmFpbCBvdXRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKGZyb20uZGlzdGFuY2VUbyh0bykgPCBwbGFuZVRvRnJvbSl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbl9kb3RfZGlyID0gd29ybGROb3JtYWwuZG90KGRpcmVjdGlvbik7XG5cbiAgICBpZiAoTWF0aC5hYnMobl9kb3RfZGlyKSA8IHRoaXMucHJlY2lzaW9uKSB7XG4gICAgICAgIC8vIE5vIGludGVyc2VjdGlvblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBsYW5lUG9pbnRUb0Zyb20gPSBuZXcgVmVjMygpO1xuICAgIHZhciBkaXJfc2NhbGVkX3dpdGhfdCA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIGhpdFBvaW50V29ybGQgPSBuZXcgVmVjMygpO1xuXG4gICAgZnJvbS52c3ViKHBvc2l0aW9uLCBwbGFuZVBvaW50VG9Gcm9tKTtcbiAgICB2YXIgdCA9IC13b3JsZE5vcm1hbC5kb3QocGxhbmVQb2ludFRvRnJvbSkgLyBuX2RvdF9kaXI7XG4gICAgZGlyZWN0aW9uLnNjYWxlKHQsIGRpcl9zY2FsZWRfd2l0aF90KTtcbiAgICBmcm9tLnZhZGQoZGlyX3NjYWxlZF93aXRoX3QsIGhpdFBvaW50V29ybGQpO1xuXG4gICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24od29ybGROb3JtYWwsIGhpdFBvaW50V29ybGQsIHJlcG9ydGVkU2hhcGUsIGJvZHksIC0xKTtcbn07XG5SYXkucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBMQU5FXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0UGxhbmU7XG5cbi8qKlxuICogR2V0IHRoZSB3b3JsZCBBQUJCIG9mIHRoZSByYXkuXG4gKiBAbWV0aG9kIGdldEFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuUmF5LnByb3RvdHlwZS5nZXRBQUJCID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgIHJlc3VsdC5sb3dlckJvdW5kLnggPSBNYXRoLm1pbih0by54LCBmcm9tLngpO1xuICAgIHJlc3VsdC5sb3dlckJvdW5kLnkgPSBNYXRoLm1pbih0by55LCBmcm9tLnkpO1xuICAgIHJlc3VsdC5sb3dlckJvdW5kLnogPSBNYXRoLm1pbih0by56LCBmcm9tLnopO1xuICAgIHJlc3VsdC51cHBlckJvdW5kLnggPSBNYXRoLm1heCh0by54LCBmcm9tLngpO1xuICAgIHJlc3VsdC51cHBlckJvdW5kLnkgPSBNYXRoLm1heCh0by55LCBmcm9tLnkpO1xuICAgIHJlc3VsdC51cHBlckJvdW5kLnogPSBNYXRoLm1heCh0by56LCBmcm9tLnopO1xufTtcblxudmFyIGludGVyc2VjdENvbnZleE9wdGlvbnMgPSB7XG4gICAgZmFjZUxpc3Q6IFswXVxufTtcbnZhciB3b3JsZFBpbGxhck9mZnNldCA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfbG9jYWxSYXkgPSBuZXcgUmF5KCk7XG52YXIgaW50ZXJzZWN0SGVpZ2h0ZmllbGRfaW5kZXggPSBbXTtcbnZhciBpbnRlcnNlY3RIZWlnaHRmaWVsZF9taW5NYXggPSBbXTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdEhlaWdodGZpZWxkXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0gIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEhlaWdodGZpZWxkID0gZnVuY3Rpb24oc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5LCByZXBvcnRlZFNoYXBlKXtcbiAgICB2YXIgZGF0YSA9IHNoYXBlLmRhdGEsXG4gICAgICAgIHcgPSBzaGFwZS5lbGVtZW50U2l6ZTtcblxuICAgIC8vIENvbnZlcnQgdGhlIHJheSB0byBsb2NhbCBoZWlnaHRmaWVsZCBjb29yZGluYXRlc1xuICAgIHZhciBsb2NhbFJheSA9IGludGVyc2VjdEhlaWdodGZpZWxkX2xvY2FsUmF5OyAvL25ldyBSYXkodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICBsb2NhbFJheS5mcm9tLmNvcHkodGhpcy5mcm9tKTtcbiAgICBsb2NhbFJheS50by5jb3B5KHRoaXMudG8pO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgbG9jYWxSYXkuZnJvbSwgbG9jYWxSYXkuZnJvbSk7XG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBsb2NhbFJheS50bywgbG9jYWxSYXkudG8pO1xuICAgIGxvY2FsUmF5Ll91cGRhdGVEaXJlY3Rpb24oKTtcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnRzIHRvIHRlc3QgYWdhaW5zdFxuICAgIHZhciBpbmRleCA9IGludGVyc2VjdEhlaWdodGZpZWxkX2luZGV4O1xuICAgIHZhciBpTWluWCwgaU1pblksIGlNYXhYLCBpTWF4WTtcblxuICAgIC8vIFNldCB0byBtYXhcbiAgICBpTWluWCA9IGlNaW5ZID0gMDtcbiAgICBpTWF4WCA9IGlNYXhZID0gc2hhcGUuZGF0YS5sZW5ndGggLSAxO1xuXG4gICAgdmFyIGFhYmIgPSBuZXcgQUFCQigpO1xuICAgIGxvY2FsUmF5LmdldEFBQkIoYWFiYik7XG5cbiAgICBzaGFwZS5nZXRJbmRleE9mUG9zaXRpb24oYWFiYi5sb3dlckJvdW5kLngsIGFhYmIubG93ZXJCb3VuZC55LCBpbmRleCwgdHJ1ZSk7XG4gICAgaU1pblggPSBNYXRoLm1heChpTWluWCwgaW5kZXhbMF0pO1xuICAgIGlNaW5ZID0gTWF0aC5tYXgoaU1pblksIGluZGV4WzFdKTtcbiAgICBzaGFwZS5nZXRJbmRleE9mUG9zaXRpb24oYWFiYi51cHBlckJvdW5kLngsIGFhYmIudXBwZXJCb3VuZC55LCBpbmRleCwgdHJ1ZSk7XG4gICAgaU1heFggPSBNYXRoLm1pbihpTWF4WCwgaW5kZXhbMF0gKyAxKTtcbiAgICBpTWF4WSA9IE1hdGgubWluKGlNYXhZLCBpbmRleFsxXSArIDEpO1xuXG4gICAgZm9yKHZhciBpID0gaU1pblg7IGkgPCBpTWF4WDsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqID0gaU1pblk7IGogPCBpTWF4WTsgaisrKXtcblxuICAgICAgICAgICAgaWYodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3Ape1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2hhcGUuZ2V0QWFiYkF0SW5kZXgoaSwgaiwgYWFiYik7XG4gICAgICAgICAgICBpZighYWFiYi5vdmVybGFwc1JheShsb2NhbFJheSkpe1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMb3dlciB0cmlhbmdsZVxuICAgICAgICAgICAgc2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgZmFsc2UpO1xuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBzaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0Q29udmV4KHNoYXBlLnBpbGxhckNvbnZleCwgcXVhdCwgd29ybGRQaWxsYXJPZmZzZXQsIGJvZHksIHJlcG9ydGVkU2hhcGUsIGludGVyc2VjdENvbnZleE9wdGlvbnMpO1xuXG4gICAgICAgICAgICBpZih0aGlzLnJlc3VsdC5fc2hvdWxkU3RvcCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcHBlciB0cmlhbmdsZVxuICAgICAgICAgICAgc2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgdHJ1ZSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHF1YXQsIHNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3RDb252ZXgoc2hhcGUucGlsbGFyQ29udmV4LCBxdWF0LCB3b3JsZFBpbGxhck9mZnNldCwgYm9keSwgcmVwb3J0ZWRTaGFwZSwgaW50ZXJzZWN0Q29udmV4T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5IRUlHSFRGSUVMRF0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdEhlaWdodGZpZWxkO1xuXG52YXIgUmF5X2ludGVyc2VjdFNwaGVyZV9pbnRlcnNlY3Rpb25Qb2ludCA9IG5ldyBWZWMzKCk7XG52YXIgUmF5X2ludGVyc2VjdFNwaGVyZV9ub3JtYWwgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0U3BoZXJlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0gIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFNwaGVyZSA9IGZ1bmN0aW9uKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSwgcmVwb3J0ZWRTaGFwZSl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb20sXG4gICAgICAgIHRvID0gdGhpcy50byxcbiAgICAgICAgciA9IHNoYXBlLnJhZGl1cztcblxuICAgIHZhciBhID0gTWF0aC5wb3codG8ueCAtIGZyb20ueCwgMikgKyBNYXRoLnBvdyh0by55IC0gZnJvbS55LCAyKSArIE1hdGgucG93KHRvLnogLSBmcm9tLnosIDIpO1xuICAgIHZhciBiID0gMiAqICgodG8ueCAtIGZyb20ueCkgKiAoZnJvbS54IC0gcG9zaXRpb24ueCkgKyAodG8ueSAtIGZyb20ueSkgKiAoZnJvbS55IC0gcG9zaXRpb24ueSkgKyAodG8ueiAtIGZyb20ueikgKiAoZnJvbS56IC0gcG9zaXRpb24ueikpO1xuICAgIHZhciBjID0gTWF0aC5wb3coZnJvbS54IC0gcG9zaXRpb24ueCwgMikgKyBNYXRoLnBvdyhmcm9tLnkgLSBwb3NpdGlvbi55LCAyKSArIE1hdGgucG93KGZyb20ueiAtIHBvc2l0aW9uLnosIDIpIC0gTWF0aC5wb3cociwgMik7XG5cbiAgICB2YXIgZGVsdGEgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBhICogYztcblxuICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQ7XG4gICAgdmFyIG5vcm1hbCA9IFJheV9pbnRlcnNlY3RTcGhlcmVfbm9ybWFsO1xuXG4gICAgaWYoZGVsdGEgPCAwKXtcbiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXG4gICAgICAgIHJldHVybjtcblxuICAgIH0gZWxzZSBpZihkZWx0YSA9PT0gMCl7XG4gICAgICAgIC8vIHNpbmdsZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgZnJvbS5sZXJwKHRvLCBkZWx0YSwgaW50ZXJzZWN0aW9uUG9pbnQpO1xuXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcblxuICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZDEgPSAoLSBiIC0gTWF0aC5zcXJ0KGRlbHRhKSkgLyAoMiAqIGEpO1xuICAgICAgICB2YXIgZDIgPSAoLSBiICsgTWF0aC5zcXJ0KGRlbHRhKSkgLyAoMiAqIGEpO1xuXG4gICAgICAgIGlmKGQxID49IDAgJiYgZDEgPD0gMSl7XG4gICAgICAgICAgICBmcm9tLmxlcnAodG8sIGQxLCBpbnRlcnNlY3Rpb25Qb2ludCk7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpO1xuICAgICAgICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgcmVwb3J0ZWRTaGFwZSwgYm9keSwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3Ape1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZDIgPj0gMCAmJiBkMiA8PSAxKXtcbiAgICAgICAgICAgIGZyb20ubGVycCh0bywgZDIsIGludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCByZXBvcnRlZFNoYXBlLCBib2R5LCAtMSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkVdID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RTcGhlcmU7XG5cblxudmFyIGludGVyc2VjdENvbnZleF9ub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIGludGVyc2VjdENvbnZleF9taW5EaXN0Tm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RDb252ZXhfbWluRGlzdEludGVyc2VjdCA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0Q29udmV4X3ZlY3RvciA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBpbnRlcnNlY3RDb252ZXhcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2FycmF5fSBbb3B0aW9ucy5mYWNlTGlzdF1cbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RDb252ZXggPSBmdW5jdGlvbiBpbnRlcnNlY3RDb252ZXgoXG4gICAgc2hhcGUsXG4gICAgcXVhdCxcbiAgICBwb3NpdGlvbixcbiAgICBib2R5LFxuICAgIHJlcG9ydGVkU2hhcGUsXG4gICAgb3B0aW9uc1xuKXtcbiAgICB2YXIgbWluRGlzdE5vcm1hbCA9IGludGVyc2VjdENvbnZleF9taW5EaXN0Tm9ybWFsO1xuICAgIHZhciBub3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbm9ybWFsO1xuICAgIHZhciB2ZWN0b3IgPSBpbnRlcnNlY3RDb252ZXhfdmVjdG9yO1xuICAgIHZhciBtaW5EaXN0SW50ZXJzZWN0ID0gaW50ZXJzZWN0Q29udmV4X21pbkRpc3RJbnRlcnNlY3Q7XG4gICAgdmFyIGZhY2VMaXN0ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5mYWNlTGlzdCkgfHwgbnVsbDtcblxuICAgIC8vIENoZWNraW5nIGZhY2VzXG4gICAgdmFyIGZhY2VzID0gc2hhcGUuZmFjZXMsXG4gICAgICAgIHZlcnRpY2VzID0gc2hhcGUudmVydGljZXMsXG4gICAgICAgIG5vcm1hbHMgPSBzaGFwZS5mYWNlTm9ybWFscztcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uO1xuXG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgZnJvbVRvRGlzdGFuY2UgPSBmcm9tLmRpc3RhbmNlVG8odG8pO1xuXG4gICAgdmFyIG1pbkRpc3QgPSAtMTtcbiAgICB2YXIgTmZhY2VzID0gZmFjZUxpc3QgPyBmYWNlTGlzdC5sZW5ndGggOiBmYWNlcy5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0O1xuXG4gICAgZm9yICh2YXIgaiA9IDA7ICFyZXN1bHQuX3Nob3VsZFN0b3AgJiYgaiA8IE5mYWNlczsgaisrKSB7XG4gICAgICAgIHZhciBmaSA9IGZhY2VMaXN0ID8gZmFjZUxpc3Rbal0gOiBqO1xuXG4gICAgICAgIHZhciBmYWNlID0gZmFjZXNbZmldO1xuICAgICAgICB2YXIgZmFjZU5vcm1hbCA9IG5vcm1hbHNbZmldO1xuICAgICAgICB2YXIgcSA9IHF1YXQ7XG4gICAgICAgIHZhciB4ID0gcG9zaXRpb247XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHJheSBpbnRlcnNlY3RzIHRoZSBwbGFuZSBvZiB0aGUgZmFjZVxuICAgICAgICAvLyBub3RlOiB0aGlzIHdvcmtzIHJlZ2FyZGxlc3Mgb2YgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZmFjZSBub3JtYWxcblxuICAgICAgICAvLyBHZXQgcGxhbmUgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMuLi5cbiAgICAgICAgdmVjdG9yLmNvcHkodmVydGljZXNbZmFjZVswXV0pO1xuICAgICAgICBxLnZtdWx0KHZlY3Rvcix2ZWN0b3IpO1xuICAgICAgICB2ZWN0b3IudmFkZCh4LHZlY3Rvcik7XG5cbiAgICAgICAgLy8gLi4uYnV0IG1ha2UgaXQgcmVsYXRpdmUgdG8gdGhlIHJheSBmcm9tLiBXZSdsbCBmaXggdGhpcyBsYXRlci5cbiAgICAgICAgdmVjdG9yLnZzdWIoZnJvbSx2ZWN0b3IpO1xuXG4gICAgICAgIC8vIEdldCBwbGFuZSBub3JtYWxcbiAgICAgICAgcS52bXVsdChmYWNlTm9ybWFsLG5vcm1hbCk7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBkb3QgcHJvZHVjdCBpcyBuZWdhdGl2ZSwgd2UgaGF2ZSBzb21ldGhpbmcgaW50ZXJlc3RpbmdcbiAgICAgICAgdmFyIGRvdCA9IGRpcmVjdGlvbi5kb3Qobm9ybWFsKTtcblxuICAgICAgICAvLyBCYWlsIG91dCBpZiByYXkgYW5kIHBsYW5lIGFyZSBwYXJhbGxlbFxuICAgICAgICBpZiAoIE1hdGguYWJzKCBkb3QgKSA8IHRoaXMucHJlY2lzaW9uICl7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGMgZGlzdGFuY2UgdG8gcGxhbmVcbiAgICAgICAgdmFyIHNjYWxhciA9IG5vcm1hbC5kb3QodmVjdG9yKSAvIGRvdDtcblxuICAgICAgICAvLyBpZiBuZWdhdGl2ZSBkaXN0YW5jZSwgdGhlbiBwbGFuZSBpcyBiZWhpbmQgcmF5XG4gICAgICAgIGlmIChzY2FsYXIgPCAwKXtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgKGRvdCA8IDApIHtcblxuICAgICAgICAvLyBJbnRlcnNlY3Rpb24gcG9pbnQgaXMgZnJvbSArIGRpcmVjdGlvbiAqIHNjYWxhclxuICAgICAgICBkaXJlY3Rpb24ubXVsdChzY2FsYXIsaW50ZXJzZWN0UG9pbnQpO1xuICAgICAgICBpbnRlcnNlY3RQb2ludC52YWRkKGZyb20saW50ZXJzZWN0UG9pbnQpO1xuXG4gICAgICAgIC8vIGEgaXMgdGhlIHBvaW50IHdlIGNvbXBhcmUgcG9pbnRzIGIgYW5kIGMgd2l0aC5cbiAgICAgICAgYS5jb3B5KHZlcnRpY2VzW2ZhY2VbMF1dKTtcbiAgICAgICAgcS52bXVsdChhLGEpO1xuICAgICAgICB4LnZhZGQoYSxhKTtcblxuICAgICAgICBmb3IodmFyIGkgPSAxOyAhcmVzdWx0Ll9zaG91bGRTdG9wICYmIGkgPCBmYWNlLmxlbmd0aCAtIDE7IGkrKyl7XG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gMyB2ZXJ0aWNlcyB0byB3b3JsZCBjb29yZHNcbiAgICAgICAgICAgIGIuY29weSh2ZXJ0aWNlc1tmYWNlW2ldXSk7XG4gICAgICAgICAgICBjLmNvcHkodmVydGljZXNbZmFjZVtpKzFdXSk7XG4gICAgICAgICAgICBxLnZtdWx0KGIsYik7XG4gICAgICAgICAgICBxLnZtdWx0KGMsYyk7XG4gICAgICAgICAgICB4LnZhZGQoYixiKTtcbiAgICAgICAgICAgIHgudmFkZChjLGMpO1xuXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBpbnRlcnNlY3RQb2ludC5kaXN0YW5jZVRvKGZyb20pO1xuXG4gICAgICAgICAgICBpZighKHBvaW50SW5UcmlhbmdsZShpbnRlcnNlY3RQb2ludCwgYSwgYiwgYykgfHwgcG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBiLCBhLCBjKSkgfHwgZGlzdGFuY2UgPiBmcm9tVG9EaXN0YW5jZSl7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKG5vcm1hbCwgaW50ZXJzZWN0UG9pbnQsIHJlcG9ydGVkU2hhcGUsIGJvZHksIGZpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB9XG4gICAgfVxufTtcblJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdENvbnZleDtcblxudmFyIGludGVyc2VjdFRyaW1lc2hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRGlyZWN0aW9uID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRnJvbSA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbFRvID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX3dvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX3dvcmxkSW50ZXJzZWN0UG9pbnQgPSBuZXcgVmVjMygpO1xudmFyIGludGVyc2VjdFRyaW1lc2hfbG9jYWxBQUJCID0gbmV3IEFBQkIoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX3RyaWFuZ2xlcyA9IFtdO1xudmFyIGludGVyc2VjdFRyaW1lc2hfdHJlZVRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFRyaW1lc2hcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAdG9kbyBPcHRpbWl6ZSBieSB0cmFuc2Zvcm1pbmcgdGhlIHdvcmxkIHRvIGxvY2FsIHNwYWNlIGZpcnN0LlxuICogQHRvZG8gVXNlIE9jdHJlZSBsb29rdXBcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RUcmltZXNoID0gZnVuY3Rpb24gaW50ZXJzZWN0VHJpbWVzaChcbiAgICBtZXNoLFxuICAgIHF1YXQsXG4gICAgcG9zaXRpb24sXG4gICAgYm9keSxcbiAgICByZXBvcnRlZFNoYXBlLFxuICAgIG9wdGlvbnNcbil7XG4gICAgdmFyIG5vcm1hbCA9IGludGVyc2VjdFRyaW1lc2hfbm9ybWFsO1xuICAgIHZhciB0cmlhbmdsZXMgPSBpbnRlcnNlY3RUcmltZXNoX3RyaWFuZ2xlcztcbiAgICB2YXIgdHJlZVRyYW5zZm9ybSA9IGludGVyc2VjdFRyaW1lc2hfdHJlZVRyYW5zZm9ybTtcbiAgICB2YXIgbWluRGlzdE5vcm1hbCA9IGludGVyc2VjdENvbnZleF9taW5EaXN0Tm9ybWFsO1xuICAgIHZhciB2ZWN0b3IgPSBpbnRlcnNlY3RDb252ZXhfdmVjdG9yO1xuICAgIHZhciBtaW5EaXN0SW50ZXJzZWN0ID0gaW50ZXJzZWN0Q29udmV4X21pbkRpc3RJbnRlcnNlY3Q7XG4gICAgdmFyIGxvY2FsQUFCQiA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxBQUJCO1xuICAgIHZhciBsb2NhbERpcmVjdGlvbiA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxEaXJlY3Rpb247XG4gICAgdmFyIGxvY2FsRnJvbSA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxGcm9tO1xuICAgIHZhciBsb2NhbFRvID0gaW50ZXJzZWN0VHJpbWVzaF9sb2NhbFRvO1xuICAgIHZhciB3b3JsZEludGVyc2VjdFBvaW50ID0gaW50ZXJzZWN0VHJpbWVzaF93b3JsZEludGVyc2VjdFBvaW50O1xuICAgIHZhciB3b3JsZE5vcm1hbCA9IGludGVyc2VjdFRyaW1lc2hfd29ybGROb3JtYWw7XG4gICAgdmFyIGZhY2VMaXN0ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5mYWNlTGlzdCkgfHwgbnVsbDtcblxuICAgIC8vIENoZWNraW5nIGZhY2VzXG4gICAgdmFyIGluZGljZXMgPSBtZXNoLmluZGljZXMsXG4gICAgICAgIHZlcnRpY2VzID0gbWVzaC52ZXJ0aWNlcyxcbiAgICAgICAgbm9ybWFscyA9IG1lc2guZmFjZU5vcm1hbHM7XG5cbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb247XG5cbiAgICB2YXIgbWluRGlzdCA9IC0xO1xuICAgIHRyZWVUcmFuc2Zvcm0ucG9zaXRpb24uY29weShwb3NpdGlvbik7XG4gICAgdHJlZVRyYW5zZm9ybS5xdWF0ZXJuaW9uLmNvcHkocXVhdCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmF5IHRvIGxvY2FsIHNwYWNlIVxuICAgIFRyYW5zZm9ybS52ZWN0b3JUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIGRpcmVjdGlvbiwgbG9jYWxEaXJlY3Rpb24pO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgZnJvbSwgbG9jYWxGcm9tKTtcbiAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIHRvLCBsb2NhbFRvKTtcblxuICAgIGxvY2FsVG8ueCAqPSBtZXNoLnNjYWxlLng7XG4gICAgbG9jYWxUby55ICo9IG1lc2guc2NhbGUueTtcbiAgICBsb2NhbFRvLnogKj0gbWVzaC5zY2FsZS56O1xuICAgIGxvY2FsRnJvbS54ICo9IG1lc2guc2NhbGUueDtcbiAgICBsb2NhbEZyb20ueSAqPSBtZXNoLnNjYWxlLnk7XG4gICAgbG9jYWxGcm9tLnogKj0gbWVzaC5zY2FsZS56O1xuXG4gICAgbG9jYWxUby52c3ViKGxvY2FsRnJvbSwgbG9jYWxEaXJlY3Rpb24pO1xuICAgIGxvY2FsRGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG4gICAgdmFyIGZyb21Ub0Rpc3RhbmNlU3F1YXJlZCA9IGxvY2FsRnJvbS5kaXN0YW5jZVNxdWFyZWQobG9jYWxUbyk7XG5cbiAgICBtZXNoLnRyZWUucmF5UXVlcnkodGhpcywgdHJlZVRyYW5zZm9ybSwgdHJpYW5nbGVzKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBOID0gdHJpYW5nbGVzLmxlbmd0aDsgIXRoaXMucmVzdWx0Ll9zaG91bGRTdG9wICYmIGkgIT09IE47IGkrKykge1xuICAgICAgICB2YXIgdHJpYW5nbGVzSW5kZXggPSB0cmlhbmdsZXNbaV07XG5cbiAgICAgICAgbWVzaC5nZXROb3JtYWwodHJpYW5nbGVzSW5kZXgsIG5vcm1hbCk7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHJheSBpbnRlcnNlY3RzIHRoZSBwbGFuZSBvZiB0aGUgZmFjZVxuICAgICAgICAvLyBub3RlOiB0aGlzIHdvcmtzIHJlZ2FyZGxlc3Mgb2YgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZmFjZSBub3JtYWxcblxuICAgICAgICAvLyBHZXQgcGxhbmUgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMuLi5cbiAgICAgICAgbWVzaC5nZXRWZXJ0ZXgoaW5kaWNlc1t0cmlhbmdsZXNJbmRleCAqIDNdLCBhKTtcblxuICAgICAgICAvLyAuLi5idXQgbWFrZSBpdCByZWxhdGl2ZSB0byB0aGUgcmF5IGZyb20uIFdlJ2xsIGZpeCB0aGlzIGxhdGVyLlxuICAgICAgICBhLnZzdWIobG9jYWxGcm9tLHZlY3Rvcik7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBkb3QgcHJvZHVjdCBpcyBuZWdhdGl2ZSwgd2UgaGF2ZSBzb21ldGhpbmcgaW50ZXJlc3RpbmdcbiAgICAgICAgdmFyIGRvdCA9IGxvY2FsRGlyZWN0aW9uLmRvdChub3JtYWwpO1xuXG4gICAgICAgIC8vIEJhaWwgb3V0IGlmIHJheSBhbmQgcGxhbmUgYXJlIHBhcmFsbGVsXG4gICAgICAgIC8vIGlmIChNYXRoLmFicyggZG90ICkgPCB0aGlzLnByZWNpc2lvbil7XG4gICAgICAgIC8vICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGNhbGMgZGlzdGFuY2UgdG8gcGxhbmVcbiAgICAgICAgdmFyIHNjYWxhciA9IG5vcm1hbC5kb3QodmVjdG9yKSAvIGRvdDtcblxuICAgICAgICAvLyBpZiBuZWdhdGl2ZSBkaXN0YW5jZSwgdGhlbiBwbGFuZSBpcyBiZWhpbmQgcmF5XG4gICAgICAgIGlmIChzY2FsYXIgPCAwKXtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXJcbiAgICAgICAgbG9jYWxEaXJlY3Rpb24uc2NhbGUoc2NhbGFyLGludGVyc2VjdFBvaW50KTtcbiAgICAgICAgaW50ZXJzZWN0UG9pbnQudmFkZChsb2NhbEZyb20saW50ZXJzZWN0UG9pbnQpO1xuXG4gICAgICAgIC8vIEdldCB0cmlhbmdsZSB2ZXJ0aWNlc1xuICAgICAgICBtZXNoLmdldFZlcnRleChpbmRpY2VzW3RyaWFuZ2xlc0luZGV4ICogMyArIDFdLCBiKTtcbiAgICAgICAgbWVzaC5nZXRWZXJ0ZXgoaW5kaWNlc1t0cmlhbmdsZXNJbmRleCAqIDMgKyAyXSwgYyk7XG5cbiAgICAgICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IGludGVyc2VjdFBvaW50LmRpc3RhbmNlU3F1YXJlZChsb2NhbEZyb20pO1xuXG4gICAgICAgIGlmKCEocG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBiLCBhLCBjKSB8fCBwb2ludEluVHJpYW5nbGUoaW50ZXJzZWN0UG9pbnQsIGEsIGIsIGMpKSB8fCBzcXVhcmVkRGlzdGFuY2UgPiBmcm9tVG9EaXN0YW5jZVNxdWFyZWQpe1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmFuc2Zvcm0gaW50ZXJzZWN0cG9pbnQgYW5kIG5vcm1hbCB0byB3b3JsZFxuICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHF1YXQsIG5vcm1hbCwgd29ybGROb3JtYWwpO1xuICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHF1YXQsIGludGVyc2VjdFBvaW50LCB3b3JsZEludGVyc2VjdFBvaW50KTtcbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24od29ybGROb3JtYWwsIHdvcmxkSW50ZXJzZWN0UG9pbnQsIHJlcG9ydGVkU2hhcGUsIGJvZHksIHRyaWFuZ2xlc0luZGV4KTtcbiAgICB9XG4gICAgdHJpYW5nbGVzLmxlbmd0aCA9IDA7XG59O1xuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5UUklNRVNIXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0VHJpbWVzaDtcblxuXG4vKipcbiAqIEBtZXRob2QgcmVwb3J0SW50ZXJzZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7VmVjM30gbm9ybWFsXG4gKiBAcGFyYW0gIHtWZWMzfSBoaXRQb2ludFdvcmxkXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGludGVyc2VjdGlvbnMgc2hvdWxkIGNvbnRpbnVlXG4gKi9cblJheS5wcm90b3R5cGUucmVwb3J0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24obm9ybWFsLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgaGl0RmFjZUluZGV4KXtcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBkaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyhoaXRQb2ludFdvcmxkKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG5cbiAgICAvLyBTa2lwIGJhY2sgZmFjZXM/XG4gICAgaWYodGhpcy5za2lwQmFja2ZhY2VzICYmIG5vcm1hbC5kb3QodGhpcy5fZGlyZWN0aW9uKSA+IDApe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzdWx0LmhpdEZhY2VJbmRleCA9IHR5cGVvZihoaXRGYWNlSW5kZXgpICE9PSAndW5kZWZpbmVkJyA/IGhpdEZhY2VJbmRleCA6IC0xO1xuXG4gICAgc3dpdGNoKHRoaXMubW9kZSl7XG4gICAgY2FzZSBSYXkuQUxMOlxuICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XG4gICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFJheS5DTE9TRVNUOlxuXG4gICAgICAgIC8vIFN0b3JlIGlmIGNsb3NlciB0aGFuIGN1cnJlbnQgY2xvc2VzdFxuICAgICAgICBpZihkaXN0YW5jZSA8IHJlc3VsdC5kaXN0YW5jZSB8fCAhcmVzdWx0Lmhhc0hpdCl7XG4gICAgICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcbiAgICAgICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBSYXkuQU5ZOlxuXG4gICAgICAgIC8vIFJlcG9ydCBhbmQgc3RvcC5cbiAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xuICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIG5vcm1hbCxcbiAgICAgICAgICAgIGhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICApO1xuICAgICAgICByZXN1bHQuX3Nob3VsZFN0b3AgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG52YXIgdjAgPSBuZXcgVmVjMygpLFxuICAgIGludGVyc2VjdCA9IG5ldyBWZWMzKCk7XG5mdW5jdGlvbiBkaXN0YW5jZUZyb21JbnRlcnNlY3Rpb24oZnJvbSwgZGlyZWN0aW9uLCBwb3NpdGlvbikge1xuXG4gICAgLy8gdjAgaXMgdmVjdG9yIGZyb20gZnJvbSB0byBwb3NpdGlvblxuICAgIHBvc2l0aW9uLnZzdWIoZnJvbSx2MCk7XG4gICAgdmFyIGRvdCA9IHYwLmRvdChkaXJlY3Rpb24pO1xuXG4gICAgLy8gaW50ZXJzZWN0ID0gZGlyZWN0aW9uKmRvdCArIGZyb21cbiAgICBkaXJlY3Rpb24ubXVsdChkb3QsaW50ZXJzZWN0KTtcbiAgICBpbnRlcnNlY3QudmFkZChmcm9tLGludGVyc2VjdCk7XG5cbiAgICB2YXIgZGlzdGFuY2UgPSBwb3NpdGlvbi5kaXN0YW5jZVRvKGludGVyc2VjdCk7XG5cbiAgICByZXR1cm4gZGlzdGFuY2U7XG59XG5cbiIsInZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmF5Y2FzdFJlc3VsdDtcblxuLyoqXG4gKiBTdG9yYWdlIGZvciBSYXkgY2FzdGluZyBkYXRhLlxuICogQGNsYXNzIFJheWNhc3RSZXN1bHRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSYXljYXN0UmVzdWx0KCl7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7VmVjM30gcmF5RnJvbVdvcmxkXG5cdCAqL1xuXHR0aGlzLnJheUZyb21Xb3JsZCA9IG5ldyBWZWMzKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7VmVjM30gcmF5VG9Xb3JsZFxuXHQgKi9cblx0dGhpcy5yYXlUb1dvcmxkID0gbmV3IFZlYzMoKTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHtWZWMzfSBoaXROb3JtYWxXb3JsZFxuXHQgKi9cblx0dGhpcy5oaXROb3JtYWxXb3JsZCA9IG5ldyBWZWMzKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7VmVjM30gaGl0UG9pbnRXb3JsZFxuXHQgKi9cblx0dGhpcy5oaXRQb2ludFdvcmxkID0gbmV3IFZlYzMoKTtcblxuXHQvKipcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBoYXNIaXRcblx0ICovXG5cdHRoaXMuaGFzSGl0ID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFRoZSBoaXQgc2hhcGUsIG9yIG51bGwuXG5cdCAqIEBwcm9wZXJ0eSB7U2hhcGV9IHNoYXBlXG5cdCAqL1xuXHR0aGlzLnNoYXBlID0gbnVsbDtcblxuXHQvKipcblx0ICogVGhlIGhpdCBib2R5LCBvciBudWxsLlxuXHQgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlcblx0ICovXG5cdHRoaXMuYm9keSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBpbmRleCBvZiB0aGUgaGl0IHRyaWFuZ2xlLCBpZiB0aGUgaGl0IHNoYXBlIHdhcyBhIHRyaW1lc2guXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaXRGYWNlSW5kZXhcblx0ICogQGRlZmF1bHQgLTFcblx0ICovXG5cdHRoaXMuaGl0RmFjZUluZGV4ID0gLTE7XG5cblx0LyoqXG5cdCAqIERpc3RhbmNlIHRvIHRoZSBoaXQuIFdpbGwgYmUgc2V0IHRvIC0xIGlmIHRoZXJlIHdhcyBubyBoaXQuXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaXN0YW5jZVxuXHQgKiBAZGVmYXVsdCAtMVxuXHQgKi9cblx0dGhpcy5kaXN0YW5jZSA9IC0xO1xuXG5cdC8qKlxuXHQgKiBJZiB0aGUgcmF5IHNob3VsZCBzdG9wIHRyYXZlcnNpbmcgdGhlIGJvZGllcy5cblx0ICogQHByaXZhdGVcblx0ICogQHByb3BlcnR5IHtCb29sZWFufSBfc2hvdWxkU3RvcFxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKi9cblx0dGhpcy5fc2hvdWxkU3RvcCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlc2V0IGFsbCByZXN1bHQgZGF0YS5cbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG5cdHRoaXMucmF5RnJvbVdvcmxkLnNldFplcm8oKTtcblx0dGhpcy5yYXlUb1dvcmxkLnNldFplcm8oKTtcblx0dGhpcy5oaXROb3JtYWxXb3JsZC5zZXRaZXJvKCk7XG5cdHRoaXMuaGl0UG9pbnRXb3JsZC5zZXRaZXJvKCk7XG5cdHRoaXMuaGFzSGl0ID0gZmFsc2U7XG5cdHRoaXMuc2hhcGUgPSBudWxsO1xuXHR0aGlzLmJvZHkgPSBudWxsO1xuXHR0aGlzLmhpdEZhY2VJbmRleCA9IC0xO1xuXHR0aGlzLmRpc3RhbmNlID0gLTE7XG5cdHRoaXMuX3Nob3VsZFN0b3AgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBhYm9ydFxuICovXG5SYXljYXN0UmVzdWx0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG5cdHRoaXMuX3Nob3VsZFN0b3AgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtIHtWZWMzfSByYXlGcm9tV29ybGRcbiAqIEBwYXJhbSB7VmVjM30gcmF5VG9Xb3JsZFxuICogQHBhcmFtIHtWZWMzfSBoaXROb3JtYWxXb3JsZFxuICogQHBhcmFtIHtWZWMzfSBoaXRQb2ludFdvcmxkXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oXG5cdHJheUZyb21Xb3JsZCxcblx0cmF5VG9Xb3JsZCxcblx0aGl0Tm9ybWFsV29ybGQsXG5cdGhpdFBvaW50V29ybGQsXG5cdHNoYXBlLFxuXHRib2R5LFxuXHRkaXN0YW5jZVxuKXtcblx0dGhpcy5yYXlGcm9tV29ybGQuY29weShyYXlGcm9tV29ybGQpO1xuXHR0aGlzLnJheVRvV29ybGQuY29weShyYXlUb1dvcmxkKTtcblx0dGhpcy5oaXROb3JtYWxXb3JsZC5jb3B5KGhpdE5vcm1hbFdvcmxkKTtcblx0dGhpcy5oaXRQb2ludFdvcmxkLmNvcHkoaGl0UG9pbnRXb3JsZCk7XG5cdHRoaXMuc2hhcGUgPSBzaGFwZTtcblx0dGhpcy5ib2R5ID0gYm9keTtcblx0dGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xufTsiLCJ2YXIgU2hhcGUgPSByZXF1aXJlKCcuLi9zaGFwZXMvU2hhcGUnKTtcbnZhciBCcm9hZHBoYXNlID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTQVBCcm9hZHBoYXNlO1xuXG4vKipcbiAqIFN3ZWVwIGFuZCBwcnVuZSBicm9hZHBoYXNlIGFsb25nIG9uZSBheGlzLlxuICpcbiAqIEBjbGFzcyBTQVBCcm9hZHBoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7V29ybGR9IFt3b3JsZF1cbiAqIEBleHRlbmRzIEJyb2FkcGhhc2VcbiAqL1xuZnVuY3Rpb24gU0FQQnJvYWRwaGFzZSh3b3JsZCl7XG4gICAgQnJvYWRwaGFzZS5hcHBseSh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYm9kaWVzIGN1cnJlbnRseSBpbiB0aGUgYnJvYWRwaGFzZS5cbiAgICAgKiBAcHJvcGVydHkgYXhpc0xpc3RcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5heGlzTGlzdCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdvcmxkIHRvIHNlYXJjaCBpbi5cbiAgICAgKiBAcHJvcGVydHkgd29ybGRcbiAgICAgKiBAdHlwZSB7V29ybGR9XG4gICAgICovXG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBeGlzIHRvIHNvcnQgdGhlIGJvZGllcyBhbG9uZy4gU2V0IHRvIDAgZm9yIHggYXhpcywgYW5kIDEgZm9yIHkgYXhpcy4gRm9yIGJlc3QgcGVyZm9ybWFuY2UsIGNob29zZSBhbiBheGlzIHRoYXQgdGhlIGJvZGllcyBhcmUgc3ByZWFkIG91dCBtb3JlIG9uLlxuICAgICAqIEBwcm9wZXJ0eSBheGlzSW5kZXhcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYXhpc0luZGV4ID0gMDtcblxuICAgIHZhciBheGlzTGlzdCA9IHRoaXMuYXhpc0xpc3Q7XG5cbiAgICB0aGlzLl9hZGRCb2R5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICBheGlzTGlzdC5wdXNoKGUuYm9keSk7XG4gICAgfTtcblxuICAgIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIHZhciBpZHggPSBheGlzTGlzdC5pbmRleE9mKGUuYm9keSk7XG4gICAgICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICAgICAgYXhpc0xpc3Quc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZih3b3JsZCl7XG4gICAgICAgIHRoaXMuc2V0V29ybGQod29ybGQpO1xuICAgIH1cbn1cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHdvcmxkXG4gKiBAbWV0aG9kIHNldFdvcmxkXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuc2V0V29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgLy8gQ2xlYXIgdGhlIG9sZCBheGlzIGFycmF5XG4gICAgdGhpcy5heGlzTGlzdC5sZW5ndGggPSAwO1xuXG4gICAgLy8gQWRkIGFsbCBib2RpZXMgZnJvbSB0aGUgbmV3IHdvcmxkXG4gICAgZm9yKHZhciBpPTA7IGk8d29ybGQuYm9kaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5heGlzTGlzdC5wdXNoKHdvcmxkLmJvZGllc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIG9sZCBoYW5kbGVycywgaWYgYW55XG4gICAgd29ybGQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFkZEJvZHlcIiwgdGhpcy5fYWRkQm9keUhhbmRsZXIpO1xuICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZW1vdmVCb2R5XCIsIHRoaXMuX3JlbW92ZUJvZHlIYW5kbGVyKTtcblxuICAgIC8vIEFkZCBoYW5kbGVycyB0byB1cGRhdGUgdGhlIGxpc3Qgb2YgYm9kaWVzLlxuICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoXCJhZGRCb2R5XCIsIHRoaXMuX2FkZEJvZHlIYW5kbGVyKTtcbiAgICB3b3JsZC5hZGRFdmVudExpc3RlbmVyKFwicmVtb3ZlQm9keVwiLCB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7XG5cbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgaW5zZXJ0aW9uU29ydFhcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WCA9IGZ1bmN0aW9uKGEpIHtcbiAgICBmb3IodmFyIGk9MSxsPWEubGVuZ3RoO2k8bDtpKyspIHtcbiAgICAgICAgdmFyIHYgPSBhW2ldO1xuICAgICAgICBmb3IodmFyIGo9aSAtIDE7aj49MDtqLS0pIHtcbiAgICAgICAgICAgIGlmKGFbal0uYWFiYi5sb3dlckJvdW5kLnggPD0gdi5hYWJiLmxvd2VyQm91bmQueCl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhW2orMV0gPSBhW2pdO1xuICAgICAgICB9XG4gICAgICAgIGFbaisxXSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGluc2VydGlvblNvcnRZXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFkgPSBmdW5jdGlvbihhKSB7XG4gICAgZm9yKHZhciBpPTEsbD1hLmxlbmd0aDtpPGw7aSsrKSB7XG4gICAgICAgIHZhciB2ID0gYVtpXTtcbiAgICAgICAgZm9yKHZhciBqPWkgLSAxO2o+PTA7ai0tKSB7XG4gICAgICAgICAgICBpZihhW2pdLmFhYmIubG93ZXJCb3VuZC55IDw9IHYuYWFiYi5sb3dlckJvdW5kLnkpe1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVtqKzFdID0gYVtqXTtcbiAgICAgICAgfVxuICAgICAgICBhW2orMV0gPSB2O1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBpbnNlcnRpb25Tb3J0WlxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRaID0gZnVuY3Rpb24oYSkge1xuICAgIGZvcih2YXIgaT0xLGw9YS5sZW5ndGg7aTxsO2krKykge1xuICAgICAgICB2YXIgdiA9IGFbaV07XG4gICAgICAgIGZvcih2YXIgaj1pIC0gMTtqPj0wO2otLSkge1xuICAgICAgICAgICAgaWYoYVtqXS5hYWJiLmxvd2VyQm91bmQueiA8PSB2LmFhYmIubG93ZXJCb3VuZC56KXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFbaisxXSA9IGFbal07XG4gICAgICAgIH1cbiAgICAgICAgYVtqKzFdID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIENvbGxlY3QgYWxsIGNvbGxpc2lvbiBwYWlyc1xuICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAqIEBwYXJhbSAge0FycmF5fSBwMlxuICovXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5jb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uKHdvcmxkLHAxLHAyKXtcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5heGlzTGlzdCxcbiAgICAgICAgTiA9IGJvZGllcy5sZW5ndGgsXG4gICAgICAgIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4LFxuICAgICAgICBpLCBqO1xuXG4gICAgaWYodGhpcy5kaXJ0eSl7XG4gICAgICAgIHRoaXMuc29ydExpc3QoKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIExvb2sgdGhyb3VnaCB0aGUgbGlzdFxuICAgIGZvcihpPTA7IGkgIT09IE47IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcblxuICAgICAgICBmb3Ioaj1pKzE7IGogPCBOOyBqKyspe1xuICAgICAgICAgICAgdmFyIGJqID0gYm9kaWVzW2pdO1xuXG4gICAgICAgICAgICBpZighdGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihiaSxiaikpe1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighU0FQQnJvYWRwaGFzZS5jaGVja0JvdW5kcyhiaSxiaixheGlzSW5kZXgpKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25UZXN0KGJpLGJqLHAxLHAyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLnNvcnRMaXN0ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0O1xuICAgIHZhciBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleDtcbiAgICB2YXIgTiA9IGF4aXNMaXN0Lmxlbmd0aDtcblxuICAgIC8vIFVwZGF0ZSBBQUJCc1xuICAgIGZvcih2YXIgaSA9IDA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBheGlzTGlzdFtpXTtcbiAgICAgICAgaWYoYmkuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGJpLmNvbXB1dGVBQUJCKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb3J0IHRoZSBsaXN0XG4gICAgaWYoYXhpc0luZGV4ID09PSAwKXtcbiAgICAgICAgU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WChheGlzTGlzdCk7XG4gICAgfSBlbHNlIGlmKGF4aXNJbmRleCA9PT0gMSl7XG4gICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFkoYXhpc0xpc3QpO1xuICAgIH0gZWxzZSBpZihheGlzSW5kZXggPT09IDIpe1xuICAgICAgICBTQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRaKGF4aXNMaXN0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBib3VuZHMgb2YgdHdvIGJvZGllcyBvdmVybGFwLCBhbG9uZyB0aGUgZ2l2ZW4gU0FQIGF4aXMuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNoZWNrQm91bmRzXG4gKiBAcGFyYW0gIHtCb2R5fSBiaVxuICogQHBhcmFtICB7Qm9keX0gYmpcbiAqIEBwYXJhbSAge051bWJlcn0gYXhpc0luZGV4XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5TQVBCcm9hZHBoYXNlLmNoZWNrQm91bmRzID0gZnVuY3Rpb24oYmksIGJqLCBheGlzSW5kZXgpe1xuICAgIHZhciBiaVBvcztcbiAgICB2YXIgYmpQb3M7XG5cbiAgICBpZihheGlzSW5kZXggPT09IDApe1xuICAgICAgICBiaVBvcyA9IGJpLnBvc2l0aW9uLng7XG4gICAgICAgIGJqUG9zID0gYmoucG9zaXRpb24ueDtcbiAgICB9IGVsc2UgaWYoYXhpc0luZGV4ID09PSAxKXtcbiAgICAgICAgYmlQb3MgPSBiaS5wb3NpdGlvbi55O1xuICAgICAgICBialBvcyA9IGJqLnBvc2l0aW9uLnk7XG4gICAgfSBlbHNlIGlmKGF4aXNJbmRleCA9PT0gMil7XG4gICAgICAgIGJpUG9zID0gYmkucG9zaXRpb24uejtcbiAgICAgICAgYmpQb3MgPSBiai5wb3NpdGlvbi56O1xuICAgIH1cblxuICAgIHZhciByaSA9IGJpLmJvdW5kaW5nUmFkaXVzLFxuICAgICAgICByaiA9IGJqLmJvdW5kaW5nUmFkaXVzLFxuICAgICAgICBib3VuZEExID0gYmlQb3MgLSByaSxcbiAgICAgICAgYm91bmRBMiA9IGJpUG9zICsgcmksXG4gICAgICAgIGJvdW5kQjEgPSBialBvcyAtIHJqLFxuICAgICAgICBib3VuZEIyID0gYmpQb3MgKyByajtcblxuICAgIHJldHVybiBib3VuZEIxIDwgYm91bmRBMjtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHZhcmlhbmNlIG9mIHRoZSBib2R5IHBvc2l0aW9ucyBhbmQgZXN0aW1hdGVzIHRoZSBiZXN0XG4gKiBheGlzIHRvIHVzZS4gV2lsbCBhdXRvbWF0aWNhbGx5IHNldCBwcm9wZXJ0eSAuYXhpc0luZGV4LlxuICogQG1ldGhvZCBhdXRvRGV0ZWN0QXhpc1xuICovXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5hdXRvRGV0ZWN0QXhpcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHN1bVg9MCxcbiAgICAgICAgc3VtWDI9MCxcbiAgICAgICAgc3VtWT0wLFxuICAgICAgICBzdW1ZMj0wLFxuICAgICAgICBzdW1aPTAsXG4gICAgICAgIHN1bVoyPTAsXG4gICAgICAgIGJvZGllcyA9IHRoaXMuYXhpc0xpc3QsXG4gICAgICAgIE4gPSBib2RpZXMubGVuZ3RoLFxuICAgICAgICBpbnZOPTEvTjtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSBib2RpZXNbaV07XG5cbiAgICAgICAgdmFyIGNlbnRlclggPSBiLnBvc2l0aW9uLng7XG4gICAgICAgIHN1bVggKz0gY2VudGVyWDtcbiAgICAgICAgc3VtWDIgKz0gY2VudGVyWCpjZW50ZXJYO1xuXG4gICAgICAgIHZhciBjZW50ZXJZID0gYi5wb3NpdGlvbi55O1xuICAgICAgICBzdW1ZICs9IGNlbnRlclk7XG4gICAgICAgIHN1bVkyICs9IGNlbnRlclkqY2VudGVyWTtcblxuICAgICAgICB2YXIgY2VudGVyWiA9IGIucG9zaXRpb24uejtcbiAgICAgICAgc3VtWiArPSBjZW50ZXJaO1xuICAgICAgICBzdW1aMiArPSBjZW50ZXJaKmNlbnRlclo7XG4gICAgfVxuXG4gICAgdmFyIHZhcmlhbmNlWCA9IHN1bVgyIC0gc3VtWCpzdW1YKmludk4sXG4gICAgICAgIHZhcmlhbmNlWSA9IHN1bVkyIC0gc3VtWSpzdW1ZKmludk4sXG4gICAgICAgIHZhcmlhbmNlWiA9IHN1bVoyIC0gc3VtWipzdW1aKmludk47XG5cbiAgICBpZih2YXJpYW5jZVggPiB2YXJpYW5jZVkpe1xuICAgICAgICBpZih2YXJpYW5jZVggPiB2YXJpYW5jZVope1xuICAgICAgICAgICAgdGhpcy5heGlzSW5kZXggPSAwO1xuICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICB0aGlzLmF4aXNJbmRleCA9IDI7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYodmFyaWFuY2VZID4gdmFyaWFuY2VaKXtcbiAgICAgICAgdGhpcy5heGlzSW5kZXggPSAxO1xuICAgIH0gZWxzZXtcbiAgICAgICAgdGhpcy5heGlzSW5kZXggPSAyO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gYW4gQUFCQi5cbiAqIEBtZXRob2QgYWFiYlF1ZXJ5XG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKHdvcmxkLCBhYWJiLCByZXN1bHQpe1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICAgIGlmKHRoaXMuZGlydHkpe1xuICAgICAgICB0aGlzLnNvcnRMaXN0KCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXgsIGF4aXMgPSAneCc7XG4gICAgaWYoYXhpc0luZGV4ID09PSAxKXsgYXhpcyA9ICd5JzsgfVxuICAgIGlmKGF4aXNJbmRleCA9PT0gMil7IGF4aXMgPSAneic7IH1cblxuICAgIHZhciBheGlzTGlzdCA9IHRoaXMuYXhpc0xpc3Q7XG4gICAgdmFyIGxvd2VyID0gYWFiYi5sb3dlckJvdW5kW2F4aXNdO1xuICAgIHZhciB1cHBlciA9IGFhYmIudXBwZXJCb3VuZFtheGlzXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXhpc0xpc3QubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgYiA9IGF4aXNMaXN0W2ldO1xuXG4gICAgICAgIGlmKGIuYWFiYk5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIGIuY29tcHV0ZUFBQkIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGIuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gQ29uZVR3aXN0Q29uc3RyYWludDtcblxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBQb2ludFRvUG9pbnRDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Qb2ludFRvUG9pbnRDb25zdHJhaW50Jyk7XG52YXIgQ29uZUVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0NvbmVFcXVhdGlvbicpO1xudmFyIFJvdGF0aW9uYWxFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsRXF1YXRpb24nKTtcbnZhciBDb250YWN0RXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xuXG4vKipcbiAqIEBjbGFzcyBDb25lVHdpc3RDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMucGl2b3RBXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5waXZvdEJdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNBXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQl1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZT0xZTZdXG4gKiBAZXh0ZW5kcyBQb2ludFRvUG9pbnRDb25zdHJhaW50XG4gKi9cbmZ1bmN0aW9uIENvbmVUd2lzdENvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgbWF4Rm9yY2UgPSB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhGb3JjZSA6IDFlNjtcblxuICAgIC8vIFNldCBwaXZvdCBwb2ludCBpbiBiZXR3ZWVuXG4gICAgdmFyIHBpdm90QSA9IG9wdGlvbnMucGl2b3RBID8gb3B0aW9ucy5waXZvdEEuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG4gICAgdmFyIHBpdm90QiA9IG9wdGlvbnMucGl2b3RCID8gb3B0aW9ucy5waXZvdEIuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5heGlzQSA9IG9wdGlvbnMuYXhpc0EgPyBvcHRpb25zLmF4aXNBLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoKTtcblxuICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQuY2FsbCh0aGlzLCBib2R5QSwgcGl2b3RBLCBib2R5QiwgcGl2b3RCLCBtYXhGb3JjZSk7XG5cbiAgICB0aGlzLmNvbGxpZGVDb25uZWN0ZWQgPSAhIW9wdGlvbnMuY29sbGlkZUNvbm5lY3RlZDtcblxuICAgIHRoaXMuYW5nbGUgPSB0eXBlb2Yob3B0aW9ucy5hbmdsZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5hbmdsZSA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0NvbmVFcXVhdGlvbn0gY29uZUVxdWF0aW9uXG4gICAgICovXG4gICAgdmFyIGMgPSB0aGlzLmNvbmVFcXVhdGlvbiA9IG5ldyBDb25lRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gdHdpc3RFcXVhdGlvblxuICAgICAqL1xuICAgIHZhciB0ID0gdGhpcy50d2lzdEVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSxib2R5QixvcHRpb25zKTtcbiAgICB0aGlzLnR3aXN0QW5nbGUgPSB0eXBlb2Yob3B0aW9ucy50d2lzdEFuZ2xlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnR3aXN0QW5nbGUgOiAwO1xuXG4gICAgLy8gTWFrZSB0aGUgY29uZSBlcXVhdGlvbiBwdXNoIHRoZSBib2RpZXMgdG93YXJkIHRoZSBjb25lIGF4aXMsIG5vdCBvdXR3YXJkXG4gICAgYy5tYXhGb3JjZSA9IDA7XG4gICAgYy5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcblxuICAgIC8vIE1ha2UgdGhlIHR3aXN0IGVxdWF0aW9uIGFkZCB0b3JxdWUgdG93YXJkIHRoZSBpbml0aWFsIHBvc2l0aW9uXG4gICAgdC5tYXhGb3JjZSA9IDA7XG4gICAgdC5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcblxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2goYywgdCk7XG59XG5Db25lVHdpc3RDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KCk7XG5Db25lVHdpc3RDb25zdHJhaW50LmNvbnN0cnVjdG9yID0gQ29uZVR3aXN0Q29uc3RyYWludDtcblxudmFyIENvbmVUd2lzdENvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEgPSBuZXcgVmVjMygpO1xudmFyIENvbmVUd2lzdENvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzIgPSBuZXcgVmVjMygpO1xuXG5Db25lVHdpc3RDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgY29uZSA9IHRoaXMuY29uZUVxdWF0aW9uLFxuICAgICAgICB0d2lzdCA9IHRoaXMudHdpc3RFcXVhdGlvbjtcblxuICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBheGVzIHRvIHRoZSBjb25lIGNvbnN0cmFpbnRcbiAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy5heGlzQSwgY29uZS5heGlzQSk7XG4gICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMuYXhpc0IsIGNvbmUuYXhpc0IpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSB3b3JsZCBheGVzIGluIHRoZSB0d2lzdCBjb25zdHJhaW50XG4gICAgdGhpcy5heGlzQS50YW5nZW50cyh0d2lzdC5heGlzQSwgdHdpc3QuYXhpc0EpO1xuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0d2lzdC5heGlzQSwgdHdpc3QuYXhpc0EpO1xuXG4gICAgdGhpcy5heGlzQi50YW5nZW50cyh0d2lzdC5heGlzQiwgdHdpc3QuYXhpc0IpO1xuICAgIGJvZHlCLnZlY3RvclRvV29ybGRGcmFtZSh0d2lzdC5heGlzQiwgdHdpc3QuYXhpc0IpO1xuXG4gICAgY29uZS5hbmdsZSA9IHRoaXMuYW5nbGU7XG4gICAgdHdpc3QubWF4QW5nbGUgPSB0aGlzLnR3aXN0QW5nbGU7XG59O1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IENvbnN0cmFpbnQ7XG5cbnZhciBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJyk7XG5cbi8qKlxuICogQ29uc3RyYWludCBiYXNlIGNsYXNzXG4gKiBAY2xhc3MgQ29uc3RyYWludFxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ9dHJ1ZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMud2FrZVVwQm9kaWVzPXRydWVdXG4gKi9cbmZ1bmN0aW9uIENvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucyx7XG4gICAgICAgIGNvbGxpZGVDb25uZWN0ZWQgOiB0cnVlLFxuICAgICAgICB3YWtlVXBCb2RpZXMgOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogRXF1YXRpb25zIHRvIGJlIHNvbHZlZCBpbiB0aGlzIGNvbnN0cmFpbnRcbiAgICAgKiBAcHJvcGVydHkgZXF1YXRpb25zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlBXG4gICAgICovXG4gICAgdGhpcy5ib2R5QSA9IGJvZHlBO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb2R5fSBib2R5QlxuICAgICAqL1xuICAgIHRoaXMuYm9keUIgPSBib2R5QjtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZFxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBDb25zdHJhaW50LmlkQ291bnRlcisrO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdGhlIGJvZGllcyB0byBjb2xsaWRlIHdoZW4gdGhleSBhcmUgY29ubmVjdGVkLlxuICAgICAqIEBwcm9wZXJ0eSBjb2xsaWRlQ29ubmVjdGVkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkO1xuXG4gICAgaWYob3B0aW9ucy53YWtlVXBCb2RpZXMpe1xuICAgICAgICBpZihib2R5QSl7XG4gICAgICAgICAgICBib2R5QS53YWtlVXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZihib2R5Qil7XG4gICAgICAgICAgICBib2R5Qi53YWtlVXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBVcGRhdGUgYWxsIHRoZSBlcXVhdGlvbnMgd2l0aCBkYXRhLlxuICogQG1ldGhvZCB1cGRhdGVcbiAqL1xuQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXRob2QgdXBkYXRlKCkgbm90IGltcGxtZW1lbnRlZCBpbiB0aGlzIENvbnN0cmFpbnQgc3ViY2xhc3MhXCIpO1xufTtcblxuLyoqXG4gKiBFbmFibGVzIGFsbCBlcXVhdGlvbnMgaW4gdGhlIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIGVuYWJsZVxuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBmb3IodmFyIGk9MDsgaTxlcXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBlcXNbaV0uZW5hYmxlZCA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBEaXNhYmxlcyBhbGwgZXF1YXRpb25zIGluIHRoZSBjb25zdHJhaW50LlxuICogQG1ldGhvZCBkaXNhYmxlXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICBmb3IodmFyIGk9MDsgaTxlcXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBlcXNbaV0uZW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbkNvbnN0cmFpbnQuaWRDb3VudGVyID0gMDtcbiIsIm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2VDb25zdHJhaW50O1xuXG52YXIgQ29uc3RyYWludCA9IHJlcXVpcmUoJy4vQ29uc3RyYWludCcpO1xudmFyIENvbnRhY3RFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcblxuLyoqXG4gKiBDb25zdHJhaW5zIHR3byBib2RpZXMgdG8gYmUgYXQgYSBjb25zdGFudCBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXJzIGNlbnRlciBvZiBtYXNzLlxuICogQGNsYXNzIERpc3RhbmNlQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge051bWJlcn0gW2Rpc3RhbmNlXSBUaGUgZGlzdGFuY2UgdG8ga2VlcC4gSWYgdW5kZWZpbmVkLCBpdCB3aWxsIGJlIHNldCB0byB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIGJvZHlBIGFuZCBib2R5QlxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXhGb3JjZT0xZTZdXG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKi9cbmZ1bmN0aW9uIERpc3RhbmNlQ29uc3RyYWludChib2R5QSxib2R5QixkaXN0YW5jZSxtYXhGb3JjZSl7XG4gICAgQ29uc3RyYWludC5jYWxsKHRoaXMsYm9keUEsYm9keUIpO1xuXG4gICAgaWYodHlwZW9mKGRpc3RhbmNlKT09PVwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZGlzdGFuY2UgPSBib2R5QS5wb3NpdGlvbi5kaXN0YW5jZVRvKGJvZHlCLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBpZih0eXBlb2YobWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIikge1xuICAgICAgICBtYXhGb3JjZSA9IDFlNjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGlzdGFuY2VcbiAgICAgKi9cbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0NvbnRhY3RFcXVhdGlvbn0gZGlzdGFuY2VFcXVhdGlvblxuICAgICAqL1xuICAgIHZhciBlcSA9IHRoaXMuZGlzdGFuY2VFcXVhdGlvbiA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCKTtcbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGVxKTtcblxuICAgIC8vIE1ha2UgaXQgYmlkaXJlY3Rpb25hbFxuICAgIGVxLm1pbkZvcmNlID0gLW1heEZvcmNlO1xuICAgIGVxLm1heEZvcmNlID0gIG1heEZvcmNlO1xufVxuRGlzdGFuY2VDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5cbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBO1xuICAgIHZhciBib2R5QiA9IHRoaXMuYm9keUI7XG4gICAgdmFyIGVxID0gdGhpcy5kaXN0YW5jZUVxdWF0aW9uO1xuICAgIHZhciBoYWxmRGlzdCA9IHRoaXMuZGlzdGFuY2UgKiAwLjU7XG4gICAgdmFyIG5vcm1hbCA9IGVxLm5pO1xuXG4gICAgYm9keUIucG9zaXRpb24udnN1Yihib2R5QS5wb3NpdGlvbiwgbm9ybWFsKTtcbiAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgbm9ybWFsLm11bHQoaGFsZkRpc3QsIGVxLnJpKTtcbiAgICBub3JtYWwubXVsdCgtaGFsZkRpc3QsIGVxLnJqKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBIaW5nZUNvbnN0cmFpbnQ7XG5cbnZhciBDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Db25zdHJhaW50Jyk7XG52YXIgUG9pbnRUb1BvaW50Q29uc3RyYWludCA9IHJlcXVpcmUoJy4vUG9pbnRUb1BvaW50Q29uc3RyYWludCcpO1xudmFyIFJvdGF0aW9uYWxFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsRXF1YXRpb24nKTtcbnZhciBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbicpO1xudmFyIENvbnRhY3RFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG5cbi8qKlxuICogSGluZ2UgY29uc3RyYWludC4gVGhpbmsgb2YgaXQgYXMgYSBkb29yIGhpbmdlLiBJdCB0cmllcyB0byBrZWVwIHRoZSBkb29yIGluIHRoZSBjb3JyZWN0IHBsYWNlIGFuZCB3aXRoIHRoZSBjb3JyZWN0IG9yaWVudGF0aW9uLlxuICogQGNsYXNzIEhpbmdlQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBpdm90QV0gQSBwb2ludCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEuIFRoaXMgZGVmaW5lcyB0aGUgb2Zmc2V0IG9mIGF4aXNBLlxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQV0gQW4gYXhpcyB0aGF0IGJvZHlBIGNhbiByb3RhdGUgYXJvdW5kLCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEuXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBpdm90Ql1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0JdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4Rm9yY2U9MWU2XVxuICogQGV4dGVuZHMgUG9pbnRUb1BvaW50Q29uc3RyYWludFxuICovXG5mdW5jdGlvbiBIaW5nZUNvbnN0cmFpbnQoYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgbWF4Rm9yY2UgPSB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhGb3JjZSA6IDFlNjtcbiAgICB2YXIgcGl2b3RBID0gb3B0aW9ucy5waXZvdEEgPyBvcHRpb25zLnBpdm90QS5jbG9uZSgpIDogbmV3IFZlYzMoKTtcbiAgICB2YXIgcGl2b3RCID0gb3B0aW9ucy5waXZvdEIgPyBvcHRpb25zLnBpdm90Qi5jbG9uZSgpIDogbmV3IFZlYzMoKTtcblxuICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQuY2FsbCh0aGlzLCBib2R5QSwgcGl2b3RBLCBib2R5QiwgcGl2b3RCLCBtYXhGb3JjZSk7XG5cbiAgICAvKipcbiAgICAgKiBSb3RhdGlvbiBheGlzLCBkZWZpbmVkIGxvY2FsbHkgaW4gYm9keUEuXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBheGlzQVxuICAgICAqL1xuICAgIHZhciBheGlzQSA9IHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwwLDApO1xuICAgIGF4aXNBLm5vcm1hbGl6ZSgpO1xuXG4gICAgLyoqXG4gICAgICogUm90YXRpb24gYXhpcywgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlCLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0JcbiAgICAgKi9cbiAgICB2YXIgYXhpc0IgPSB0aGlzLmF4aXNCID0gb3B0aW9ucy5heGlzQiA/IG9wdGlvbnMuYXhpc0IuY2xvbmUoKSA6IG5ldyBWZWMzKDEsMCwwKTtcbiAgICBheGlzQi5ub3JtYWxpemUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Um90YXRpb25hbEVxdWF0aW9ufSByb3RhdGlvbmFsRXF1YXRpb24xXG4gICAgICovXG4gICAgdmFyIHIxID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24xID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSxib2R5QixvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Um90YXRpb25hbEVxdWF0aW9ufSByb3RhdGlvbmFsRXF1YXRpb24yXG4gICAgICovXG4gICAgdmFyIHIyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSxib2R5QixvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Um90YXRpb25hbE1vdG9yRXF1YXRpb259IG1vdG9yRXF1YXRpb25cbiAgICAgKi9cbiAgICB2YXIgbW90b3IgPSB0aGlzLm1vdG9yRXF1YXRpb24gPSBuZXcgUm90YXRpb25hbE1vdG9yRXF1YXRpb24oYm9keUEsYm9keUIsbWF4Rm9yY2UpO1xuICAgIG1vdG9yLmVuYWJsZWQgPSBmYWxzZTsgLy8gTm90IGVuYWJsZWQgYnkgZGVmYXVsdFxuXG4gICAgLy8gRXF1YXRpb25zIHRvIGJlIGZlZCB0byB0aGUgc29sdmVyXG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaChcbiAgICAgICAgcjEsIC8vIHJvdGF0aW9uYWwxXG4gICAgICAgIHIyLCAvLyByb3RhdGlvbmFsMlxuICAgICAgICBtb3RvclxuICAgICk7XG59XG5IaW5nZUNvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IFBvaW50VG9Qb2ludENvbnN0cmFpbnQoKTtcbkhpbmdlQ29uc3RyYWludC5jb25zdHJ1Y3RvciA9IEhpbmdlQ29uc3RyYWludDtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZU1vdG9yXG4gKi9cbkhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUuZW5hYmxlTW90b3IgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlTW90b3JcbiAqL1xuSGluZ2VDb25zdHJhaW50LnByb3RvdHlwZS5kaXNhYmxlTW90b3IgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0TW90b3JTcGVlZFxuICogQHBhcmFtIHtudW1iZXJ9IHNwZWVkXG4gKi9cbkhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uKHNwZWVkKXtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24udGFyZ2V0VmVsb2NpdHkgPSBzcGVlZDtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzZXRNb3Rvck1heEZvcmNlXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4Rm9yY2VcbiAqL1xuSGluZ2VDb25zdHJhaW50LnByb3RvdHlwZS5zZXRNb3Rvck1heEZvcmNlID0gZnVuY3Rpb24obWF4Rm9yY2Upe1xuICAgIHRoaXMubW90b3JFcXVhdGlvbi5tYXhGb3JjZSA9IG1heEZvcmNlO1xuICAgIHRoaXMubW90b3JFcXVhdGlvbi5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcbn07XG5cbnZhciBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEgPSBuZXcgVmVjMygpO1xudmFyIEhpbmdlQ29uc3RyYWludF91cGRhdGVfdG1wVmVjMiA9IG5ldyBWZWMzKCk7XG5cbkhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIG1vdG9yID0gdGhpcy5tb3RvckVxdWF0aW9uLFxuICAgICAgICByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSxcbiAgICAgICAgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIsXG4gICAgICAgIHdvcmxkQXhpc0EgPSBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEsXG4gICAgICAgIHdvcmxkQXhpc0IgPSBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzI7XG5cbiAgICB2YXIgYXhpc0EgPSB0aGlzLmF4aXNBO1xuICAgIHZhciBheGlzQiA9IHRoaXMuYXhpc0I7XG5cbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgIC8vIEdldCB3b3JsZCBheGVzXG4gICAgYm9keUEucXVhdGVybmlvbi52bXVsdChheGlzQSwgd29ybGRBeGlzQSk7XG4gICAgYm9keUIucXVhdGVybmlvbi52bXVsdChheGlzQiwgd29ybGRBeGlzQik7XG5cbiAgICB3b3JsZEF4aXNBLnRhbmdlbnRzKHIxLmF4aXNBLCByMi5heGlzQSk7XG4gICAgcjEuYXhpc0IuY29weSh3b3JsZEF4aXNCKTtcbiAgICByMi5heGlzQi5jb3B5KHdvcmxkQXhpc0IpO1xuXG4gICAgaWYodGhpcy5tb3RvckVxdWF0aW9uLmVuYWJsZWQpe1xuICAgICAgICBib2R5QS5xdWF0ZXJuaW9uLnZtdWx0KHRoaXMuYXhpc0EsIG1vdG9yLmF4aXNBKTtcbiAgICAgICAgYm9keUIucXVhdGVybmlvbi52bXVsdCh0aGlzLmF4aXNCLCBtb3Rvci5heGlzQik7XG4gICAgfVxufTtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSBMb2NrQ29uc3RyYWludDtcblxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBQb2ludFRvUG9pbnRDb25zdHJhaW50ID0gcmVxdWlyZSgnLi9Qb2ludFRvUG9pbnRDb25zdHJhaW50Jyk7XG52YXIgUm90YXRpb25hbEVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvbicpO1xudmFyIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxNb3RvckVxdWF0aW9uJyk7XG52YXIgQ29udGFjdEVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcblxuLyoqXG4gKiBMb2NrIGNvbnN0cmFpbnQuIFdpbGwgcmVtb3ZlIGFsbCBkZWdyZWVzIG9mIGZyZWVkb20gYmV0d2VlbiB0aGUgYm9kaWVzLlxuICogQGNsYXNzIExvY2tDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZT0xZTZdXG4gKiBAZXh0ZW5kcyBQb2ludFRvUG9pbnRDb25zdHJhaW50XG4gKi9cbmZ1bmN0aW9uIExvY2tDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIG1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG5cbiAgICAvLyBTZXQgcGl2b3QgcG9pbnQgaW4gYmV0d2VlblxuICAgIHZhciBwaXZvdEEgPSBuZXcgVmVjMygpO1xuICAgIHZhciBwaXZvdEIgPSBuZXcgVmVjMygpO1xuICAgIHZhciBoYWxmV2F5ID0gbmV3IFZlYzMoKTtcbiAgICBib2R5QS5wb3NpdGlvbi52YWRkKGJvZHlCLnBvc2l0aW9uLCBoYWxmV2F5KTtcbiAgICBoYWxmV2F5LnNjYWxlKDAuNSwgaGFsZldheSk7XG4gICAgYm9keUIucG9pbnRUb0xvY2FsRnJhbWUoaGFsZldheSwgcGl2b3RCKTtcbiAgICBib2R5QS5wb2ludFRvTG9jYWxGcmFtZShoYWxmV2F5LCBwaXZvdEEpO1xuXG4gICAgLy8gVGhlIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnQgd2lsbCBrZWVwIGEgcG9pbnQgc2hhcmVkIGJldHdlZW4gdGhlIGJvZGllc1xuICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQuY2FsbCh0aGlzLCBib2R5QSwgcGl2b3RBLCBib2R5QiwgcGl2b3RCLCBtYXhGb3JjZSk7XG5cbiAgICAvLyBTdG9yZSBpbml0aWFsIHJvdGF0aW9uIG9mIHRoZSBib2RpZXMgYXMgdW5pdCB2ZWN0b3JzIGluIHRoZSBsb2NhbCBib2R5IHNwYWNlc1xuICAgIHRoaXMueEEgPSBib2R5QS52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1gpO1xuICAgIHRoaXMueEIgPSBib2R5Qi52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1gpO1xuICAgIHRoaXMueUEgPSBib2R5QS52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1kpO1xuICAgIHRoaXMueUIgPSBib2R5Qi52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1kpO1xuICAgIHRoaXMuekEgPSBib2R5QS52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1opO1xuICAgIHRoaXMuekIgPSBib2R5Qi52ZWN0b3JUb0xvY2FsRnJhbWUoVmVjMy5VTklUX1opO1xuXG4gICAgLy8gLi4uYW5kIHRoZSBmb2xsb3dpbmcgcm90YXRpb25hbCBlcXVhdGlvbnMgd2lsbCBrZWVwIGFsbCByb3RhdGlvbmFsIERPRidzIGluIHBsYWNlXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uMVxuICAgICAqL1xuICAgIHZhciByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uMlxuICAgICAqL1xuICAgIHZhciByMiA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMiA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uM1xuICAgICAqL1xuICAgIHZhciByMyA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMyA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XG5cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHIxLCByMiwgcjMpO1xufVxuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IFBvaW50VG9Qb2ludENvbnN0cmFpbnQoKTtcbkxvY2tDb25zdHJhaW50LmNvbnN0cnVjdG9yID0gTG9ja0NvbnN0cmFpbnQ7XG5cbnZhciBMb2NrQ29uc3RyYWludF91cGRhdGVfdG1wVmVjMSA9IG5ldyBWZWMzKCk7XG52YXIgTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzIgPSBuZXcgVmVjMygpO1xuXG5Mb2NrQ29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIG1vdG9yID0gdGhpcy5tb3RvckVxdWF0aW9uLFxuICAgICAgICByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSxcbiAgICAgICAgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIsXG4gICAgICAgIHIzID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24zLFxuICAgICAgICB3b3JsZEF4aXNBID0gTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEsXG4gICAgICAgIHdvcmxkQXhpc0IgPSBMb2NrQ29uc3RyYWludF91cGRhdGVfdG1wVmVjMjtcblxuICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gICAgLy8gVGhlc2UgdmVjdG9yIHBhaXJzIG11c3QgYmUgb3J0aG9nb25hbFxuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnhBLCByMS5heGlzQSk7XG4gICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMueUIsIHIxLmF4aXNCKTtcblxuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnlBLCByMi5heGlzQSk7XG4gICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMuekIsIHIyLmF4aXNCKTtcblxuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLnpBLCByMy5heGlzQSk7XG4gICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMueEIsIHIzLmF4aXNCKTtcbn07XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gUG9pbnRUb1BvaW50Q29uc3RyYWludDtcblxudmFyIENvbnN0cmFpbnQgPSByZXF1aXJlKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBDb250YWN0RXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xuXG4vKipcbiAqIENvbm5lY3RzIHR3byBib2RpZXMgYXQgZ2l2ZW4gb2Zmc2V0IHBvaW50cy5cbiAqIEBjbGFzcyBQb2ludFRvUG9pbnRDb25zdHJhaW50XG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7VmVjM30gcGl2b3RBIFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgYm9keUEgd2hpY2ggYm9keUEgaXMgY29uc3RyYWluZWQgdG8uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCIEJvZHkgdGhhdCB3aWxsIGJlIGNvbnN0cmFpbmVkIGluIGEgc2ltaWxhciB3YXkgdG8gdGhlIHNhbWUgcG9pbnQgYXMgYm9keUEuIFdlIHdpbGwgdGhlcmVmb3JlIGdldCBhIGxpbmsgYmV0d2VlbiBib2R5QSBhbmQgYm9keUIuIElmIG5vdCBzcGVjaWZpZWQsIGJvZHlBIHdpbGwgYmUgY29uc3RyYWluZWQgdG8gYSBzdGF0aWMgcG9pbnQuXG4gKiBAcGFyYW0ge1ZlYzN9IHBpdm90QiBTZWUgcGl2b3RBLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEZvcmNlIFRoZSBtYXhpbXVtIGZvcmNlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gY29uc3RyYWluIHRoZSBib2RpZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XG4gKiAgICAgdmFyIGJvZHlCID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xuICogICAgIGJvZHlBLnBvc2l0aW9uLnNldCgtMSwgMCwgMCk7XG4gKiAgICAgYm9keUIucG9zaXRpb24uc2V0KDEsIDAsIDApO1xuICogICAgIGJvZHlBLmFkZFNoYXBlKHNoYXBlQSk7XG4gKiAgICAgYm9keUIuYWRkU2hhcGUoc2hhcGVCKTtcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHlBKTtcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHlCKTtcbiAqICAgICB2YXIgbG9jYWxQaXZvdEEgPSBuZXcgVmVjMygxLCAwLCAwKTtcbiAqICAgICB2YXIgbG9jYWxQaXZvdEIgPSBuZXcgVmVjMygtMSwgMCwgMCk7XG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgUG9pbnRUb1BvaW50Q29uc3RyYWludChib2R5QSwgbG9jYWxQaXZvdEEsIGJvZHlCLCBsb2NhbFBpdm90Qik7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqL1xuZnVuY3Rpb24gUG9pbnRUb1BvaW50Q29uc3RyYWludChib2R5QSxwaXZvdEEsYm9keUIscGl2b3RCLG1heEZvcmNlKXtcbiAgICBDb25zdHJhaW50LmNhbGwodGhpcyxib2R5QSxib2R5Qik7XG5cbiAgICBtYXhGb3JjZSA9IHR5cGVvZihtYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gbWF4Rm9yY2UgOiAxZTY7XG5cbiAgICAvKipcbiAgICAgKiBQaXZvdCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcGl2b3RBXG4gICAgICovXG4gICAgdGhpcy5waXZvdEEgPSBwaXZvdEEgPyBwaXZvdEEuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBQaXZvdCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlCLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcGl2b3RCXG4gICAgICovXG4gICAgdGhpcy5waXZvdEIgPSBwaXZvdEIgPyBwaXZvdEIuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0NvbnRhY3RFcXVhdGlvbn0gZXF1YXRpb25YXG4gICAgICovXG4gICAgdmFyIHggPSB0aGlzLmVxdWF0aW9uWCA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0RXF1YXRpb259IGVxdWF0aW9uWVxuICAgICAqL1xuICAgIHZhciB5ID0gdGhpcy5lcXVhdGlvblkgPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdEVxdWF0aW9ufSBlcXVhdGlvblpcbiAgICAgKi9cbiAgICB2YXIgeiA9IHRoaXMuZXF1YXRpb25aID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5Qik7XG5cbiAgICAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXJcbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHgsIHksIHopO1xuXG4gICAgLy8gTWFrZSB0aGUgZXF1YXRpb25zIGJpZGlyZWN0aW9uYWxcbiAgICB4Lm1pbkZvcmNlID0geS5taW5Gb3JjZSA9IHoubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG4gICAgeC5tYXhGb3JjZSA9IHkubWF4Rm9yY2UgPSB6Lm1heEZvcmNlID0gIG1heEZvcmNlO1xuXG4gICAgeC5uaS5zZXQoMSwgMCwgMCk7XG4gICAgeS5uaS5zZXQoMCwgMSwgMCk7XG4gICAgei5uaS5zZXQoMCwgMCwgMSk7XG59XG5Qb2ludFRvUG9pbnRDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5cblBvaW50VG9Qb2ludENvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QTtcbiAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCO1xuICAgIHZhciB4ID0gdGhpcy5lcXVhdGlvblg7XG4gICAgdmFyIHkgPSB0aGlzLmVxdWF0aW9uWTtcbiAgICB2YXIgeiA9IHRoaXMuZXF1YXRpb25aO1xuXG4gICAgLy8gUm90YXRlIHRoZSBwaXZvdHMgdG8gd29ybGQgc3BhY2VcbiAgICBib2R5QS5xdWF0ZXJuaW9uLnZtdWx0KHRoaXMucGl2b3RBLHgucmkpO1xuICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQodGhpcy5waXZvdEIseC5yaik7XG5cbiAgICB5LnJpLmNvcHkoeC5yaSk7XG4gICAgeS5yai5jb3B5KHgucmopO1xuICAgIHoucmkuY29weSh4LnJpKTtcbiAgICB6LnJqLmNvcHkoeC5yaik7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gQ29uZUVxdWF0aW9uO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIE1hdDMgPSByZXF1aXJlKCcuLi9tYXRoL01hdDMnKTtcbnZhciBFcXVhdGlvbiA9IHJlcXVpcmUoJy4vRXF1YXRpb24nKTtcblxuLyoqXG4gKiBDb25lIGVxdWF0aW9uLiBXb3JrcyB0byBrZWVwIHRoZSBnaXZlbiBib2R5IHdvcmxkIHZlY3RvcnMgYWxpZ25lZCwgb3IgdGlsdGVkIHdpdGhpbiBhIGdpdmVuIGFuZ2xlIGZyb20gZWFjaCBvdGhlci5cbiAqIEBjbGFzcyBDb25lRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQV0gTG9jYWwgYXhpcyBpbiBBXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNCXSBMb2NhbCBheGlzIGluIEJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYW5nbGVdIFRoZSBcImNvbmUgYW5nbGVcIiB0byBrZWVwXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4Rm9yY2U9MWU2XVxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqL1xuZnVuY3Rpb24gQ29uZUVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIG1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG5cbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsYm9keUEsYm9keUIsLW1heEZvcmNlLCBtYXhGb3JjZSk7XG5cbiAgICB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKDEsIDAsIDApO1xuICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMCwgMSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29uZSBhbmdsZSB0byBrZWVwXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFuZ2xlXG4gICAgICovXG4gICAgdGhpcy5hbmdsZSA9IHR5cGVvZihvcHRpb25zLmFuZ2xlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ2xlIDogMDtcbn1cblxuQ29uZUVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuQ29uZUVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbmVFcXVhdGlvbjtcblxudmFyIHRtcFZlYzEgPSBuZXcgVmVjMygpO1xudmFyIHRtcFZlYzIgPSBuZXcgVmVjMygpO1xuXG5Db25lRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oaCl7XG4gICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG5cbiAgICAgICAgbmkgPSB0aGlzLmF4aXNBLFxuICAgICAgICBuaiA9IHRoaXMuYXhpc0IsXG5cbiAgICAgICAgbml4bmogPSB0bXBWZWMxLFxuICAgICAgICBuanhuaSA9IHRtcFZlYzIsXG5cbiAgICAgICAgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCO1xuXG4gICAgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzXG4gICAgbmkuY3Jvc3MobmosIG5peG5qKTtcbiAgICBuai5jcm9zcyhuaSwgbmp4bmkpO1xuXG4gICAgLy8gVGhlIGFuZ2xlIGJldHdlZW4gdHdvIHZlY3RvciBpczpcbiAgICAvLyBjb3ModGhldGEpID0gYSAqIGIgLyAobGVuZ3RoKGEpICogbGVuZ3RoKGIpID0geyBsZW4oYSkgPSBsZW4oYikgPSAxIH0gPSBhICogYlxuXG4gICAgLy8gZyA9IGEgKiBiXG4gICAgLy8gZ2RvdCA9IChiIHggYSkgKiB3aSArIChhIHggYikgKiB3alxuICAgIC8vIEcgPSBbMCBieGEgMCBheGJdXG4gICAgLy8gVyA9IFt2aSB3aSB2aiB3al1cbiAgICBHQS5yb3RhdGlvbmFsLmNvcHkobmp4bmkpO1xuICAgIEdCLnJvdGF0aW9uYWwuY29weShuaXhuaik7XG5cbiAgICB2YXIgZyA9IE1hdGguY29zKHRoaXMuYW5nbGUpIC0gbmkuZG90KG5qKSxcbiAgICAgICAgR1cgPSB0aGlzLmNvbXB1dGVHVygpLFxuICAgICAgICBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuXG4gICAgdmFyIEIgPSAtIGcgKiBhIC0gR1cgKiBiIC0gaCAqIEdpTWY7XG5cbiAgICByZXR1cm4gQjtcbn07XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gQ29udGFjdEVxdWF0aW9uO1xuXG52YXIgRXF1YXRpb24gPSByZXF1aXJlKCcuL0VxdWF0aW9uJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIE1hdDMgPSByZXF1aXJlKCcuLi9tYXRoL01hdDMnKTtcblxuLyoqXG4gKiBDb250YWN0L25vbi1wZW5ldHJhdGlvbiBjb25zdHJhaW50IGVxdWF0aW9uXG4gKiBAY2xhc3MgQ29udGFjdEVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKi9cbmZ1bmN0aW9uIENvbnRhY3RFcXVhdGlvbihib2R5QSwgYm9keUIsIG1heEZvcmNlKXtcbiAgICBtYXhGb3JjZSA9IHR5cGVvZihtYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gbWF4Rm9yY2UgOiAxZTY7XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIDAsIG1heEZvcmNlKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSByZXN0aXR1dGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IDAuMDsgLy8gXCJib3VuY2luZXNzXCI6IHUxID0gLWUqdTBcblxuICAgIC8qKlxuICAgICAqIFdvcmxkLW9yaWVudGVkIHZlY3RvciB0aGF0IGdvZXMgZnJvbSB0aGUgY2VudGVyIG9mIGJpIHRvIHRoZSBjb250YWN0IHBvaW50LlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcmlcbiAgICAgKi9cbiAgICB0aGlzLnJpID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIFdvcmxkLW9yaWVudGVkIHZlY3RvciB0aGF0IHN0YXJ0cyBpbiBib2R5IGogcG9zaXRpb24gYW5kIGdvZXMgdG8gdGhlIGNvbnRhY3QgcG9pbnQuXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSByalxuICAgICAqL1xuICAgIHRoaXMucmogPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQ29udGFjdCBub3JtYWwsIHBvaW50aW5nIG91dCBvZiBib2R5IGkuXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBuaVxuICAgICAqL1xuICAgIHRoaXMubmkgPSBuZXcgVmVjMygpO1xufVxuXG5Db250YWN0RXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Db250YWN0RXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udGFjdEVxdWF0aW9uO1xuXG52YXIgQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAxID0gbmV3IFZlYzMoKTsgLy8gVGVtcCB2ZWN0b3JzXG52YXIgQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyID0gbmV3IFZlYzMoKTtcbnZhciBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDMgPSBuZXcgVmVjMygpO1xuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGgpe1xuICAgIHZhciBhID0gdGhpcy5hLFxuICAgICAgICBiID0gdGhpcy5iLFxuICAgICAgICBiaSA9IHRoaXMuYmksXG4gICAgICAgIGJqID0gdGhpcy5iaixcbiAgICAgICAgcmkgPSB0aGlzLnJpLFxuICAgICAgICByaiA9IHRoaXMucmosXG4gICAgICAgIHJpeG4gPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDEsXG4gICAgICAgIHJqeG4gPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDIsXG5cbiAgICAgICAgdmkgPSBiaS52ZWxvY2l0eSxcbiAgICAgICAgd2kgPSBiaS5hbmd1bGFyVmVsb2NpdHksXG4gICAgICAgIGZpID0gYmkuZm9yY2UsXG4gICAgICAgIHRhdWkgPSBiaS50b3JxdWUsXG5cbiAgICAgICAgdmogPSBiai52ZWxvY2l0eSxcbiAgICAgICAgd2ogPSBiai5hbmd1bGFyVmVsb2NpdHksXG4gICAgICAgIGZqID0gYmouZm9yY2UsXG4gICAgICAgIHRhdWogPSBiai50b3JxdWUsXG5cbiAgICAgICAgcGVuZXRyYXRpb25WZWMgPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDMsXG5cbiAgICAgICAgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxuXG4gICAgICAgIG4gPSB0aGlzLm5pO1xuXG4gICAgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzXG4gICAgcmkuY3Jvc3MobixyaXhuKTtcbiAgICByai5jcm9zcyhuLHJqeG4pO1xuXG4gICAgLy8gZyA9IHhqK3JqIC0oeGkrcmkpXG4gICAgLy8gRyA9IFsgLW5pICAtcml4biAgbmkgIHJqeG4gXVxuICAgIG4ubmVnYXRlKEdBLnNwYXRpYWwpO1xuICAgIHJpeG4ubmVnYXRlKEdBLnJvdGF0aW9uYWwpO1xuICAgIEdCLnNwYXRpYWwuY29weShuKTtcbiAgICBHQi5yb3RhdGlvbmFsLmNvcHkocmp4bik7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHBlbmV0cmF0aW9uIHZlY3RvclxuICAgIHBlbmV0cmF0aW9uVmVjLmNvcHkoYmoucG9zaXRpb24pO1xuICAgIHBlbmV0cmF0aW9uVmVjLnZhZGQocmoscGVuZXRyYXRpb25WZWMpO1xuICAgIHBlbmV0cmF0aW9uVmVjLnZzdWIoYmkucG9zaXRpb24scGVuZXRyYXRpb25WZWMpO1xuICAgIHBlbmV0cmF0aW9uVmVjLnZzdWIocmkscGVuZXRyYXRpb25WZWMpO1xuXG4gICAgdmFyIGcgPSBuLmRvdChwZW5ldHJhdGlvblZlYyk7XG5cbiAgICAvLyBDb21wdXRlIGl0ZXJhdGlvblxuICAgIHZhciBlUGx1c09uZSA9IHRoaXMucmVzdGl0dXRpb24gKyAxO1xuICAgIHZhciBHVyA9IGVQbHVzT25lICogdmouZG90KG4pIC0gZVBsdXNPbmUgKiB2aS5kb3QobikgKyB3ai5kb3Qocmp4bikgLSB3aS5kb3Qocml4bik7XG4gICAgdmFyIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG5cbiAgICB2YXIgQiA9IC0gZyAqIGEgLSBHVyAqIGIgLSBoKkdpTWY7XG5cbiAgICByZXR1cm4gQjtcbn07XG5cbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aSA9IG5ldyBWZWMzKCk7XG52YXIgQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfdmogPSBuZXcgVmVjMygpO1xudmFyIENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3hpID0gbmV3IFZlYzMoKTtcbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aiA9IG5ldyBWZWMzKCk7XG52YXIgQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfcmVsVmVsID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgcmVsYXRpdmUgdmVsb2NpdHkgaW4gdGhlIGNvbnRhY3QgcG9pbnQuXG4gKiBAbWV0aG9kIGdldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdmkgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aTtcbiAgICB2YXIgdmogPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92ajtcbiAgICB2YXIgeGkgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aTtcbiAgICB2YXIgeGogPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94ajtcbiAgICB2YXIgcmVsVmVsID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfcmVsVmVsO1xuXG4gICAgdGhpcy5iaS5wb3NpdGlvbi52YWRkKHRoaXMucmksIHhpKTtcbiAgICB0aGlzLmJqLnBvc2l0aW9uLnZhZGQodGhpcy5yaiwgeGopO1xuXG4gICAgdGhpcy5iaS5nZXRWZWxvY2l0eUF0V29ybGRQb2ludCh4aSwgdmkpO1xuICAgIHRoaXMuYmouZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoeGosIHZqKTtcblxuICAgIHZpLnZzdWIodmosIHJlbFZlbCk7XG5cbiAgICByZXR1cm4gdGhpcy5uaS5kb3QocmVsVmVsKTtcbn07XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gRXF1YXRpb247XG5cbnZhciBKYWNvYmlhbkVsZW1lbnQgPSByZXF1aXJlKCcuLi9tYXRoL0phY29iaWFuRWxlbWVudCcpLFxuICAgIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcblxuLyoqXG4gKiBFcXVhdGlvbiBiYXNlIGNsYXNzXG4gKiBAY2xhc3MgRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBiaVxuICogQHBhcmFtIHtCb2R5fSBialxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbkZvcmNlIE1pbmltdW0gKHJlYWQ6IG5lZ2F0aXZlIG1heCkgZm9yY2UgdG8gYmUgYXBwbGllZCBieSB0aGUgY29uc3RyYWludC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGb3JjZSBNYXhpbXVtIChyZWFkOiBwb3NpdGl2ZSBtYXgpIGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnQuXG4gKi9cbmZ1bmN0aW9uIEVxdWF0aW9uKGJpLGJqLG1pbkZvcmNlLG1heEZvcmNlKXtcbiAgICB0aGlzLmlkID0gRXF1YXRpb24uaWQrKztcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5Gb3JjZVxuICAgICAqL1xuICAgIHRoaXMubWluRm9yY2UgPSB0eXBlb2YobWluRm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IC0xZTYgOiBtaW5Gb3JjZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhGb3JjZVxuICAgICAqL1xuICAgIHRoaXMubWF4Rm9yY2UgPSB0eXBlb2YobWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IDFlNiA6IG1heEZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGJpXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5iaSA9IGJpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGJqXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5iaiA9IGJqO1xuXG4gICAgLyoqXG4gICAgICogU1BPT0sgcGFyYW1ldGVyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFcbiAgICAgKi9cbiAgICB0aGlzLmEgPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBTUE9PSyBwYXJhbWV0ZXJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYlxuICAgICAqL1xuICAgIHRoaXMuYiA9IDAuMDtcblxuICAgIC8qKlxuICAgICAqIFNQT09LIHBhcmFtZXRlclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlcHNcbiAgICAgKi9cbiAgICB0aGlzLmVwcyA9IDAuMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7SmFjb2JpYW5FbGVtZW50fSBqYWNvYmlhbkVsZW1lbnRBXG4gICAgICovXG4gICAgdGhpcy5qYWNvYmlhbkVsZW1lbnRBID0gbmV3IEphY29iaWFuRWxlbWVudCgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtKYWNvYmlhbkVsZW1lbnR9IGphY29iaWFuRWxlbWVudEJcbiAgICAgKi9cbiAgICB0aGlzLmphY29iaWFuRWxlbWVudEIgPSBuZXcgSmFjb2JpYW5FbGVtZW50KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEEgbnVtYmVyLCBwcm9wb3J0aW9uYWwgdG8gdGhlIGZvcmNlIGFkZGVkIHRvIHRoZSBib2RpZXMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG11bHRpcGxpZXJcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLm11bHRpcGxpZXIgPSAwO1xuXG4gICAgLy8gU2V0IHR5cGljYWwgc3Bvb2sgcGFyYW1zXG4gICAgdGhpcy5zZXRTcG9va1BhcmFtcygxZTcsNCwxLzYwKTtcbn1cbkVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVxdWF0aW9uO1xuXG5FcXVhdGlvbi5pZCA9IDA7XG5cbi8qKlxuICogUmVjYWxjdWxhdGVzIGEsYixlcHMuXG4gKiBAbWV0aG9kIHNldFNwb29rUGFyYW1zXG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5zZXRTcG9va1BhcmFtcyA9IGZ1bmN0aW9uKHN0aWZmbmVzcyxyZWxheGF0aW9uLHRpbWVTdGVwKXtcbiAgICB2YXIgZCA9IHJlbGF4YXRpb24sXG4gICAgICAgIGsgPSBzdGlmZm5lc3MsXG4gICAgICAgIGggPSB0aW1lU3RlcDtcbiAgICB0aGlzLmEgPSA0LjAgLyAoaCAqICgxICsgNCAqIGQpKTtcbiAgICB0aGlzLmIgPSAoNC4wICogZCkgLyAoMSArIDQgKiBkKTtcbiAgICB0aGlzLmVwcyA9IDQuMCAvIChoICogaCAqIGsgKiAoMSArIDQgKiBkKSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBSSFMgb2YgdGhlIFNQT09LIGVxdWF0aW9uXG4gKiBAbWV0aG9kIGNvbXB1dGVCXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGEsYixoKXtcbiAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpLFxuICAgICAgICBHcSA9IHRoaXMuY29tcHV0ZUdxKCksXG4gICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG4gICAgcmV0dXJuIC0gR3EgKiBhIC0gR1cgKiBiIC0gR2lNZipoO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyBHKnEsIHdoZXJlIHEgYXJlIHRoZSBnZW5lcmFsaXplZCBib2R5IGNvb3JkaW5hdGVzXG4gKiBAbWV0aG9kIGNvbXB1dGVHcVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdxID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxuICAgICAgICBiaSA9IHRoaXMuYmksXG4gICAgICAgIGJqID0gdGhpcy5iaixcbiAgICAgICAgeGkgPSBiaS5wb3NpdGlvbixcbiAgICAgICAgeGogPSBiai5wb3NpdGlvbjtcbiAgICByZXR1cm4gR0Euc3BhdGlhbC5kb3QoeGkpICsgR0Iuc3BhdGlhbC5kb3QoeGopO1xufTtcblxudmFyIHplcm8gPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIENvbXB1dGVzIEcqVywgd2hlcmUgVyBhcmUgdGhlIGJvZHkgdmVsb2NpdGllc1xuICogQG1ldGhvZCBjb21wdXRlR1dcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHVyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIHZpID0gYmkudmVsb2NpdHksXG4gICAgICAgIHZqID0gYmoudmVsb2NpdHksXG4gICAgICAgIHdpID0gYmkuYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eTtcbiAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKHZpLHdpKSArIEdCLm11bHRpcGx5VmVjdG9ycyh2aix3aik7XG59O1xuXG5cbi8qKlxuICogQ29tcHV0ZXMgRypXbGFtYmRhLCB3aGVyZSBXIGFyZSB0aGUgYm9keSB2ZWxvY2l0aWVzXG4gKiBAbWV0aG9kIGNvbXB1dGVHV2xhbWJkYVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdXbGFtYmRhID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxuICAgICAgICBiaSA9IHRoaXMuYmksXG4gICAgICAgIGJqID0gdGhpcy5iaixcbiAgICAgICAgdmkgPSBiaS52bGFtYmRhLFxuICAgICAgICB2aiA9IGJqLnZsYW1iZGEsXG4gICAgICAgIHdpID0gYmkud2xhbWJkYSxcbiAgICAgICAgd2ogPSBiai53bGFtYmRhO1xuICAgIHJldHVybiBHQS5tdWx0aXBseVZlY3RvcnModmksd2kpICsgR0IubXVsdGlwbHlWZWN0b3JzKHZqLHdqKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgRyppbnYoTSkqZiwgd2hlcmUgTSBpcyB0aGUgbWFzcyBtYXRyaXggd2l0aCBkaWFnb25hbCBibG9ja3MgZm9yIGVhY2ggYm9keSwgYW5kIGYgYXJlIHRoZSBmb3JjZXMgb24gdGhlIGJvZGllcy5cbiAqIEBtZXRob2QgY29tcHV0ZUdpTWZcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIGlNZmkgPSBuZXcgVmVjMygpLFxuICAgIGlNZmogPSBuZXcgVmVjMygpLFxuICAgIGludklpX3ZtdWx0X3RhdWkgPSBuZXcgVmVjMygpLFxuICAgIGludklqX3ZtdWx0X3RhdWogPSBuZXcgVmVjMygpO1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHaU1mID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxuICAgICAgICBiaSA9IHRoaXMuYmksXG4gICAgICAgIGJqID0gdGhpcy5iaixcbiAgICAgICAgZmkgPSBiaS5mb3JjZSxcbiAgICAgICAgdGkgPSBiaS50b3JxdWUsXG4gICAgICAgIGZqID0gYmouZm9yY2UsXG4gICAgICAgIHRqID0gYmoudG9ycXVlLFxuICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmU7XG5cbiAgICBmaS5zY2FsZShpbnZNYXNzaSxpTWZpKTtcbiAgICBmai5zY2FsZShpbnZNYXNzaixpTWZqKTtcblxuICAgIGJpLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KHRpLGludklpX3ZtdWx0X3RhdWkpO1xuICAgIGJqLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KHRqLGludklqX3ZtdWx0X3RhdWopO1xuXG4gICAgcmV0dXJuIEdBLm11bHRpcGx5VmVjdG9ycyhpTWZpLGludklpX3ZtdWx0X3RhdWkpICsgR0IubXVsdGlwbHlWZWN0b3JzKGlNZmosaW52SWpfdm11bHRfdGF1aik7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIEcqaW52KE0pKkcnXG4gKiBAbWV0aG9kIGNvbXB1dGVHaU1HdFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG52YXIgdG1wID0gbmV3IFZlYzMoKTtcbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR2lNR3QgPSBmdW5jdGlvbigpe1xuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsXG4gICAgICAgIGJpID0gdGhpcy5iaSxcbiAgICAgICAgYmogPSB0aGlzLmJqLFxuICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmUsXG4gICAgICAgIGludklpID0gYmkuaW52SW5lcnRpYVdvcmxkU29sdmUsXG4gICAgICAgIGludklqID0gYmouaW52SW5lcnRpYVdvcmxkU29sdmUsXG4gICAgICAgIHJlc3VsdCA9IGludk1hc3NpICsgaW52TWFzc2o7XG5cbiAgICBpbnZJaS52bXVsdChHQS5yb3RhdGlvbmFsLHRtcCk7XG4gICAgcmVzdWx0ICs9IHRtcC5kb3QoR0Eucm90YXRpb25hbCk7XG5cbiAgICBpbnZJai52bXVsdChHQi5yb3RhdGlvbmFsLHRtcCk7XG4gICAgcmVzdWx0ICs9IHRtcC5kb3QoR0Iucm90YXRpb25hbCk7XG5cbiAgICByZXR1cm4gIHJlc3VsdDtcbn07XG5cbnZhciBhZGRUb1dsYW1iZGFfdGVtcCA9IG5ldyBWZWMzKCksXG4gICAgYWRkVG9XbGFtYmRhX0dpID0gbmV3IFZlYzMoKSxcbiAgICBhZGRUb1dsYW1iZGFfR2ogPSBuZXcgVmVjMygpLFxuICAgIGFkZFRvV2xhbWJkYV9yaSA9IG5ldyBWZWMzKCksXG4gICAgYWRkVG9XbGFtYmRhX3JqID0gbmV3IFZlYzMoKSxcbiAgICBhZGRUb1dsYW1iZGFfTWRpYWcgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEFkZCBjb25zdHJhaW50IHZlbG9jaXR5IHRvIHRoZSBib2RpZXMuXG4gKiBAbWV0aG9kIGFkZFRvV2xhbWJkYVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhbGFtYmRhXG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5hZGRUb1dsYW1iZGEgPSBmdW5jdGlvbihkZWx0YWxhbWJkYSl7XG4gICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIHRlbXAgPSBhZGRUb1dsYW1iZGFfdGVtcDtcblxuICAgIC8vIEFkZCB0byBsaW5lYXIgdmVsb2NpdHlcbiAgICAvLyB2X2xhbWJkYSArPSBpbnYoTSkgKiBkZWx0YV9sYW1iYSAqIEdcbiAgICBiaS52bGFtYmRhLmFkZFNjYWxlZFZlY3RvcihiaS5pbnZNYXNzU29sdmUgKiBkZWx0YWxhbWJkYSwgR0Euc3BhdGlhbCwgYmkudmxhbWJkYSk7XG4gICAgYmoudmxhbWJkYS5hZGRTY2FsZWRWZWN0b3IoYmouaW52TWFzc1NvbHZlICogZGVsdGFsYW1iZGEsIEdCLnNwYXRpYWwsIGJqLnZsYW1iZGEpO1xuXG4gICAgLy8gQWRkIHRvIGFuZ3VsYXIgdmVsb2NpdHlcbiAgICBiaS5pbnZJbmVydGlhV29ybGRTb2x2ZS52bXVsdChHQS5yb3RhdGlvbmFsLHRlbXApO1xuICAgIGJpLndsYW1iZGEuYWRkU2NhbGVkVmVjdG9yKGRlbHRhbGFtYmRhLCB0ZW1wLCBiaS53bGFtYmRhKTtcblxuICAgIGJqLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KEdCLnJvdGF0aW9uYWwsdGVtcCk7XG4gICAgYmoud2xhbWJkYS5hZGRTY2FsZWRWZWN0b3IoZGVsdGFsYW1iZGEsIHRlbXAsIGJqLndsYW1iZGEpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBkZW5vbWluYXRvciBwYXJ0IG9mIHRoZSBTUE9PSyBlcXVhdGlvbjogQyA9IEcqaW52KE0pKkcnICsgZXBzXG4gKiBAbWV0aG9kIGNvbXB1dGVJbnZDXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVwc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUMgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmNvbXB1dGVHaU1HdCgpICsgdGhpcy5lcHM7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBGcmljdGlvbkVxdWF0aW9uO1xuXG52YXIgRXF1YXRpb24gPSByZXF1aXJlKCcuL0VxdWF0aW9uJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIE1hdDMgPSByZXF1aXJlKCcuLi9tYXRoL01hdDMnKTtcblxuLyoqXG4gKiBDb25zdHJhaW5zIHRoZSBzbGlwcGluZyBpbiBhIGNvbnRhY3QgYWxvbmcgYSB0YW5nZW50XG4gKiBAY2xhc3MgRnJpY3Rpb25FcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge051bWJlcn0gc2xpcEZvcmNlIHNob3VsZCBiZSArLUZfZnJpY3Rpb24gPSArLW11ICogRl9ub3JtYWwgPSArLW11ICogbSAqIGdcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKi9cbmZ1bmN0aW9uIEZyaWN0aW9uRXF1YXRpb24oYm9keUEsIGJvZHlCLCBzbGlwRm9yY2Upe1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcyxib2R5QSwgYm9keUIsIC1zbGlwRm9yY2UsIHNsaXBGb3JjZSk7XG4gICAgdGhpcy5yaSA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5yaiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy50ID0gbmV3IFZlYzMoKTsgLy8gdGFuZ2VudFxufVxuXG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGcmljdGlvbkVxdWF0aW9uO1xuXG52YXIgRnJpY3Rpb25FcXVhdGlvbl9jb21wdXRlQl90ZW1wMSA9IG5ldyBWZWMzKCk7XG52YXIgRnJpY3Rpb25FcXVhdGlvbl9jb21wdXRlQl90ZW1wMiA9IG5ldyBWZWMzKCk7XG5GcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGgpe1xuICAgIHZhciBhID0gdGhpcy5hLFxuICAgICAgICBiID0gdGhpcy5iLFxuICAgICAgICBiaSA9IHRoaXMuYmksXG4gICAgICAgIGJqID0gdGhpcy5iaixcbiAgICAgICAgcmkgPSB0aGlzLnJpLFxuICAgICAgICByaiA9IHRoaXMucmosXG4gICAgICAgIHJpeHQgPSBGcmljdGlvbkVxdWF0aW9uX2NvbXB1dGVCX3RlbXAxLFxuICAgICAgICByanh0ID0gRnJpY3Rpb25FcXVhdGlvbl9jb21wdXRlQl90ZW1wMixcbiAgICAgICAgdCA9IHRoaXMudDtcblxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuICAgIHJpLmNyb3NzKHQscml4dCk7XG4gICAgcmouY3Jvc3ModCxyanh0KTtcblxuICAgIC8vIEcgPSBbLXQgLXJpeHQgdCByanh0XVxuICAgIC8vIEFuZCByZW1lbWJlciwgdGhpcyBpcyBhIHB1cmUgdmVsb2NpdHkgY29uc3RyYWludCwgZyBpcyBhbHdheXMgemVybyFcbiAgICB2YXIgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCO1xuICAgIHQubmVnYXRlKEdBLnNwYXRpYWwpO1xuICAgIHJpeHQubmVnYXRlKEdBLnJvdGF0aW9uYWwpO1xuICAgIEdCLnNwYXRpYWwuY29weSh0KTtcbiAgICBHQi5yb3RhdGlvbmFsLmNvcHkocmp4dCk7XG5cbiAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpO1xuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuXG4gICAgdmFyIEIgPSAtIEdXICogYiAtIGggKiBHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsRXF1YXRpb247XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgTWF0MyA9IHJlcXVpcmUoJy4uL21hdGgvTWF0MycpO1xudmFyIEVxdWF0aW9uID0gcmVxdWlyZSgnLi9FcXVhdGlvbicpO1xuXG4vKipcbiAqIFJvdGF0aW9uYWwgY29uc3RyYWludC4gV29ya3MgdG8ga2VlcCB0aGUgbG9jYWwgdmVjdG9ycyBvcnRob2dvbmFsIHRvIGVhY2ggb3RoZXIgaW4gd29ybGQgc3BhY2UuXG4gKiBAY2xhc3MgUm90YXRpb25hbEVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0FdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNCXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlXVxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIG1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG5cbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsYm9keUEsYm9keUIsLW1heEZvcmNlLCBtYXhGb3JjZSk7XG5cbiAgICB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKDEsIDAsIDApO1xuICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMCwgMSwgMCk7XG5cbiAgICB0aGlzLm1heEFuZ2xlID0gTWF0aC5QSSAvIDI7XG59XG5cblJvdGF0aW9uYWxFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcblJvdGF0aW9uYWxFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbmFsRXF1YXRpb247XG5cbnZhciB0bXBWZWMxID0gbmV3IFZlYzMoKTtcbnZhciB0bXBWZWMyID0gbmV3IFZlYzMoKTtcblxuUm90YXRpb25hbEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGgpe1xuICAgIHZhciBhID0gdGhpcy5hLFxuICAgICAgICBiID0gdGhpcy5iLFxuXG4gICAgICAgIG5pID0gdGhpcy5heGlzQSxcbiAgICAgICAgbmogPSB0aGlzLmF4aXNCLFxuXG4gICAgICAgIG5peG5qID0gdG1wVmVjMSxcbiAgICAgICAgbmp4bmkgPSB0bXBWZWMyLFxuXG4gICAgICAgIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcblxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuICAgIG5pLmNyb3NzKG5qLCBuaXhuaik7XG4gICAgbmouY3Jvc3MobmksIG5qeG5pKTtcblxuICAgIC8vIGcgPSBuaSAqIG5qXG4gICAgLy8gZ2RvdCA9IChuaiB4IG5pKSAqIHdpICsgKG5pIHggbmopICogd2pcbiAgICAvLyBHID0gWzAgbmp4bmkgMCBuaXhual1cbiAgICAvLyBXID0gW3ZpIHdpIHZqIHdqXVxuICAgIEdBLnJvdGF0aW9uYWwuY29weShuanhuaSk7XG4gICAgR0Iucm90YXRpb25hbC5jb3B5KG5peG5qKTtcblxuICAgIHZhciBnID0gTWF0aC5jb3ModGhpcy5tYXhBbmdsZSkgLSBuaS5kb3QobmopLFxuICAgICAgICBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXG4gICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG5cbiAgICB2YXIgQiA9IC0gZyAqIGEgLSBHVyAqIGIgLSBoICogR2lNZjtcblxuICAgIHJldHVybiBCO1xufTtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbjtcblxudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBNYXQzID0gcmVxdWlyZSgnLi4vbWF0aC9NYXQzJyk7XG52YXIgRXF1YXRpb24gPSByZXF1aXJlKCcuL0VxdWF0aW9uJyk7XG5cbi8qKlxuICogUm90YXRpb25hbCBtb3RvciBjb25zdHJhaW50LiBUcmllcyB0byBrZWVwIHRoZSByZWxhdGl2ZSBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSBib2RpZXMgdG8gYSBnaXZlbiB2YWx1ZS5cbiAqIEBjbGFzcyBSb3RhdGlvbmFsTW90b3JFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4Rm9yY2VcbiAqIEBleHRlbmRzIEVxdWF0aW9uXG4gKi9cbmZ1bmN0aW9uIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uKGJvZHlBLCBib2R5QiwgbWF4Rm9yY2Upe1xuICAgIG1heEZvcmNlID0gdHlwZW9mKG1heEZvcmNlKSE9PSd1bmRlZmluZWQnID8gbWF4Rm9yY2UgOiAxZTY7XG4gICAgRXF1YXRpb24uY2FsbCh0aGlzLGJvZHlBLGJvZHlCLC1tYXhGb3JjZSxtYXhGb3JjZSk7XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZCBvcmllbnRlZCByb3RhdGlvbmFsIGF4aXNcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGF4aXNBXG4gICAgICovXG4gICAgdGhpcy5heGlzQSA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZCBvcmllbnRlZCByb3RhdGlvbmFsIGF4aXNcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGF4aXNCXG4gICAgICovXG4gICAgdGhpcy5heGlzQiA9IG5ldyBWZWMzKCk7IC8vIFdvcmxkIG9yaWVudGVkIHJvdGF0aW9uYWwgYXhpc1xuXG4gICAgLyoqXG4gICAgICogTW90b3IgdmVsb2NpdHlcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gdGFyZ2V0VmVsb2NpdHlcbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldFZlbG9jaXR5ID0gMDtcbn1cblxuUm90YXRpb25hbE1vdG9yRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbjtcblxuUm90YXRpb25hbE1vdG9yRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24oaCl7XG4gICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGJpID0gdGhpcy5iaSxcbiAgICAgICAgYmogPSB0aGlzLmJqLFxuXG4gICAgICAgIGF4aXNBID0gdGhpcy5heGlzQSxcbiAgICAgICAgYXhpc0IgPSB0aGlzLmF4aXNCLFxuXG4gICAgICAgIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcblxuICAgIC8vIGcgPSAwXG4gICAgLy8gZ2RvdCA9IGF4aXNBICogd2kgLSBheGlzQiAqIHdqXG4gICAgLy8gZ2RvdCA9IEcgKiBXID0gRyAqIFt2aSB3aSB2aiB3al1cbiAgICAvLyA9PlxuICAgIC8vIEcgPSBbMCBheGlzQSAwIC1heGlzQl1cblxuICAgIEdBLnJvdGF0aW9uYWwuY29weShheGlzQSk7XG4gICAgYXhpc0IubmVnYXRlKEdCLnJvdGF0aW9uYWwpO1xuXG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKSAtIHRoaXMudGFyZ2V0VmVsb2NpdHksXG4gICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG5cbiAgICB2YXIgQiA9IC0gR1cgKiBiIC0gaCAqIEdpTWY7XG5cbiAgICByZXR1cm4gQjtcbn07XG4iLCJ2YXIgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhY3RNYXRlcmlhbDtcblxuLyoqXG4gKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHR3byBtYXRlcmlhbHMgbWVldC5cbiAqIEBjbGFzcyBDb250YWN0TWF0ZXJpYWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtNYXRlcmlhbH0gbTFcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG0yXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJpY3Rpb249MC4zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc3RpdHV0aW9uPTAuM11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb250YWN0RXF1YXRpb25TdGlmZm5lc3M9MWU3XVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb249M11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzPTFlN11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbj0zXVxuICovXG5mdW5jdGlvbiBDb250YWN0TWF0ZXJpYWwobTEsIG0yLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBmcmljdGlvbjogMC4zLFxuICAgICAgICByZXN0aXR1dGlvbjogMC4zLFxuICAgICAgICBjb250YWN0RXF1YXRpb25TdGlmZm5lc3M6IDFlNyxcbiAgICAgICAgY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbjogMyxcbiAgICAgICAgZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzczogMWU3LFxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbjogM1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZmllciBvZiB0aGlzIG1hdGVyaWFsXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGlkXG4gICAgICovXG4gICAgdGhpcy5pZCA9IENvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIrKztcblxuICAgIC8qKlxuICAgICAqIFBhcnRpY2lwYXRpbmcgbWF0ZXJpYWxzXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gbWF0ZXJpYWxzXG4gICAgICogQHRvZG8gIFNob3VsZCBiZSAubWF0ZXJpYWxBIGFuZCAubWF0ZXJpYWxCIGluc3RlYWRcbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFscyA9IFttMSwgbTJdO1xuXG4gICAgLyoqXG4gICAgICogRnJpY3Rpb24gY29lZmZpY2llbnRcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZnJpY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uID0gb3B0aW9ucy5mcmljdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFJlc3RpdHV0aW9uIGNvZWZmaWNpZW50XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJlc3RpdHV0aW9uXG4gICAgICovXG4gICAgdGhpcy5yZXN0aXR1dGlvbiA9IG9wdGlvbnMucmVzdGl0dXRpb247XG5cbiAgICAvKipcbiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHByb2R1Y2VkIGNvbnRhY3QgZXF1YXRpb25zXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbnRhY3RFcXVhdGlvblN0aWZmbmVzc1xuICAgICAqL1xuICAgIHRoaXMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzID0gb3B0aW9ucy5jb250YWN0RXF1YXRpb25TdGlmZm5lc3M7XG5cbiAgICAvKipcbiAgICAgKiBSZWxheGF0aW9uIHRpbWUgb2YgdGhlIHByb2R1Y2VkIGNvbnRhY3QgZXF1YXRpb25zXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb25cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb24gPSBvcHRpb25zLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb247XG5cbiAgICAvKipcbiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHByb2R1Y2VkIGZyaWN0aW9uIGVxdWF0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBmcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzID0gb3B0aW9ucy5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXhhdGlvbiB0aW1lIG9mIHRoZSBwcm9kdWNlZCBmcmljdGlvbiBlcXVhdGlvbnNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb25cbiAgICAgKi9cbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uID0gb3B0aW9ucy5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbjtcbn1cblxuQ29udGFjdE1hdGVyaWFsLmlkQ291bnRlciA9IDA7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IE1hdGVyaWFsO1xuXG4vKipcbiAqIERlZmluZXMgYSBwaHlzaWNzIG1hdGVyaWFsLlxuICogQGNsYXNzIE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gTWF0ZXJpYWwob3B0aW9ucyl7XG4gICAgdmFyIG5hbWUgPSAnJztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZpeFxuICAgIGlmKHR5cGVvZihvcHRpb25zKSA9PT0gJ3N0cmluZycpe1xuICAgICAgICBuYW1lID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH0gZWxzZSBpZih0eXBlb2Yob3B0aW9ucykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG5hbWUgPSAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbmFtZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIC8qKlxuICAgICAqIG1hdGVyaWFsIGlkLlxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IE1hdGVyaWFsLmlkQ291bnRlcisrO1xuXG4gICAgLyoqXG4gICAgICogRnJpY3Rpb24gZm9yIHRoaXMgbWF0ZXJpYWwuIElmIG5vbi1uZWdhdGl2ZSwgaXQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGZyaWN0aW9uIGdpdmVuIGJ5IENvbnRhY3RNYXRlcmlhbHMuIElmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgQ29udGFjdE1hdGVyaWFsLCB0aGUgdmFsdWUgZnJvbSAuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCBpbiB0aGUgV29ybGQgd2lsbCBiZSB1c2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmcmljdGlvblxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb24gPSB0eXBlb2Yob3B0aW9ucy5mcmljdGlvbikgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5mcmljdGlvbiA6IC0xO1xuXG4gICAgLyoqXG4gICAgICogUmVzdGl0dXRpb24gZm9yIHRoaXMgbWF0ZXJpYWwuIElmIG5vbi1uZWdhdGl2ZSwgaXQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIHJlc3RpdHV0aW9uIGdpdmVuIGJ5IENvbnRhY3RNYXRlcmlhbHMuIElmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgQ29udGFjdE1hdGVyaWFsLCB0aGUgdmFsdWUgZnJvbSAuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCBpbiB0aGUgV29ybGQgd2lsbCBiZSB1c2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXN0aXR1dGlvblxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSB0eXBlb2Yob3B0aW9ucy5yZXN0aXR1dGlvbikgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5yZXN0aXR1dGlvbiA6IC0xO1xufVxuXG5NYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBKYWNvYmlhbkVsZW1lbnQ7XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnLi9WZWMzJyk7XG5cbi8qKlxuICogQW4gZWxlbWVudCBjb250YWluaW5nIDYgZW50cmllcywgMyBzcGF0aWFsIGFuZCAzIHJvdGF0aW9uYWwgZGVncmVlcyBvZiBmcmVlZG9tLlxuICogQGNsYXNzIEphY29iaWFuRWxlbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEphY29iaWFuRWxlbWVudCgpe1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBzcGF0aWFsXG4gICAgICovXG4gICAgdGhpcy5zcGF0aWFsID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcm90YXRpb25hbFxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb25hbCA9IG5ldyBWZWMzKCk7XG59XG5cbi8qKlxuICogTXVsdGlwbHkgd2l0aCBvdGhlciBKYWNvYmlhbkVsZW1lbnRcbiAqIEBtZXRob2QgbXVsdGlwbHlFbGVtZW50XG4gKiBAcGFyYW0gIHtKYWNvYmlhbkVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuSmFjb2JpYW5FbGVtZW50LnByb3RvdHlwZS5tdWx0aXBseUVsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50KXtcbiAgICByZXR1cm4gZWxlbWVudC5zcGF0aWFsLmRvdCh0aGlzLnNwYXRpYWwpICsgZWxlbWVudC5yb3RhdGlvbmFsLmRvdCh0aGlzLnJvdGF0aW9uYWwpO1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSB3aXRoIHR3byB2ZWN0b3JzXG4gKiBAbWV0aG9kIG11bHRpcGx5VmVjdG9yc1xuICogQHBhcmFtICB7VmVjM30gc3BhdGlhbFxuICogQHBhcmFtICB7VmVjM30gcm90YXRpb25hbFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5KYWNvYmlhbkVsZW1lbnQucHJvdG90eXBlLm11bHRpcGx5VmVjdG9ycyA9IGZ1bmN0aW9uKHNwYXRpYWwscm90YXRpb25hbCl7XG4gICAgcmV0dXJuIHNwYXRpYWwuZG90KHRoaXMuc3BhdGlhbCkgKyByb3RhdGlvbmFsLmRvdCh0aGlzLnJvdGF0aW9uYWwpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gTWF0MztcblxudmFyIFZlYzMgPSByZXF1aXJlKCcuL1ZlYzMnKTtcblxuLyoqXG4gKiBBIDN4MyBtYXRyaXguXG4gKiBAY2xhc3MgTWF0M1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gYXJyYXkgZWxlbWVudHMgQXJyYXkgb2YgbmluZSBlbGVtZW50cy4gT3B0aW9uYWwuXG4gKiBAYXV0aG9yIHNjaHRlcHBlIC8gaHR0cDovL2dpdGh1Yi5jb20vc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gTWF0MyhlbGVtZW50cyl7XG4gICAgLyoqXG4gICAgICogQSB2ZWN0b3Igb2YgbGVuZ3RoIDksIGNvbnRhaW5pbmcgYWxsIG1hdHJpeCBlbGVtZW50c1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGVsZW1lbnRzXG4gICAgICovXG4gICAgaWYoZWxlbWVudHMpe1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IFswLDAsMCwwLDAsMCwwLDAsMF07XG4gICAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hdHJpeCB0byBpZGVudGl0eVxuICogQG1ldGhvZCBpZGVudGl0eVxuICogQHRvZG8gU2hvdWxkIHBlcmhhcHMgYmUgcmVuYW1lZCB0byBzZXRJZGVudGl0eSgpIHRvIGJlIG1vcmUgY2xlYXIuXG4gKiBAdG9kbyBDcmVhdGUgYW5vdGhlciBmdW5jdGlvbiB0aGF0IGltbWVkaWF0ZWx5IGNyZWF0ZXMgYW4gaWRlbnRpdHkgbWF0cml4IGVnLiBleWUoKVxuICovXG5NYXQzLnByb3RvdHlwZS5pZGVudGl0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGVbMF0gPSAxO1xuICAgIGVbMV0gPSAwO1xuICAgIGVbMl0gPSAwO1xuXG4gICAgZVszXSA9IDA7XG4gICAgZVs0XSA9IDE7XG4gICAgZVs1XSA9IDA7XG5cbiAgICBlWzZdID0gMDtcbiAgICBlWzddID0gMDtcbiAgICBlWzhdID0gMTtcbn07XG5cbi8qKlxuICogU2V0IGFsbCBlbGVtZW50cyB0byB6ZXJvXG4gKiBAbWV0aG9kIHNldFplcm9cbiAqL1xuTWF0My5wcm90b3R5cGUuc2V0WmVybyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGVbMF0gPSAwO1xuICAgIGVbMV0gPSAwO1xuICAgIGVbMl0gPSAwO1xuICAgIGVbM10gPSAwO1xuICAgIGVbNF0gPSAwO1xuICAgIGVbNV0gPSAwO1xuICAgIGVbNl0gPSAwO1xuICAgIGVbN10gPSAwO1xuICAgIGVbOF0gPSAwO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXRyaXggZGlhZ29uYWwgZWxlbWVudHMgZnJvbSBhIFZlYzNcbiAqIEBtZXRob2Qgc2V0VHJhY2VcbiAqIEBwYXJhbSB7VmVjM30gdmVjM1xuICovXG5NYXQzLnByb3RvdHlwZS5zZXRUcmFjZSA9IGZ1bmN0aW9uKHZlYzMpe1xuICAgIHZhciBlID0gdGhpcy5lbGVtZW50cztcbiAgICBlWzBdID0gdmVjMy54O1xuICAgIGVbNF0gPSB2ZWMzLnk7XG4gICAgZVs4XSA9IHZlYzMuejtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbWF0cml4IGRpYWdvbmFsIGVsZW1lbnRzXG4gKiBAbWV0aG9kIGdldFRyYWNlXG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5NYXQzLnByb3RvdHlwZS5nZXRUcmFjZSA9IGZ1bmN0aW9uKHRhcmdldCl7XG4gICAgdmFyIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHZhciBlID0gdGhpcy5lbGVtZW50cztcbiAgICB0YXJnZXQueCA9IGVbMF07XG4gICAgdGFyZ2V0LnkgPSBlWzRdO1xuICAgIHRhcmdldC56ID0gZVs4XTtcbn07XG5cbi8qKlxuICogTWF0cml4LVZlY3RvciBtdWx0aXBsaWNhdGlvblxuICogQG1ldGhvZCB2bXVsdFxuICogQHBhcmFtIHtWZWMzfSB2IFRoZSB2ZWN0b3IgdG8gbXVsdGlwbHkgd2l0aFxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwsIHRhcmdldCB0byBzYXZlIHRoZSByZXN1bHQgaW4uXG4gKi9cbk1hdDMucHJvdG90eXBlLnZtdWx0ID0gZnVuY3Rpb24odix0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuXG4gICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzLFxuICAgICAgICB4ID0gdi54LFxuICAgICAgICB5ID0gdi55LFxuICAgICAgICB6ID0gdi56O1xuICAgIHRhcmdldC54ID0gZVswXSp4ICsgZVsxXSp5ICsgZVsyXSp6O1xuICAgIHRhcmdldC55ID0gZVszXSp4ICsgZVs0XSp5ICsgZVs1XSp6O1xuICAgIHRhcmdldC56ID0gZVs2XSp4ICsgZVs3XSp5ICsgZVs4XSp6O1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogTWF0cml4LXNjYWxhciBtdWx0aXBsaWNhdGlvblxuICogQG1ldGhvZCBzbXVsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHNcbiAqL1xuTWF0My5wcm90b3R5cGUuc211bHQgPSBmdW5jdGlvbihzKXtcbiAgICBmb3IodmFyIGk9MDsgaTx0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXSAqPSBzO1xuICAgIH1cbn07XG5cbi8qKlxuICogTWF0cml4IG11bHRpcGxpY2F0aW9uXG4gKiBAbWV0aG9kIG1tdWx0XG4gKiBAcGFyYW0ge01hdDN9IG0gTWF0cml4IHRvIG11bHRpcGx5IHdpdGggZnJvbSBsZWZ0IHNpZGUuXG4gKiBAcmV0dXJuIHtNYXQzfSBUaGUgcmVzdWx0LlxuICovXG5NYXQzLnByb3RvdHlwZS5tbXVsdCA9IGZ1bmN0aW9uKG0sdGFyZ2V0KXtcbiAgICB2YXIgciA9IHRhcmdldCB8fCBuZXcgTWF0MygpO1xuICAgIGZvcih2YXIgaT0wOyBpPDM7IGkrKyl7XG4gICAgICAgIGZvcih2YXIgaj0wOyBqPDM7IGorKyl7XG4gICAgICAgICAgICB2YXIgc3VtID0gMC4wO1xuICAgICAgICAgICAgZm9yKHZhciBrPTA7IGs8MzsgaysrKXtcbiAgICAgICAgICAgICAgICBzdW0gKz0gbS5lbGVtZW50c1tpK2sqM10gKiB0aGlzLmVsZW1lbnRzW2sraiozXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIuZWxlbWVudHNbaStqKjNdID0gc3VtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xufTtcblxuLyoqXG4gKiBTY2FsZSBlYWNoIGNvbHVtbiBvZiB0aGUgbWF0cml4XG4gKiBAbWV0aG9kIHNjYWxlXG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEByZXR1cm4ge01hdDN9IFRoZSByZXN1bHQuXG4gKi9cbk1hdDMucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24odix0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgTWF0MygpO1xuICAgIHZhciBlID0gdGhpcy5lbGVtZW50cyxcbiAgICAgICAgdCA9IHRhcmdldC5lbGVtZW50cztcbiAgICBmb3IodmFyIGk9MDsgaSE9PTM7IGkrKyl7XG4gICAgICAgIHRbMyppICsgMF0gPSB2LnggKiBlWzMqaSArIDBdO1xuICAgICAgICB0WzMqaSArIDFdID0gdi55ICogZVszKmkgKyAxXTtcbiAgICAgICAgdFszKmkgKyAyXSA9IHYueiAqIGVbMyppICsgMl07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIFNvbHZlIEF4PWJcbiAqIEBtZXRob2Qgc29sdmVcbiAqIEBwYXJhbSB7VmVjM30gYiBUaGUgcmlnaHQgaGFuZCBzaWRlXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbC4gVGFyZ2V0IHZlY3RvciB0byBzYXZlIGluLlxuICogQHJldHVybiB7VmVjM30gVGhlIHNvbHV0aW9uIHhcbiAqIEB0b2RvIHNob3VsZCByZXVzZSBhcnJheXNcbiAqL1xuTWF0My5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihiLHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG5cbiAgICAvLyBDb25zdHJ1Y3QgZXF1YXRpb25zXG4gICAgdmFyIG5yID0gMzsgLy8gbnVtIHJvd3NcbiAgICB2YXIgbmMgPSA0OyAvLyBudW0gY29sc1xuICAgIHZhciBlcW5zID0gW107XG4gICAgZm9yKHZhciBpPTA7IGk8bnIqbmM7IGkrKyl7XG4gICAgICAgIGVxbnMucHVzaCgwKTtcbiAgICB9XG4gICAgdmFyIGksajtcbiAgICBmb3IoaT0wOyBpPDM7IGkrKyl7XG4gICAgICAgIGZvcihqPTA7IGo8MzsgaisrKXtcbiAgICAgICAgICAgIGVxbnNbaStuYypqXSA9IHRoaXMuZWxlbWVudHNbaSszKmpdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVxbnNbMys0KjBdID0gYi54O1xuICAgIGVxbnNbMys0KjFdID0gYi55O1xuICAgIGVxbnNbMys0KjJdID0gYi56O1xuXG4gICAgLy8gQ29tcHV0ZSByaWdodCB1cHBlciB0cmlhbmd1bGFyIHZlcnNpb24gb2YgdGhlIG1hdHJpeCAtIEdhdXNzIGVsaW1pbmF0aW9uXG4gICAgdmFyIG4gPSAzLCBrID0gbiwgbnA7XG4gICAgdmFyIGtwID0gNDsgLy8gbnVtIHJvd3NcbiAgICB2YXIgcCwgZWxzO1xuICAgIGRvIHtcbiAgICAgICAgaSA9IGsgLSBuO1xuICAgICAgICBpZiAoZXFuc1tpK25jKmldID09PSAwKSB7XG4gICAgICAgICAgICAvLyB0aGUgcGl2b3QgaXMgbnVsbCwgc3dhcCBsaW5lc1xuICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZXFuc1tpK25jKmpdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5wID0ga3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHsgIC8vIGRvIGxpZ25lKCBpICkgPSBsaWduZSggaSApICsgbGlnbmUoIGsgKVxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcW5zW3ArbmMqaV0gKz0gZXFuc1twK25jKmpdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW5wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlcW5zW2krbmMqaV0gIT09IDApIHtcbiAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBlcW5zW2krbmMqal0gLyBlcW5zW2krbmMqaV07XG4gICAgICAgICAgICAgICAgbnAgPSBrcDtcbiAgICAgICAgICAgICAgICBkbyB7ICAvLyBkbyBsaWduZSggayApID0gbGlnbmUoIGsgKSAtIG11bHRpcGxpZXIgKiBsaWduZSggaSApXG4gICAgICAgICAgICAgICAgICAgIHAgPSBrcCAtIG5wO1xuICAgICAgICAgICAgICAgICAgICBlcW5zW3ArbmMqal0gPSBwIDw9IGkgPyAwIDogZXFuc1twK25jKmpdIC0gZXFuc1twK25jKmldICogbXVsdGlwbGllciA7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgLy8gR2V0IHRoZSBzb2x1dGlvblxuICAgIHRhcmdldC56ID0gZXFuc1syKm5jKzNdIC8gZXFuc1syKm5jKzJdO1xuICAgIHRhcmdldC55ID0gKGVxbnNbMSpuYyszXSAtIGVxbnNbMSpuYysyXSp0YXJnZXQueikgLyBlcW5zWzEqbmMrMV07XG4gICAgdGFyZ2V0LnggPSAoZXFuc1swKm5jKzNdIC0gZXFuc1swKm5jKzJdKnRhcmdldC56IC0gZXFuc1swKm5jKzFdKnRhcmdldC55KSAvIGVxbnNbMCpuYyswXTtcblxuICAgIGlmKGlzTmFOKHRhcmdldC54KSB8fCBpc05hTih0YXJnZXQueSkgfHwgaXNOYU4odGFyZ2V0LnopIHx8IHRhcmdldC54PT09SW5maW5pdHkgfHwgdGFyZ2V0Lnk9PT1JbmZpbml0eSB8fCB0YXJnZXQuej09PUluZmluaXR5KXtcbiAgICAgICAgdGhyb3cgXCJDb3VsZCBub3Qgc29sdmUgZXF1YXRpb24hIEdvdCB4PVtcIit0YXJnZXQudG9TdHJpbmcoKStcIl0sIGI9W1wiK2IudG9TdHJpbmcoKStcIl0sIEE9W1wiK3RoaXMudG9TdHJpbmcoKStcIl1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBHZXQgYW4gZWxlbWVudCBpbiB0aGUgbWF0cml4IGJ5IGluZGV4LiBJbmRleCBzdGFydHMgYXQgMCwgbm90IDEhISFcbiAqIEBtZXRob2QgZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICogQHBhcmFtIHtOdW1iZXJ9IGNvbHVtblxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIE9wdGlvbmFsLiBJZiBwcm92aWRlZCwgdGhlIG1hdHJpeCBlbGVtZW50IHdpbGwgYmUgc2V0IHRvIHRoaXMgdmFsdWUuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbk1hdDMucHJvdG90eXBlLmUgPSBmdW5jdGlvbiggcm93ICwgY29sdW1uICx2YWx1ZSl7XG4gICAgaWYodmFsdWU9PT11bmRlZmluZWQpe1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50c1tjb2x1bW4rMypyb3ddO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNldCB2YWx1ZVxuICAgICAgICB0aGlzLmVsZW1lbnRzW2NvbHVtbiszKnJvd10gPSB2YWx1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvcHkgYW5vdGhlciBtYXRyaXggaW50byB0aGlzIG1hdHJpeCBvYmplY3QuXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSB7TWF0M30gc291cmNlXG4gKiBAcmV0dXJuIHtNYXQzfSB0aGlzXG4gKi9cbk1hdDMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihzb3VyY2Upe1xuICAgIGZvcih2YXIgaT0wOyBpIDwgc291cmNlLmVsZW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXSA9IHNvdXJjZS5lbGVtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeC5cbiAqIEBtZXRob2QgdG9TdHJpbmdcbiAqIEByZXR1cm4gc3RyaW5nXG4gKi9cbk1hdDMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgciA9IFwiXCI7XG4gICAgdmFyIHNlcCA9IFwiLFwiO1xuICAgIGZvcih2YXIgaT0wOyBpPDk7IGkrKyl7XG4gICAgICAgIHIgKz0gdGhpcy5lbGVtZW50c1tpXSArIHNlcDtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiAqIHJldmVyc2UgdGhlIG1hdHJpeFxuICogQG1ldGhvZCByZXZlcnNlXG4gKiBAcGFyYW0ge01hdDN9IHRhcmdldCBPcHRpb25hbC4gVGFyZ2V0IG1hdHJpeCB0byBzYXZlIGluLlxuICogQHJldHVybiB7TWF0M30gVGhlIHNvbHV0aW9uIHhcbiAqL1xuTWF0My5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uKHRhcmdldCl7XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IE1hdDMoKTtcblxuICAgIC8vIENvbnN0cnVjdCBlcXVhdGlvbnNcbiAgICB2YXIgbnIgPSAzOyAvLyBudW0gcm93c1xuICAgIHZhciBuYyA9IDY7IC8vIG51bSBjb2xzXG4gICAgdmFyIGVxbnMgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTxucipuYzsgaSsrKXtcbiAgICAgICAgZXFucy5wdXNoKDApO1xuICAgIH1cbiAgICB2YXIgaSxqO1xuICAgIGZvcihpPTA7IGk8MzsgaSsrKXtcbiAgICAgICAgZm9yKGo9MDsgajwzOyBqKyspe1xuICAgICAgICAgICAgZXFuc1tpK25jKmpdID0gdGhpcy5lbGVtZW50c1tpKzMqal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXFuc1szKzYqMF0gPSAxO1xuICAgIGVxbnNbMys2KjFdID0gMDtcbiAgICBlcW5zWzMrNioyXSA9IDA7XG4gICAgZXFuc1s0KzYqMF0gPSAwO1xuICAgIGVxbnNbNCs2KjFdID0gMTtcbiAgICBlcW5zWzQrNioyXSA9IDA7XG4gICAgZXFuc1s1KzYqMF0gPSAwO1xuICAgIGVxbnNbNSs2KjFdID0gMDtcbiAgICBlcW5zWzUrNioyXSA9IDE7XG5cbiAgICAvLyBDb21wdXRlIHJpZ2h0IHVwcGVyIHRyaWFuZ3VsYXIgdmVyc2lvbiBvZiB0aGUgbWF0cml4IC0gR2F1c3MgZWxpbWluYXRpb25cbiAgICB2YXIgbiA9IDMsIGsgPSBuLCBucDtcbiAgICB2YXIga3AgPSBuYzsgLy8gbnVtIHJvd3NcbiAgICB2YXIgcDtcbiAgICBkbyB7XG4gICAgICAgIGkgPSBrIC0gbjtcbiAgICAgICAgaWYgKGVxbnNbaStuYyppXSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gdGhlIHBpdm90IGlzIG51bGwsIHN3YXAgbGluZXNcbiAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVxbnNbaStuYypqXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBucCA9IGtwO1xuICAgICAgICAgICAgICAgICAgICBkbyB7IC8vIGRvIGxpbmUoIGkgKSA9IGxpbmUoIGkgKSArIGxpbmUoIGsgKVxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcW5zW3ArbmMqaV0gKz0gZXFuc1twK25jKmpdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW5wKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlcW5zW2krbmMqaV0gIT09IDApIHtcbiAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBlcW5zW2krbmMqal0gLyBlcW5zW2krbmMqaV07XG4gICAgICAgICAgICAgICAgbnAgPSBrcDtcbiAgICAgICAgICAgICAgICBkbyB7IC8vIGRvIGxpbmUoIGsgKSA9IGxpbmUoIGsgKSAtIG11bHRpcGxpZXIgKiBsaW5lKCBpIClcbiAgICAgICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XG4gICAgICAgICAgICAgICAgICAgIGVxbnNbcCtuYypqXSA9IHAgPD0gaSA/IDAgOiBlcW5zW3ArbmMqal0gLSBlcW5zW3ArbmMqaV0gKiBtdWx0aXBsaWVyIDtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW5wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAvLyBlbGltaW5hdGUgdGhlIHVwcGVyIGxlZnQgdHJpYW5nbGUgb2YgdGhlIG1hdHJpeFxuICAgIGkgPSAyO1xuICAgIGRvIHtcbiAgICAgICAgaiA9IGktMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBlcW5zW2krbmMqal0gLyBlcW5zW2krbmMqaV07XG4gICAgICAgICAgICBucCA9IG5jO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHAgPSBuYyAtIG5wO1xuICAgICAgICAgICAgICAgIGVxbnNbcCtuYypqXSA9ICBlcW5zW3ArbmMqal0gLSBlcW5zW3ArbmMqaV0gKiBtdWx0aXBsaWVyIDtcbiAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApO1xuICAgICAgICB9IHdoaWxlIChqLS0pO1xuICAgIH0gd2hpbGUgKC0taSk7XG5cbiAgICAvLyBvcGVyYXRpb25zIG9uIHRoZSBkaWFnb25hbFxuICAgIGkgPSAyO1xuICAgIGRvIHtcbiAgICAgICAgdmFyIG11bHRpcGxpZXIgPSAxIC8gZXFuc1tpK25jKmldO1xuICAgICAgICBucCA9IG5jO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBwID0gbmMgLSBucDtcbiAgICAgICAgICAgIGVxbnNbcCtuYyppXSA9IGVxbnNbcCtuYyppXSAqIG11bHRpcGxpZXIgO1xuICAgICAgICB9IHdoaWxlICgtLW5wKTtcbiAgICB9IHdoaWxlIChpLS0pO1xuXG4gICAgaSA9IDI7XG4gICAgZG8ge1xuICAgICAgICBqID0gMjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcCA9IGVxbnNbbnIraituYyppXTtcbiAgICAgICAgICAgIGlmKCBpc05hTiggcCApIHx8IHAgPT09SW5maW5pdHkgKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCByZXZlcnNlISBBPVtcIit0aGlzLnRvU3RyaW5nKCkrXCJdXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQuZSggaSAsIGogLCBwICk7XG4gICAgICAgIH0gd2hpbGUgKGotLSk7XG4gICAgfSB3aGlsZSAoaS0tKTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF0cml4IGZyb20gYSBxdWF0ZXJpb25cbiAqIEBtZXRob2Qgc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvblxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxXG4gKi9cbk1hdDMucHJvdG90eXBlLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24gPSBmdW5jdGlvbiggcSApIHtcbiAgICB2YXIgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudyxcbiAgICAgICAgeDIgPSB4ICsgeCwgeTIgPSB5ICsgeSwgejIgPSB6ICsgeixcbiAgICAgICAgeHggPSB4ICogeDIsIHh5ID0geCAqIHkyLCB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MixcbiAgICAgICAgZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBlWzMqMCArIDBdID0gMSAtICggeXkgKyB6eiApO1xuICAgIGVbMyowICsgMV0gPSB4eSAtIHd6O1xuICAgIGVbMyowICsgMl0gPSB4eiArIHd5O1xuXG4gICAgZVszKjEgKyAwXSA9IHh5ICsgd3o7XG4gICAgZVszKjEgKyAxXSA9IDEgLSAoIHh4ICsgenogKTtcbiAgICBlWzMqMSArIDJdID0geXogLSB3eDtcblxuICAgIGVbMyoyICsgMF0gPSB4eiAtIHd5O1xuICAgIGVbMyoyICsgMV0gPSB5eiArIHd4O1xuICAgIGVbMyoyICsgMl0gPSAxIC0gKCB4eCArIHl5ICk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSBtYXRyaXhcbiAqIEBtZXRob2QgdHJhbnNwb3NlXG4gKiBAcGFyYW0gIHtNYXQzfSB0YXJnZXQgV2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAqIEByZXR1cm4ge01hdDN9IFRoZSB0YXJnZXQgTWF0Mywgb3IgYSBuZXcgTWF0MyBpZiB0YXJnZXQgd2FzIG9taXR0ZWQuXG4gKi9cbk1hdDMucHJvdG90eXBlLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBNYXQzKCk7XG5cbiAgICB2YXIgTXQgPSB0YXJnZXQuZWxlbWVudHMsXG4gICAgICAgIE0gPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT0zOyBpKyspe1xuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PTM7IGorKyl7XG4gICAgICAgICAgICBNdFszKmkgKyBqXSA9IE1bMypqICsgaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gUXVhdGVybmlvbjtcblxudmFyIFZlYzMgPSByZXF1aXJlKCcuL1ZlYzMnKTtcblxuLyoqXG4gKiBBIFF1YXRlcm5pb24gZGVzY3JpYmVzIGEgcm90YXRpb24gaW4gM0Qgc3BhY2UuIFRoZSBRdWF0ZXJuaW9uIGlzIG1hdGhlbWF0aWNhbGx5IGRlZmluZWQgYXMgUSA9IHgqaSArIHkqaiArIHoqayArIHcsIHdoZXJlIChpLGosaykgYXJlIGltYWdpbmFyeSBiYXNpcyB2ZWN0b3JzLiAoeCx5LHopIGNhbiBiZSBzZWVuIGFzIGEgdmVjdG9yIHJlbGF0ZWQgdG8gdGhlIGF4aXMgb2Ygcm90YXRpb24sIHdoaWxlIHRoZSByZWFsIG11bHRpcGxpZXIsIHcsIGlzIHJlbGF0ZWQgdG8gdGhlIGFtb3VudCBvZiByb3RhdGlvbi5cbiAqIEBjbGFzcyBRdWF0ZXJuaW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IE11bHRpcGxpZXIgb2YgdGhlIGltYWdpbmFyeSBiYXNpcyB2ZWN0b3IgaS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IE11bHRpcGxpZXIgb2YgdGhlIGltYWdpbmFyeSBiYXNpcyB2ZWN0b3Igai5cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IE11bHRpcGxpZXIgb2YgdGhlIGltYWdpbmFyeSBiYXNpcyB2ZWN0b3Igay5cbiAqIEBwYXJhbSB7TnVtYmVyfSB3IE11bHRpcGxpZXIgb2YgdGhlIHJlYWwgcGFydC5cbiAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWF0ZXJuaW9uXG4gKi9cbmZ1bmN0aW9uIFF1YXRlcm5pb24oeCx5LHosdyl7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHhcbiAgICAgKi9cbiAgICB0aGlzLnggPSB4IT09dW5kZWZpbmVkID8geCA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0geVxuICAgICAqL1xuICAgIHRoaXMueSA9IHkhPT11bmRlZmluZWQgPyB5IDogMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB6XG4gICAgICovXG4gICAgdGhpcy56ID0geiE9PXVuZGVmaW5lZCA/IHogOiAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG11bHRpcGxpZXIgb2YgdGhlIHJlYWwgcXVhdGVybmlvbiBiYXNpcyB2ZWN0b3IuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHdcbiAgICAgKi9cbiAgICB0aGlzLncgPSB3IT09dW5kZWZpbmVkID8gdyA6IDE7XG59XG5cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgcXVhdGVybmlvbi5cbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKiBAcGFyYW0ge051bWJlcn0gd1xuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih4LHkseix3KXtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy56ID0gejtcbiAgICB0aGlzLncgPSB3O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIGEgcmVhZGFibGUgZm9ybWF0XG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKiBAcmV0dXJuIHN0cmluZ1xuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMueCtcIixcIit0aGlzLnkrXCIsXCIrdGhpcy56K1wiLFwiK3RoaXMudztcbn07XG5cbi8qKlxuICogQ29udmVydCB0byBhbiBBcnJheVxuICogQG1ldGhvZCB0b0FycmF5XG4gKiBAcmV0dXJuIEFycmF5XG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53XTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBxdWF0ZXJuaW9uIGNvbXBvbmVudHMgZ2l2ZW4gYW4gYXhpcyBhbmQgYW4gYW5nbGUuXG4gKiBAbWV0aG9kIHNldEZyb21BeGlzQW5nbGVcbiAqIEBwYXJhbSB7VmVjM30gYXhpc1xuICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuc2V0RnJvbUF4aXNBbmdsZSA9IGZ1bmN0aW9uKGF4aXMsYW5nbGUpe1xuICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGUqMC41KTtcbiAgICB0aGlzLnggPSBheGlzLnggKiBzO1xuICAgIHRoaXMueSA9IGF4aXMueSAqIHM7XG4gICAgdGhpcy56ID0gYXhpcy56ICogcztcbiAgICB0aGlzLncgPSBNYXRoLmNvcyhhbmdsZSowLjUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcXVhdGVybmlvbiB0byBheGlzL2FuZ2xlIHJlcHJlc2VudGF0aW9uLlxuICogQG1ldGhvZCB0b0F4aXNBbmdsZVxuICogQHBhcmFtIHtWZWMzfSBbdGFyZ2V0QXhpc10gQSB2ZWN0b3Igb2JqZWN0IHRvIHJldXNlIGZvciBzdG9yaW5nIHRoZSBheGlzLlxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5LCBmaXJzdCBlbGVtbnQgaXMgdGhlIGF4aXMgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGFuZ2xlIGluIHJhZGlhbnMuXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnRvQXhpc0FuZ2xlID0gZnVuY3Rpb24odGFyZ2V0QXhpcyl7XG4gICAgdGFyZ2V0QXhpcyA9IHRhcmdldEF4aXMgfHwgbmV3IFZlYzMoKTtcbiAgICB0aGlzLm5vcm1hbGl6ZSgpOyAvLyBpZiB3PjEgYWNvcyBhbmQgc3FydCB3aWxsIHByb2R1Y2UgZXJyb3JzLCB0aGlzIGNhbnQgaGFwcGVuIGlmIHF1YXRlcm5pb24gaXMgbm9ybWFsaXNlZFxuICAgIHZhciBhbmdsZSA9IDIgKiBNYXRoLmFjb3ModGhpcy53KTtcbiAgICB2YXIgcyA9IE1hdGguc3FydCgxLXRoaXMudyp0aGlzLncpOyAvLyBhc3N1bWluZyBxdWF0ZXJuaW9uIG5vcm1hbGlzZWQgdGhlbiB3IGlzIGxlc3MgdGhhbiAxLCBzbyB0ZXJtIGFsd2F5cyBwb3NpdGl2ZS5cbiAgICBpZiAocyA8IDAuMDAxKSB7IC8vIHRlc3QgdG8gYXZvaWQgZGl2aWRlIGJ5IHplcm8sIHMgaXMgYWx3YXlzIHBvc2l0aXZlIGR1ZSB0byBzcXJ0XG4gICAgICAgIC8vIGlmIHMgY2xvc2UgdG8gemVybyB0aGVuIGRpcmVjdGlvbiBvZiBheGlzIG5vdCBpbXBvcnRhbnRcbiAgICAgICAgdGFyZ2V0QXhpcy54ID0gdGhpcy54OyAvLyBpZiBpdCBpcyBpbXBvcnRhbnQgdGhhdCBheGlzIGlzIG5vcm1hbGlzZWQgdGhlbiByZXBsYWNlIHdpdGggeD0xOyB5PXo9MDtcbiAgICAgICAgdGFyZ2V0QXhpcy55ID0gdGhpcy55O1xuICAgICAgICB0YXJnZXRBeGlzLnogPSB0aGlzLno7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0QXhpcy54ID0gdGhpcy54IC8gczsgLy8gbm9ybWFsaXNlIGF4aXNcbiAgICAgICAgdGFyZ2V0QXhpcy55ID0gdGhpcy55IC8gcztcbiAgICAgICAgdGFyZ2V0QXhpcy56ID0gdGhpcy56IC8gcztcbiAgICB9XG4gICAgcmV0dXJuIFt0YXJnZXRBeGlzLGFuZ2xlXTtcbn07XG5cbnZhciBzZnZfdDEgPSBuZXcgVmVjMygpLFxuICAgIHNmdl90MiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogU2V0IHRoZSBxdWF0ZXJuaW9uIHZhbHVlIGdpdmVuIHR3byB2ZWN0b3JzLiBUaGUgcmVzdWx0aW5nIHJvdGF0aW9uIHdpbGwgYmUgdGhlIG5lZWRlZCByb3RhdGlvbiB0byByb3RhdGUgdSB0byB2LlxuICogQG1ldGhvZCBzZXRGcm9tVmVjdG9yc1xuICogQHBhcmFtIHtWZWMzfSB1XG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuc2V0RnJvbVZlY3RvcnMgPSBmdW5jdGlvbih1LHYpe1xuICAgIGlmKHUuaXNBbnRpcGFyYWxsZWxUbyh2KSl7XG4gICAgICAgIHZhciB0MSA9IHNmdl90MTtcbiAgICAgICAgdmFyIHQyID0gc2Z2X3QyO1xuXG4gICAgICAgIHUudGFuZ2VudHModDEsdDIpO1xuICAgICAgICB0aGlzLnNldEZyb21BeGlzQW5nbGUodDEsTWF0aC5QSSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGEgPSB1LmNyb3NzKHYpO1xuICAgICAgICB0aGlzLnggPSBhLng7XG4gICAgICAgIHRoaXMueSA9IGEueTtcbiAgICAgICAgdGhpcy56ID0gYS56O1xuICAgICAgICB0aGlzLncgPSBNYXRoLnNxcnQoTWF0aC5wb3codS5ub3JtKCksMikgKiBNYXRoLnBvdyh2Lm5vcm0oKSwyKSkgKyB1LmRvdCh2KTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1YXRlcm5pb24gbXVsdGlwbGljYXRpb25cbiAqIEBtZXRob2QgbXVsdFxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHRhcmdldCBPcHRpb25hbC5cbiAqIEByZXR1cm4ge1F1YXRlcm5pb259XG4gKi9cbnZhciBRdWF0ZXJuaW9uX211bHRfdmEgPSBuZXcgVmVjMygpO1xudmFyIFF1YXRlcm5pb25fbXVsdF92YiA9IG5ldyBWZWMzKCk7XG52YXIgUXVhdGVybmlvbl9tdWx0X3ZheHZiID0gbmV3IFZlYzMoKTtcblF1YXRlcm5pb24ucHJvdG90eXBlLm11bHQgPSBmdW5jdGlvbihxLHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICB2YXIgYXggPSB0aGlzLngsIGF5ID0gdGhpcy55LCBheiA9IHRoaXMueiwgYXcgPSB0aGlzLncsXG4gICAgICAgIGJ4ID0gcS54LCBieSA9IHEueSwgYnogPSBxLnosIGJ3ID0gcS53O1xuXG4gICAgdGFyZ2V0LnggPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICAgIHRhcmdldC55ID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgICB0YXJnZXQueiA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gICAgdGFyZ2V0LncgPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbnZlcnNlIHF1YXRlcm5pb24gcm90YXRpb24uXG4gKiBAbWV0aG9kIGludmVyc2VcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5pbnZlcnNlID0gZnVuY3Rpb24odGFyZ2V0KXtcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMueiwgdyA9IHRoaXMudztcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIHRoaXMuY29uanVnYXRlKHRhcmdldCk7XG4gICAgdmFyIGlub3JtMiA9IDEvKHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG4gICAgdGFyZ2V0LnggKj0gaW5vcm0yO1xuICAgIHRhcmdldC55ICo9IGlub3JtMjtcbiAgICB0YXJnZXQueiAqPSBpbm9ybTI7XG4gICAgdGFyZ2V0LncgKj0gaW5vcm0yO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBxdWF0ZXJuaW9uIGNvbmp1Z2F0ZVxuICogQG1ldGhvZCBjb25qdWdhdGVcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbih0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgdGFyZ2V0LnggPSAtdGhpcy54O1xuICAgIHRhcmdldC55ID0gLXRoaXMueTtcbiAgICB0YXJnZXQueiA9IC10aGlzLno7XG4gICAgdGFyZ2V0LncgPSB0aGlzLnc7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIHF1YXRlcm5pb24uIE5vdGUgdGhhdCB0aGlzIGNoYW5nZXMgdGhlIHZhbHVlcyBvZiB0aGUgcXVhdGVybmlvbi5cbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGwgPSBNYXRoLnNxcnQodGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMudyk7XG4gICAgaWYgKCBsID09PSAwICkge1xuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICB0aGlzLnogPSAwO1xuICAgICAgICB0aGlzLncgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGwgPSAxIC8gbDtcbiAgICAgICAgdGhpcy54ICo9IGw7XG4gICAgICAgIHRoaXMueSAqPSBsO1xuICAgICAgICB0aGlzLnogKj0gbDtcbiAgICAgICAgdGhpcy53ICo9IGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHByb3hpbWF0aW9uIG9mIHF1YXRlcm5pb24gbm9ybWFsaXphdGlvbi4gV29ya3MgYmVzdCB3aGVuIHF1YXQgaXMgYWxyZWFkeSBhbG1vc3Qtbm9ybWFsaXplZC5cbiAqIEBtZXRob2Qgbm9ybWFsaXplRmFzdFxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9mYXN0LXF1YXRlcm5pb24tbm9ybWFsaXphdGlvblxuICogQGF1dGhvciB1bnBoYXNlZCwgaHR0cHM6Ly9naXRodWIuY29tL3VucGhhc2VkXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLm5vcm1hbGl6ZUZhc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGYgPSAoMy4wLSh0aGlzLngqdGhpcy54K3RoaXMueSp0aGlzLnkrdGhpcy56KnRoaXMueit0aGlzLncqdGhpcy53KSkvMi4wO1xuICAgIGlmICggZiA9PT0gMCApIHtcbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgdGhpcy56ID0gMDtcbiAgICAgICAgdGhpcy53ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnggKj0gZjtcbiAgICAgICAgdGhpcy55ICo9IGY7XG4gICAgICAgIHRoaXMueiAqPSBmO1xuICAgICAgICB0aGlzLncgKj0gZjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHRoZSBxdWF0ZXJuaW9uIGJ5IGEgdmVjdG9yXG4gKiBAbWV0aG9kIHZtdWx0XG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsXG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS52bXVsdCA9IGZ1bmN0aW9uKHYsdGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcblxuICAgIHZhciB4ID0gdi54LFxuICAgICAgICB5ID0gdi55LFxuICAgICAgICB6ID0gdi56O1xuXG4gICAgdmFyIHF4ID0gdGhpcy54LFxuICAgICAgICBxeSA9IHRoaXMueSxcbiAgICAgICAgcXogPSB0aGlzLnosXG4gICAgICAgIHF3ID0gdGhpcy53O1xuXG4gICAgLy8gcSp2XG4gICAgdmFyIGl4ID0gIHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICBpeSA9ICBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgaXogPSAgcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIHRhcmdldC54ID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICB0YXJnZXQueSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgdGFyZ2V0LnogPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogQ29waWVzIHZhbHVlIG9mIHNvdXJjZSB0byB0aGlzIHF1YXRlcm5pb24uXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gc291cmNlXG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufSB0aGlzXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihzb3VyY2Upe1xuICAgIHRoaXMueCA9IHNvdXJjZS54O1xuICAgIHRoaXMueSA9IHNvdXJjZS55O1xuICAgIHRoaXMueiA9IHNvdXJjZS56O1xuICAgIHRoaXMudyA9IHNvdXJjZS53O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBxdWF0ZXJuaW9uIHRvIGV1bGVyIGFuZ2xlIHJlcHJlc2VudGF0aW9uLiBPcmRlcjogWVpYLCBhcyB0aGlzIHBhZ2UgZGVzY3JpYmVzOiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9zdGFuZGFyZHMvaW5kZXguaHRtXG4gKiBAbWV0aG9kIHRvRXVsZXJcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XG4gKiBAcGFyYW0gc3RyaW5nIG9yZGVyIFRocmVlLWNoYXJhY3RlciBzdHJpbmcgZS5nLiBcIllaWFwiLCB3aGljaCBhbHNvIGlzIGRlZmF1bHQuXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnRvRXVsZXIgPSBmdW5jdGlvbih0YXJnZXQsb3JkZXIpe1xuICAgIG9yZGVyID0gb3JkZXIgfHwgXCJZWlhcIjtcblxuICAgIHZhciBoZWFkaW5nLCBhdHRpdHVkZSwgYmFuaztcbiAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMueiwgdyA9IHRoaXMudztcblxuICAgIHN3aXRjaChvcmRlcil7XG4gICAgY2FzZSBcIllaWFwiOlxuICAgICAgICB2YXIgdGVzdCA9IHgqeSArIHoqdztcbiAgICAgICAgaWYgKHRlc3QgPiAwLjQ5OSkgeyAvLyBzaW5ndWxhcml0eSBhdCBub3J0aCBwb2xlXG4gICAgICAgICAgICBoZWFkaW5nID0gMiAqIE1hdGguYXRhbjIoeCx3KTtcbiAgICAgICAgICAgIGF0dGl0dWRlID0gTWF0aC5QSS8yO1xuICAgICAgICAgICAgYmFuayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlc3QgPCAtMC40OTkpIHsgLy8gc2luZ3VsYXJpdHkgYXQgc291dGggcG9sZVxuICAgICAgICAgICAgaGVhZGluZyA9IC0yICogTWF0aC5hdGFuMih4LHcpO1xuICAgICAgICAgICAgYXR0aXR1ZGUgPSAtIE1hdGguUEkvMjtcbiAgICAgICAgICAgIGJhbmsgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmKGlzTmFOKGhlYWRpbmcpKXtcbiAgICAgICAgICAgIHZhciBzcXggPSB4Kng7XG4gICAgICAgICAgICB2YXIgc3F5ID0geSp5O1xuICAgICAgICAgICAgdmFyIHNxeiA9IHoqejtcbiAgICAgICAgICAgIGhlYWRpbmcgPSBNYXRoLmF0YW4yKDIqeSp3IC0gMip4KnogLCAxIC0gMipzcXkgLSAyKnNxeik7IC8vIEhlYWRpbmdcbiAgICAgICAgICAgIGF0dGl0dWRlID0gTWF0aC5hc2luKDIqdGVzdCk7IC8vIGF0dGl0dWRlXG4gICAgICAgICAgICBiYW5rID0gTWF0aC5hdGFuMigyKngqdyAtIDIqeSp6ICwgMSAtIDIqc3F4IC0gMipzcXopOyAvLyBiYW5rXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXVsZXIgb3JkZXIgXCIrb3JkZXIrXCIgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO1xuICAgIH1cblxuICAgIHRhcmdldC55ID0gaGVhZGluZztcbiAgICB0YXJnZXQueiA9IGF0dGl0dWRlO1xuICAgIHRhcmdldC54ID0gYmFuaztcbn07XG5cbi8qKlxuICogU2VlIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS8yMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9jb250ZW50L1NwaW5DYWxjLm1cbiAqIEBtZXRob2Qgc2V0RnJvbUV1bGVyXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKiBAcGFyYW0ge1N0cmluZ30gb3JkZXIgVGhlIG9yZGVyIHRvIGFwcGx5IGFuZ2xlczogJ1hZWicgb3IgJ1lYWicgb3IgYW55IG90aGVyIGNvbWJpbmF0aW9uXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnNldEZyb21FdWxlciA9IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XG4gICAgb3JkZXIgPSBvcmRlciB8fCBcIlhZWlwiO1xuXG4gICAgdmFyIGMxID0gTWF0aC5jb3MoIHggLyAyICk7XG4gICAgdmFyIGMyID0gTWF0aC5jb3MoIHkgLyAyICk7XG4gICAgdmFyIGMzID0gTWF0aC5jb3MoIHogLyAyICk7XG4gICAgdmFyIHMxID0gTWF0aC5zaW4oIHggLyAyICk7XG4gICAgdmFyIHMyID0gTWF0aC5zaW4oIHkgLyAyICk7XG4gICAgdmFyIHMzID0gTWF0aC5zaW4oIHogLyAyICk7XG5cbiAgICBpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcblxuICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG4gICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xuXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcblxuICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xuXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRcbiAqXG4gKiBAbWV0aG9kIHNsZXJwXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHRvUXVhdCBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgc2VsZiBxdWF0ZXJuaW9uIGFuZCB0b1F1YXRcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gW3RhcmdldF0gQSBxdWF0ZXJuaW9uIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uIElmIG5vdCBwcm92aWRlZCwgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm5zIHtRdWF0ZXJuaW9ufSBUaGUgXCJ0YXJnZXRcIiBvYmplY3RcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuc2xlcnAgPSBmdW5jdGlvbiAodG9RdWF0LCB0LCB0YXJnZXQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIHZhciBheCA9IHRoaXMueCxcbiAgICAgICAgYXkgPSB0aGlzLnksXG4gICAgICAgIGF6ID0gdGhpcy56LFxuICAgICAgICBhdyA9IHRoaXMudyxcbiAgICAgICAgYnggPSB0b1F1YXQueCxcbiAgICAgICAgYnkgPSB0b1F1YXQueSxcbiAgICAgICAgYnogPSB0b1F1YXQueixcbiAgICAgICAgYncgPSB0b1F1YXQudztcblxuICAgIHZhciBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTtcblxuICAgIC8vIGNhbGMgY29zaW5lXG4gICAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xuXG4gICAgLy8gYWRqdXN0IHNpZ25zIChpZiBuZWNlc3NhcnkpXG4gICAgaWYgKCBjb3NvbSA8IDAuMCApIHtcbiAgICAgICAgY29zb20gPSAtY29zb207XG4gICAgICAgIGJ4ID0gLSBieDtcbiAgICAgICAgYnkgPSAtIGJ5O1xuICAgICAgICBieiA9IC0gYno7XG4gICAgICAgIGJ3ID0gLSBidztcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgY29lZmZpY2llbnRzXG4gICAgaWYgKCAoMS4wIC0gY29zb20pID4gMC4wMDAwMDEgKSB7XG4gICAgICAgIC8vIHN0YW5kYXJkIGNhc2UgKHNsZXJwKVxuICAgICAgICBvbWVnYSAgPSBNYXRoLmFjb3MoY29zb20pO1xuICAgICAgICBzaW5vbSAgPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgICAgIHNjYWxlMCA9IE1hdGguc2luKCgxLjAgLSB0KSAqIG9tZWdhKSAvIHNpbm9tO1xuICAgICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBxdWF0ZXJuaW9ucyBhcmUgdmVyeSBjbG9zZVxuICAgICAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgICAgIHNjYWxlMSA9IHQ7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlc1xuICAgIHRhcmdldC54ID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcbiAgICB0YXJnZXQueSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gICAgdGFyZ2V0LnogPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xuICAgIHRhcmdldC53ID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhbiBhYnNvbHV0ZSBvcmllbnRhdGlvbiBxdWF0ZXJuaW9uIGdpdmVuIGFuIGFuZ3VsYXIgdmVsb2NpdHkgYW5kIGEgdGltZSBzdGVwLlxuICogQHBhcmFtICB7VmVjM30gYW5ndWxhclZlbG9jaXR5XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGR0XG4gKiBAcGFyYW0gIHtWZWMzfSBhbmd1bGFyRmFjdG9yXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSB0YXJnZXRcbiAqIEByZXR1cm4ge1F1YXRlcm5pb259IFRoZSBcInRhcmdldFwiIG9iamVjdFxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5pbnRlZ3JhdGUgPSBmdW5jdGlvbihhbmd1bGFyVmVsb2NpdHksIGR0LCBhbmd1bGFyRmFjdG9yLCB0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgdmFyIGF4ID0gYW5ndWxhclZlbG9jaXR5LnggKiBhbmd1bGFyRmFjdG9yLngsXG4gICAgICAgIGF5ID0gYW5ndWxhclZlbG9jaXR5LnkgKiBhbmd1bGFyRmFjdG9yLnksXG4gICAgICAgIGF6ID0gYW5ndWxhclZlbG9jaXR5LnogKiBhbmd1bGFyRmFjdG9yLnosXG4gICAgICAgIGJ4ID0gdGhpcy54LFxuICAgICAgICBieSA9IHRoaXMueSxcbiAgICAgICAgYnogPSB0aGlzLnosXG4gICAgICAgIGJ3ID0gdGhpcy53O1xuXG4gICAgdmFyIGhhbGZfZHQgPSBkdCAqIDAuNTtcblxuICAgIHRhcmdldC54ICs9IGhhbGZfZHQgKiAoYXggKiBidyArIGF5ICogYnogLSBheiAqIGJ5KTtcbiAgICB0YXJnZXQueSArPSBoYWxmX2R0ICogKGF5ICogYncgKyBheiAqIGJ4IC0gYXggKiBieik7XG4gICAgdGFyZ2V0LnogKz0gaGFsZl9kdCAqIChheiAqIGJ3ICsgYXggKiBieSAtIGF5ICogYngpO1xuICAgIHRhcmdldC53ICs9IGhhbGZfZHQgKiAoLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYnopO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07IiwidmFyIFZlYzMgPSByZXF1aXJlKCcuL1ZlYzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gcmVxdWlyZSgnLi9RdWF0ZXJuaW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG4vKipcbiAqIEBjbGFzcyBUcmFuc2Zvcm1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge1ZlYzN9IHBvc2l0aW9uXG5cdCAqL1xuXHR0aGlzLnBvc2l0aW9uID0gbmV3IFZlYzMoKTtcbiAgICBpZihvcHRpb25zLnBvc2l0aW9uKXtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KG9wdGlvbnMucG9zaXRpb24pO1xuICAgIH1cblxuXHQvKipcblx0ICogQHByb3BlcnR5IHtRdWF0ZXJuaW9ufSBxdWF0ZXJuaW9uXG5cdCAqL1xuXHR0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIGlmKG9wdGlvbnMucXVhdGVybmlvbil7XG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XG4gICAgfVxufVxuXG52YXIgdG1wUXVhdCA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBwb2ludFRvTG9jYUZyYW1lXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc2l0aW9uXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7VmVjM30gd29ybGRQb2ludFxuICogQHBhcmFtIHtWZWMzfSByZXN1bHRcbiAqL1xuVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24ocG9zaXRpb24sIHF1YXRlcm5pb24sIHdvcmxkUG9pbnQsIHJlc3VsdCl7XG4gICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgVmVjMygpO1xuICAgIHdvcmxkUG9pbnQudnN1Yihwb3NpdGlvbiwgcmVzdWx0KTtcbiAgICBxdWF0ZXJuaW9uLmNvbmp1Z2F0ZSh0bXBRdWF0KTtcbiAgICB0bXBRdWF0LnZtdWx0KHJlc3VsdCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBHZXQgYSBnbG9iYWwgcG9pbnQgaW4gbG9jYWwgdHJhbnNmb3JtIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBwb2ludFRvTG9jYWxcbiAqIEBwYXJhbSAge1ZlYzN9IHBvaW50XG4gKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcInJlc3VsdFwiIHZlY3RvciBvYmplY3RcbiAqL1xuVHJhbnNmb3JtLnByb3RvdHlwZS5wb2ludFRvTG9jYWwgPSBmdW5jdGlvbih3b3JsZFBvaW50LCByZXN1bHQpe1xuICAgIHJldHVybiBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUodGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB3b3JsZFBvaW50LCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHBvaW50VG9Xb3JsZEZyYW1lXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc2l0aW9uXG4gKiBAcGFyYW0ge1ZlYzN9IHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7VmVjM30gbG9jYWxQb2ludFxuICogQHBhcmFtIHtWZWMzfSByZXN1bHRcbiAqL1xuVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24ocG9zaXRpb24sIHF1YXRlcm5pb24sIGxvY2FsUG9pbnQsIHJlc3VsdCl7XG4gICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgVmVjMygpO1xuICAgIHF1YXRlcm5pb24udm11bHQobG9jYWxQb2ludCwgcmVzdWx0KTtcbiAgICByZXN1bHQudmFkZChwb3NpdGlvbiwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBHZXQgYSBsb2NhbCBwb2ludCBpbiBnbG9iYWwgdHJhbnNmb3JtIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBwb2ludFRvV29ybGRcbiAqIEBwYXJhbSAge1ZlYzN9IHBvaW50XG4gKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcInJlc3VsdFwiIHZlY3RvciBvYmplY3RcbiAqL1xuVHJhbnNmb3JtLnByb3RvdHlwZS5wb2ludFRvV29ybGQgPSBmdW5jdGlvbihsb2NhbFBvaW50LCByZXN1bHQpe1xuICAgIHJldHVybiBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCBsb2NhbFBvaW50LCByZXN1bHQpO1xufTtcblxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnZlY3RvclRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uKGxvY2FsVmVjdG9yLCByZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcbiAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxWZWN0b3IsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUgPSBmdW5jdGlvbihxdWF0ZXJuaW9uLCBsb2NhbFZlY3RvciwgcmVzdWx0KXtcbiAgICBxdWF0ZXJuaW9uLnZtdWx0KGxvY2FsVmVjdG9yLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5UcmFuc2Zvcm0udmVjdG9yVG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24ocG9zaXRpb24sIHF1YXRlcm5pb24sIHdvcmxkVmVjdG9yLCByZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcbiAgICBxdWF0ZXJuaW9uLncgKj0gLTE7XG4gICAgcXVhdGVybmlvbi52bXVsdCh3b3JsZFZlY3RvciwgcmVzdWx0KTtcbiAgICBxdWF0ZXJuaW9uLncgKj0gLTE7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFZlYzM7XG5cbnZhciBNYXQzID0gcmVxdWlyZSgnLi9NYXQzJyk7XG5cbi8qKlxuICogMy1kaW1lbnNpb25hbCB2ZWN0b3JcbiAqIEBjbGFzcyBWZWMzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIHYgPSBuZXcgVmVjMygxLCAyLCAzKTtcbiAqICAgICBjb25zb2xlLmxvZygneD0nICsgdi54KTsgLy8geD0xXG4gKi9cbmZ1bmN0aW9uIFZlYzMoeCx5LHope1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB4XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnggPSB4fHwwLjA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgeVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy55ID0geXx8MC4wO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMueiA9IHp8fDAuMDtcbn1cblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge1ZlYzN9IFpFUk9cbiAqL1xuVmVjMy5aRVJPID0gbmV3IFZlYzMoMCwgMCwgMCk7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtWZWMzfSBVTklUX1hcbiAqL1xuVmVjMy5VTklUX1ggPSBuZXcgVmVjMygxLCAwLCAwKTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge1ZlYzN9IFVOSVRfWVxuICovXG5WZWMzLlVOSVRfWSA9IG5ldyBWZWMzKDAsIDEsIDApO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7VmVjM30gVU5JVF9aXG4gKi9cblZlYzMuVU5JVF9aID0gbmV3IFZlYzMoMCwgMCwgMSk7XG5cbi8qKlxuICogVmVjdG9yIGNyb3NzIHByb2R1Y3RcbiAqIEBtZXRob2QgY3Jvc3NcbiAqIEBwYXJhbSB7VmVjM30gdlxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwuIFRhcmdldCB0byBzYXZlIGluLlxuICogQHJldHVybiB7VmVjM31cbiAqL1xuVmVjMy5wcm90b3R5cGUuY3Jvc3MgPSBmdW5jdGlvbih2LHRhcmdldCl7XG4gICAgdmFyIHZ4PXYueCwgdnk9di55LCB2ej12LnosIHg9dGhpcy54LCB5PXRoaXMueSwgej10aGlzLno7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG5cbiAgICB0YXJnZXQueCA9ICh5ICogdnopIC0gKHogKiB2eSk7XG4gICAgdGFyZ2V0LnkgPSAoeiAqIHZ4KSAtICh4ICogdnopO1xuICAgIHRhcmdldC56ID0gKHggKiB2eSkgLSAoeSAqIHZ4KTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdmVjdG9ycycgMyBlbGVtZW50c1xuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAqIEByZXR1cm4gVmVjM1xuICovXG5WZWMzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih4LHkseil7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBhbGwgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yIHRvIHplcm8uXG4gKiBAbWV0aG9kIHNldFplcm9cbiAqL1xuVmVjMy5wcm90b3R5cGUuc2V0WmVybyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy54ID0gdGhpcy55ID0gdGhpcy56ID0gMDtcbn07XG5cbi8qKlxuICogVmVjdG9yIGFkZGl0aW9uXG4gKiBAbWV0aG9kIHZhZGRcbiAqIEBwYXJhbSB7VmVjM30gdlxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwuXG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5WZWMzLnByb3RvdHlwZS52YWRkID0gZnVuY3Rpb24odix0YXJnZXQpe1xuICAgIGlmKHRhcmdldCl7XG4gICAgICAgIHRhcmdldC54ID0gdi54ICsgdGhpcy54O1xuICAgICAgICB0YXJnZXQueSA9IHYueSArIHRoaXMueTtcbiAgICAgICAgdGFyZ2V0LnogPSB2LnogKyB0aGlzLno7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMueCArIHYueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnkgKyB2LnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56ICsgdi56KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFZlY3RvciBzdWJ0cmFjdGlvblxuICogQG1ldGhvZCB2c3ViXG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgdG8gc2F2ZSBpbi5cbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblZlYzMucHJvdG90eXBlLnZzdWIgPSBmdW5jdGlvbih2LHRhcmdldCl7XG4gICAgaWYodGFyZ2V0KXtcbiAgICAgICAgdGFyZ2V0LnggPSB0aGlzLnggLSB2Lng7XG4gICAgICAgIHRhcmdldC55ID0gdGhpcy55IC0gdi55O1xuICAgICAgICB0YXJnZXQueiA9IHRoaXMueiAtIHYuejtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy54LXYueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnktdi55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuei12LnopO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBjcm9zcyBwcm9kdWN0IG1hdHJpeCBhX2Nyb3NzIGZyb20gYSB2ZWN0b3IsIHN1Y2ggdGhhdCBhIHggYiA9IGFfY3Jvc3MgKiBiID0gY1xuICogQG1ldGhvZCBjcm9zc21hdFxuICogQHNlZSBodHRwOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyL1REQkQyNC9WVDA2L2xlY3R1cmVzL0xlY3R1cmU2LnBkZlxuICogQHJldHVybiB7TWF0M31cbiAqL1xuVmVjMy5wcm90b3R5cGUuY3Jvc3NtYXQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgTWF0MyhbICAgICAwLCAgLXRoaXMueiwgICB0aGlzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56LCAgICAgICAgMCwgIC10aGlzLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAtdGhpcy55LCAgIHRoaXMueCwgICAgICAgIDBdKTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSB2ZWN0b3IuIE5vdGUgdGhhdCB0aGlzIGNoYW5nZXMgdGhlIHZhbHVlcyBpbiB0aGUgdmVjdG9yLlxuICogQG1ldGhvZCBub3JtYWxpemVcbiAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgbm9ybSBvZiB0aGUgdmVjdG9yXG4gKi9cblZlYzMucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHg9dGhpcy54LCB5PXRoaXMueSwgej10aGlzLno7XG4gICAgdmFyIG4gPSBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbiAgICBpZihuPjAuMCl7XG4gICAgICAgIHZhciBpbnZOID0gMS9uO1xuICAgICAgICB0aGlzLnggKj0gaW52TjtcbiAgICAgICAgdGhpcy55ICo9IGludk47XG4gICAgICAgIHRoaXMueiAqPSBpbnZOO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1ha2Ugc29tZXRoaW5nIHVwXG4gICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgIHRoaXMueiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBuO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHZlcnNpb24gb2YgdGhpcyB2ZWN0b3IgdGhhdCBpcyBvZiBsZW5ndGggMS5cbiAqIEBtZXRob2QgdW5pdFxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwgdGFyZ2V0IHRvIHNhdmUgaW5cbiAqIEByZXR1cm4ge1ZlYzN9IFJldHVybnMgdGhlIHVuaXQgdmVjdG9yXG4gKi9cblZlYzMucHJvdG90eXBlLnVuaXQgPSBmdW5jdGlvbih0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHZhciBuaW52ID0gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG4gICAgaWYobmludj4wLjApe1xuICAgICAgICBuaW52ID0gMS4wL25pbnY7XG4gICAgICAgIHRhcmdldC54ID0geCAqIG5pbnY7XG4gICAgICAgIHRhcmdldC55ID0geSAqIG5pbnY7XG4gICAgICAgIHRhcmdldC56ID0geiAqIG5pbnY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0LnggPSAxO1xuICAgICAgICB0YXJnZXQueSA9IDA7XG4gICAgICAgIHRhcmdldC56ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxuICogQG1ldGhvZCBub3JtXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAZGVwcmVjYXRlZCBVc2UgLmxlbmd0aCgpIGluc3RlYWRcbiAqL1xuVmVjMy5wcm90b3R5cGUubm9ybSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHg9dGhpcy54LCB5PXRoaXMueSwgej10aGlzLno7XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9yXG4gKiBAbWV0aG9kIGxlbmd0aFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5WZWMzLnByb3RvdHlwZS5sZW5ndGggPSBWZWMzLnByb3RvdHlwZS5ub3JtO1xuXG4vKipcbiAqIEdldCB0aGUgc3F1YXJlZCBsZW5ndGggb2YgdGhlIHZlY3RvclxuICogQG1ldGhvZCBub3JtMlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGRlcHJlY2F0ZWQgVXNlIC5sZW5ndGhTcXVhcmVkKCkgaW5zdGVhZC5cbiAqL1xuVmVjMy5wcm90b3R5cGUubm9ybTIgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmRvdCh0aGlzKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGUgdmVjdG9yLlxuICogQG1ldGhvZCBsZW5ndGhTcXVhcmVkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblZlYzMucHJvdG90eXBlLmxlbmd0aFNxdWFyZWQgPSBWZWMzLnByb3RvdHlwZS5ub3JtMjtcblxuLyoqXG4gKiBHZXQgZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIGFub3RoZXIgcG9pbnRcbiAqIEBtZXRob2QgZGlzdGFuY2VUb1xuICogQHBhcmFtICB7VmVjM30gcFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5WZWMzLnByb3RvdHlwZS5kaXN0YW5jZVRvID0gZnVuY3Rpb24ocCl7XG4gICAgdmFyIHg9dGhpcy54LCB5PXRoaXMueSwgej10aGlzLno7XG4gICAgdmFyIHB4PXAueCwgcHk9cC55LCBwej1wLno7XG4gICAgcmV0dXJuIE1hdGguc3FydCgocHgteCkqKHB4LXgpK1xuICAgICAgICAgICAgICAgICAgICAgKHB5LXkpKihweS15KStcbiAgICAgICAgICAgICAgICAgICAgIChwei16KSoocHoteikpO1xufTtcblxuLyoqXG4gKiBHZXQgc3F1YXJlZCBkaXN0YW5jZSBmcm9tIHRoaXMgcG9pbnQgdG8gYW5vdGhlciBwb2ludFxuICogQG1ldGhvZCBkaXN0YW5jZVNxdWFyZWRcbiAqIEBwYXJhbSAge1ZlYzN9IHBcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVmVjMy5wcm90b3R5cGUuZGlzdGFuY2VTcXVhcmVkID0gZnVuY3Rpb24ocCl7XG4gICAgdmFyIHg9dGhpcy54LCB5PXRoaXMueSwgej10aGlzLno7XG4gICAgdmFyIHB4PXAueCwgcHk9cC55LCBwej1wLno7XG4gICAgcmV0dXJuIChweC14KSoocHgteCkgKyAocHkteSkqKHB5LXkpICsgKHB6LXopKihwei16KTtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgYWxsIHRoZSBjb21wb25lbnRzIG9mIHRoZSB2ZWN0b3Igd2l0aCBhIHNjYWxhci5cbiAqIEBkZXByZWNhdGVkIFVzZSAuc2NhbGUgaW5zdGVhZFxuICogQG1ldGhvZCBtdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBUaGUgdmVjdG9yIHRvIHNhdmUgdGhlIHJlc3VsdCBpbi5cbiAqIEByZXR1cm4ge1ZlYzN9XG4gKiBAZGVwcmVjYXRlZCBVc2UgLnNjYWxlKCkgaW5zdGVhZFxuICovXG5WZWMzLnByb3RvdHlwZS5tdWx0ID0gZnVuY3Rpb24oc2NhbGFyLHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgIHkgPSB0aGlzLnksXG4gICAgICAgIHogPSB0aGlzLno7XG4gICAgdGFyZ2V0LnggPSBzY2FsYXIgKiB4O1xuICAgIHRhcmdldC55ID0gc2NhbGFyICogeTtcbiAgICB0YXJnZXQueiA9IHNjYWxhciAqIHo7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgdGhlIHZlY3RvciB3aXRoIGFuIG90aGVyIHZlY3RvciwgY29tcG9uZW50LXdpc2UuXG4gKiBAbWV0aG9kIG11bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZWN0b3JcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IFRoZSB2ZWN0b3IgdG8gc2F2ZSB0aGUgcmVzdWx0IGluLlxuICogQHJldHVybiB7VmVjM31cbiAqL1xuVmVjMy5wcm90b3R5cGUudm11bCA9IGZ1bmN0aW9uKHZlY3RvciwgdGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcbiAgICB0YXJnZXQueCA9IHZlY3Rvci54ICogdGhpcy54O1xuICAgIHRhcmdldC55ID0gdmVjdG9yLnkgKiB0aGlzLnk7XG4gICAgdGFyZ2V0LnogPSB2ZWN0b3IueiAqIHRoaXMuejtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgdmVjdG9yIHdpdGggYSBzY2FsYXIuXG4gKiBAbWV0aG9kIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuVmVjMy5wcm90b3R5cGUuc2NhbGUgPSBWZWMzLnByb3RvdHlwZS5tdWx0O1xuXG4vKipcbiAqIFNjYWxlIGEgdmVjdG9yIGFuZCBhZGQgaXQgdG8gdGhpcyB2ZWN0b3IuIFNhdmUgdGhlIHJlc3VsdCBpbiBcInRhcmdldFwiLiAodGFyZ2V0ID0gdGhpcyArIHZlY3RvciAqIHNjYWxhcilcbiAqIEBtZXRob2QgYWRkU2NhbGVkVmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGFyXG4gKiBAcGFyYW0ge1ZlYzN9IHZlY3RvclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgVGhlIHZlY3RvciB0byBzYXZlIHRoZSByZXN1bHQgaW4uXG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5WZWMzLnByb3RvdHlwZS5hZGRTY2FsZWRWZWN0b3IgPSBmdW5jdGlvbihzY2FsYXIsIHZlY3RvciwgdGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcbiAgICB0YXJnZXQueCA9IHRoaXMueCArIHNjYWxhciAqIHZlY3Rvci54O1xuICAgIHRhcmdldC55ID0gdGhpcy55ICsgc2NhbGFyICogdmVjdG9yLnk7XG4gICAgdGFyZ2V0LnogPSB0aGlzLnogKyBzY2FsYXIgKiB2ZWN0b3IuejtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgZG90IHByb2R1Y3RcbiAqIEBtZXRob2QgZG90XG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVmVjMy5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24odil7XG4gICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBpc1plcm9cbiAqIEByZXR1cm4gYm9vbFxuICovXG5WZWMzLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLng9PT0wICYmIHRoaXMueT09PTAgJiYgdGhpcy56PT09MDtcbn07XG5cbi8qKlxuICogTWFrZSB0aGUgdmVjdG9yIHBvaW50IGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gKiBAbWV0aG9kIG5lZ2F0ZVxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwgdGFyZ2V0IHRvIHNhdmUgaW5cbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblZlYzMucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uKHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGFyZ2V0LnggPSAtdGhpcy54O1xuICAgIHRhcmdldC55ID0gLXRoaXMueTtcbiAgICB0YXJnZXQueiA9IC10aGlzLno7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0d28gYXJ0aWZpY2lhbCB0YW5nZW50cyB0byB0aGUgdmVjdG9yXG4gKiBAbWV0aG9kIHRhbmdlbnRzXG4gKiBAcGFyYW0ge1ZlYzN9IHQxIFZlY3RvciBvYmplY3QgdG8gc2F2ZSB0aGUgZmlyc3QgdGFuZ2VudCBpblxuICogQHBhcmFtIHtWZWMzfSB0MiBWZWN0b3Igb2JqZWN0IHRvIHNhdmUgdGhlIHNlY29uZCB0YW5nZW50IGluXG4gKi9cbnZhciBWZWMzX3RhbmdlbnRzX24gPSBuZXcgVmVjMygpO1xudmFyIFZlYzNfdGFuZ2VudHNfcmFuZFZlYyA9IG5ldyBWZWMzKCk7XG5WZWMzLnByb3RvdHlwZS50YW5nZW50cyA9IGZ1bmN0aW9uKHQxLHQyKXtcbiAgICB2YXIgbm9ybSA9IHRoaXMubm9ybSgpO1xuICAgIGlmKG5vcm0+MC4wKXtcbiAgICAgICAgdmFyIG4gPSBWZWMzX3RhbmdlbnRzX247XG4gICAgICAgIHZhciBpbm9ybSA9IDEvbm9ybTtcbiAgICAgICAgbi5zZXQodGhpcy54Kmlub3JtLHRoaXMueSppbm9ybSx0aGlzLnoqaW5vcm0pO1xuICAgICAgICB2YXIgcmFuZFZlYyA9IFZlYzNfdGFuZ2VudHNfcmFuZFZlYztcbiAgICAgICAgaWYoTWF0aC5hYnMobi54KSA8IDAuOSl7XG4gICAgICAgICAgICByYW5kVmVjLnNldCgxLDAsMCk7XG4gICAgICAgICAgICBuLmNyb3NzKHJhbmRWZWMsdDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmFuZFZlYy5zZXQoMCwxLDApO1xuICAgICAgICAgICAgbi5jcm9zcyhyYW5kVmVjLHQxKTtcbiAgICAgICAgfVxuICAgICAgICBuLmNyb3NzKHQxLHQyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgbm9ybWFsIGxlbmd0aCBpcyB6ZXJvLCBtYWtlIHNvbWV0aGluZyB1cFxuICAgICAgICB0MS5zZXQoMSwgMCwgMCk7XG4gICAgICAgIHQyLnNldCgwLCAxLCAwKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRvIGEgbW9yZSByZWFkYWJsZSBmb3JtYXRcbiAqIEBtZXRob2QgdG9TdHJpbmdcbiAqIEByZXR1cm4gc3RyaW5nXG4gKi9cblZlYzMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy54K1wiLFwiK3RoaXMueStcIixcIit0aGlzLno7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRvIGFuIGFycmF5XG4gKiBAbWV0aG9kIHRvQXJyYXlcbiAqIEByZXR1cm4gQXJyYXlcbiAqL1xuVmVjMy5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueSwgdGhpcy56XTtcbn07XG5cbi8qKlxuICogQ29waWVzIHZhbHVlIG9mIHNvdXJjZSB0byB0aGlzIHZlY3Rvci5cbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtIHtWZWMzfSBzb3VyY2VcbiAqIEByZXR1cm4ge1ZlYzN9IHRoaXNcbiAqL1xuVmVjMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHNvdXJjZSl7XG4gICAgdGhpcy54ID0gc291cmNlLng7XG4gICAgdGhpcy55ID0gc291cmNlLnk7XG4gICAgdGhpcy56ID0gc291cmNlLno7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogRG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWN0b3JzXG4gKiBAbWV0aG9kIGxlcnBcbiAqIEBwYXJhbSB7VmVjM30gdlxuICogQHBhcmFtIHtOdW1iZXJ9IHQgQSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLiAwIHdpbGwgbWFrZSB0aGlzIGZ1bmN0aW9uIHJldHVybiB1LCBhbmQgMSB3aWxsIG1ha2UgaXQgcmV0dXJuIHYuIE51bWJlcnMgaW4gYmV0d2VlbiB3aWxsIGdlbmVyYXRlIGEgdmVjdG9yIGluIGJldHdlZW4gdGhlbS5cbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XG4gKi9cblZlYzMucHJvdG90eXBlLmxlcnAgPSBmdW5jdGlvbih2LHQsdGFyZ2V0KXtcbiAgICB2YXIgeD10aGlzLngsIHk9dGhpcy55LCB6PXRoaXMuejtcbiAgICB0YXJnZXQueCA9IHggKyAodi54LXgpKnQ7XG4gICAgdGFyZ2V0LnkgPSB5ICsgKHYueS15KSp0O1xuICAgIHRhcmdldC56ID0geiArICh2LnoteikqdDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2ZWN0b3IgZXF1YWxzIGlzIGFsbW9zdCBlcXVhbCB0byBhbm90aGVyIG9uZS5cbiAqIEBtZXRob2QgYWxtb3N0RXF1YWxzXG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmVjaXNpb25cbiAqIEByZXR1cm4gYm9vbFxuICovXG5WZWMzLnByb3RvdHlwZS5hbG1vc3RFcXVhbHMgPSBmdW5jdGlvbih2LHByZWNpc2lvbil7XG4gICAgaWYocHJlY2lzaW9uPT09dW5kZWZpbmVkKXtcbiAgICAgICAgcHJlY2lzaW9uID0gMWUtNjtcbiAgICB9XG4gICAgaWYoIE1hdGguYWJzKHRoaXMueC12LngpPnByZWNpc2lvbiB8fFxuICAgICAgICBNYXRoLmFicyh0aGlzLnktdi55KT5wcmVjaXNpb24gfHxcbiAgICAgICAgTWF0aC5hYnModGhpcy56LXYueik+cHJlY2lzaW9uKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2ZWN0b3IgaXMgYWxtb3N0IHplcm9cbiAqIEBtZXRob2QgYWxtb3N0WmVyb1xuICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc2lvblxuICovXG5WZWMzLnByb3RvdHlwZS5hbG1vc3RaZXJvID0gZnVuY3Rpb24ocHJlY2lzaW9uKXtcbiAgICBpZihwcmVjaXNpb249PT11bmRlZmluZWQpe1xuICAgICAgICBwcmVjaXNpb24gPSAxZS02O1xuICAgIH1cbiAgICBpZiggTWF0aC5hYnModGhpcy54KT5wcmVjaXNpb24gfHxcbiAgICAgICAgTWF0aC5hYnModGhpcy55KT5wcmVjaXNpb24gfHxcbiAgICAgICAgTWF0aC5hYnModGhpcy56KT5wcmVjaXNpb24pe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxudmFyIGFudGlwX25lZyA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHZlY3RvciBpcyBhbnRpLXBhcmFsbGVsIHRvIGFub3RoZXIgdmVjdG9yLlxuICogQG1ldGhvZCBpc0FudGlwYXJhbGxlbFRvXG4gKiBAcGFyYW0gIHtWZWMzfSAgdlxuICogQHBhcmFtICB7TnVtYmVyfSAgcHJlY2lzaW9uIFNldCB0byB6ZXJvIGZvciBleGFjdCBjb21wYXJpc29uc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuVmVjMy5wcm90b3R5cGUuaXNBbnRpcGFyYWxsZWxUbyA9IGZ1bmN0aW9uKHYscHJlY2lzaW9uKXtcbiAgICB0aGlzLm5lZ2F0ZShhbnRpcF9uZWcpO1xuICAgIHJldHVybiBhbnRpcF9uZWcuYWxtb3N0RXF1YWxzKHYscHJlY2lzaW9uKTtcbn07XG5cbi8qKlxuICogQ2xvbmUgdGhlIHZlY3RvclxuICogQG1ldGhvZCBjbG9uZVxuICogQHJldHVybiB7VmVjM31cbiAqL1xuVmVjMy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLngsIHRoaXMueSwgdGhpcy56KTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBCb2R5O1xuXG52YXIgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuLi91dGlscy9FdmVudFRhcmdldCcpO1xudmFyIFNoYXBlID0gcmVxdWlyZSgnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIE1hdDMgPSByZXF1aXJlKCcuLi9tYXRoL01hdDMnKTtcbnZhciBRdWF0ZXJuaW9uID0gcmVxdWlyZSgnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG52YXIgTWF0ZXJpYWwgPSByZXF1aXJlKCcuLi9tYXRlcmlhbC9NYXRlcmlhbCcpO1xudmFyIEFBQkIgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQUFCQicpO1xudmFyIEJveCA9IHJlcXVpcmUoJy4uL3NoYXBlcy9Cb3gnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgYm9keSB0eXBlcy5cbiAqIEBjbGFzcyBCb2R5XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBvc2l0aW9uXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy52ZWxvY2l0eV1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYW5ndWxhclZlbG9jaXR5XVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBbb3B0aW9ucy5xdWF0ZXJuaW9uXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1hc3NdXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBbb3B0aW9ucy5tYXRlcmlhbF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50eXBlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpbmVhckRhbXBpbmc9MC4wMV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hbmd1bGFyRGFtcGluZz0wLjAxXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hbGxvd1NsZWVwPXRydWVdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2xlZXBTcGVlZExpbWl0PTAuMV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zbGVlcFRpbWVMaW1pdD0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwPTFdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaz0xXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5maXhlZFJvdGF0aW9uPWZhbHNlXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5saW5lYXJGYWN0b3JdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmFuZ3VsYXJGYWN0b3JdXG4gKiBAcGFyYW0ge0JvZHl9IFtvcHRpb25zLnNoYXBlXVxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgYm9keSA9IG5ldyBCb2R5KHtcbiAqICAgICAgICAgbWFzczogMVxuICogICAgIH0pO1xuICogICAgIHZhciBzaGFwZSA9IG5ldyBTcGhlcmUoMSk7XG4gKiAgICAgYm9keS5hZGRTaGFwZShzaGFwZSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShib2R5KTtcbiAqL1xuZnVuY3Rpb24gQm9keShvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIEV2ZW50VGFyZ2V0LmFwcGx5KHRoaXMpO1xuXG4gICAgdGhpcy5pZCA9IEJvZHkuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHdvcmxkIHRoZSBib2R5IGlzIGxpdmluZyBpblxuICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxuICAgICAqIEB0eXBlIHtXb3JsZH1cbiAgICAgKi9cbiAgICB0aGlzLndvcmxkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCBCRUZPUkUgc3RlcHBpbmcgdGhlIHN5c3RlbS4gVXNlIGl0IHRvIGFwcGx5IGZvcmNlcywgZm9yIGV4YW1wbGUuIEluc2lkZSB0aGUgZnVuY3Rpb24sIFwidGhpc1wiIHdpbGwgcmVmZXIgdG8gdGhpcyBCb2R5IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkgcHJlU3RlcFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgV29ybGQgZXZlbnRzIGluc3RlYWRcbiAgICAgKi9cbiAgICB0aGlzLnByZVN0ZXAgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIEFGVEVSIHN0ZXBwaW5nIHRoZSBzeXN0ZW0uIEluc2lkZSB0aGUgZnVuY3Rpb24sIFwidGhpc1wiIHdpbGwgcmVmZXIgdG8gdGhpcyBCb2R5IG9iamVjdC5cbiAgICAgKiBAcHJvcGVydHkgcG9zdFN0ZXBcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFdvcmxkIGV2ZW50cyBpbnN0ZWFkXG4gICAgICovXG4gICAgdGhpcy5wb3N0U3RlcCA9IG51bGw7XG5cbiAgICB0aGlzLnZsYW1iZGEgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbGxpc2lvbkZpbHRlckdyb3VwXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IHR5cGVvZihvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwKSA9PT0gJ251bWJlcicgPyBvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwIDogMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJNYXNrXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gdHlwZW9mKG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09ICdudW1iZXInID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrIDogMTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29sbGlzaW9uUmVzcG9uc2VcbiAgICAgKi9cblx0dGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgcG9zaXRpb25cbiAgICAgKiBAdHlwZSB7VmVjM31cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcHJldmlvdXNQb3NpdGlvblxuICAgICAqL1xuICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcnBvbGF0ZWQgcG9zaXRpb24gb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBpbnRlcnBvbGF0ZWRQb3NpdGlvblxuICAgICAqL1xuICAgIHRoaXMuaW50ZXJwb2xhdGVkUG9zaXRpb24gPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgYm9keVxuICAgICAqIEBwcm9wZXJ0eSBpbml0UG9zaXRpb25cbiAgICAgKiBAdHlwZSB7VmVjM31cbiAgICAgKi9cbiAgICB0aGlzLmluaXRQb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG5cbiAgICBpZihvcHRpb25zLnBvc2l0aW9uKXtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KG9wdGlvbnMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24uY29weShvcHRpb25zLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0ZWRQb3NpdGlvbi5jb3B5KG9wdGlvbnMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLmluaXRQb3NpdGlvbi5jb3B5KG9wdGlvbnMucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB2ZWxvY2l0eVxuICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAqL1xuICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYob3B0aW9ucy52ZWxvY2l0eSl7XG4gICAgICAgIHRoaXMudmVsb2NpdHkuY29weShvcHRpb25zLnZlbG9jaXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5pdFZlbG9jaXR5XG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5pbml0VmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogTGluZWFyIGZvcmNlIG9uIHRoZSBib2R5XG4gICAgICogQHByb3BlcnR5IGZvcmNlXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5mb3JjZSA9IG5ldyBWZWMzKCk7XG5cbiAgICB2YXIgbWFzcyA9IHR5cGVvZihvcHRpb25zLm1hc3MpID09PSAnbnVtYmVyJyA/IG9wdGlvbnMubWFzcyA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbWFzc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMubWFzcyA9IG1hc3M7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW52TWFzc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbnZNYXNzID0gbWFzcyA+IDAgPyAxLjAgLyBtYXNzIDogMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbFxuICAgICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGxpbmVhckRhbXBpbmdcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGluZWFyRGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmxpbmVhckRhbXBpbmcpID09PSAnbnVtYmVyJyA/IG9wdGlvbnMubGluZWFyRGFtcGluZyA6IDAuMDE7XG5cbiAgICAvKipcbiAgICAgKiBPbmUgb2Y6IEJvZHkuRFlOQU1JQywgQm9keS5TVEFUSUMgYW5kIEJvZHkuS0lORU1BVElDLlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSAobWFzcyA8PSAwLjAgPyBCb2R5LlNUQVRJQyA6IEJvZHkuRFlOQU1JQyk7XG4gICAgaWYodHlwZW9mKG9wdGlvbnMudHlwZSkgPT09IHR5cGVvZihCb2R5LlNUQVRJQykpe1xuICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGJvZHkgd2lsbCBhdXRvbWF0aWNhbGx5IGZhbGwgdG8gc2xlZXAuXG4gICAgICogQHByb3BlcnR5IGFsbG93U2xlZXBcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5hbGxvd1NsZWVwID0gdHlwZW9mKG9wdGlvbnMuYWxsb3dTbGVlcCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5hbGxvd1NsZWVwIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc2xlZXAgc3RhdGUuXG4gICAgICogQHByb3BlcnR5IHNsZWVwU3RhdGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc3BlZWQgKHRoZSBub3JtIG9mIHRoZSB2ZWxvY2l0eSkgaXMgc21hbGxlciB0aGFuIHRoaXMgdmFsdWUsIHRoZSBib2R5IGlzIGNvbnNpZGVyZWQgc2xlZXB5LlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFNwZWVkTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMVxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBTcGVlZExpbWl0ID0gdHlwZW9mKG9wdGlvbnMuc2xlZXBTcGVlZExpbWl0KSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCA6IDAuMTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVweSBmb3IgdGhpcyBzbGVlcFRpbWVMaW1pdCBzZWNvbmRzLCBpdCBpcyBjb25zaWRlcmVkIHNsZWVwaW5nLlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFRpbWVMaW1pdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBUaW1lTGltaXQgPSB0eXBlb2Yob3B0aW9ucy5zbGVlcFRpbWVMaW1pdCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5zbGVlcFRpbWVMaW1pdCA6IDE7XG5cbiAgICB0aGlzLnRpbWVMYXN0U2xlZXB5ID0gMDtcblxuICAgIHRoaXMuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogUm90YXRpb25hbCBmb3JjZSBvbiB0aGUgYm9keSwgYXJvdW5kIGNlbnRlciBvZiBtYXNzXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSB0b3JxdWVcbiAgICAgKi9cbiAgICB0aGlzLnRvcnF1ZSA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBPcmllbnRhdGlvbiBvZiB0aGUgYm9keVxuICAgICAqIEBwcm9wZXJ0eSBxdWF0ZXJuaW9uXG4gICAgICogQHR5cGUge1F1YXRlcm5pb259XG4gICAgICovXG4gICAgdGhpcy5xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbml0UXVhdGVybmlvblxuICAgICAqIEB0eXBlIHtRdWF0ZXJuaW9ufVxuICAgICAqL1xuICAgIHRoaXMuaW5pdFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtRdWF0ZXJuaW9ufSBwcmV2aW91c1F1YXRlcm5pb25cbiAgICAgKi9cbiAgICB0aGlzLnByZXZpb3VzUXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcnBvbGF0ZWQgb3JpZW50YXRpb24gb2YgdGhlIGJvZHkuXG4gICAgICogQHByb3BlcnR5IHtRdWF0ZXJuaW9ufSBpbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uXG4gICAgICovXG4gICAgdGhpcy5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIGlmKG9wdGlvbnMucXVhdGVybmlvbil7XG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XG4gICAgICAgIHRoaXMuaW5pdFF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pO1xuICAgICAgICB0aGlzLnByZXZpb3VzUXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGVkUXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGFuZ3VsYXJWZWxvY2l0eVxuICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAqL1xuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ID0gbmV3IFZlYzMoKTtcblxuICAgIGlmKG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5KXtcbiAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuY29weShvcHRpb25zLmFuZ3VsYXJWZWxvY2l0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluaXRBbmd1bGFyVmVsb2NpdHlcbiAgICAgKiBAdHlwZSB7VmVjM31cbiAgICAgKi9cbiAgICB0aGlzLmluaXRBbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHNoYXBlc1xuICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHNoYXBlT2Zmc2V0c1xuICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlT2Zmc2V0cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHNoYXBlT3JpZW50YXRpb25zXG4gICAgICogQHR5cGUge2FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVPcmllbnRhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbmVydGlhXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5pbmVydGlhID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gaW52SW5lcnRpYVxuICAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYSA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge01hdDN9IGludkluZXJ0aWFXb3JsZFxuICAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkID0gbmV3IE1hdDMoKTtcblxuICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gaW52SW5lcnRpYVNvbHZlXG4gICAgICovXG4gICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtNYXQzfSBpbnZJbmVydGlhV29ybGRTb2x2ZVxuICAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUgPSBuZXcgTWF0MygpO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IGRvbid0IHdhbnQgdGhlIGJvZHkgdG8gcm90YXRlLiBNYWtlIHN1cmUgdG8gcnVuIC51cGRhdGVNYXNzUHJvcGVydGllcygpIGFmdGVyIGNoYW5naW5nIHRoaXMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBmaXhlZFJvdGF0aW9uXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB0aGlzLmZpeGVkUm90YXRpb24gPSB0eXBlb2Yob3B0aW9ucy5maXhlZFJvdGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMuZml4ZWRSb3RhdGlvbiA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGFuZ3VsYXJEYW1waW5nXG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmFuZ3VsYXJEYW1waW5nKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ3VsYXJEYW1waW5nIDogMC4wMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gbGluZWFyRmFjdG9yXG4gICAgICovXG4gICAgdGhpcy5saW5lYXJGYWN0b3IgPSBuZXcgVmVjMygxLDEsMSk7XG4gICAgaWYob3B0aW9ucy5saW5lYXJGYWN0b3Ipe1xuICAgICAgICB0aGlzLmxpbmVhckZhY3Rvci5jb3B5KG9wdGlvbnMubGluZWFyRmFjdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGFuZ3VsYXJGYWN0b3JcbiAgICAgKi9cbiAgICB0aGlzLmFuZ3VsYXJGYWN0b3IgPSBuZXcgVmVjMygxLDEsMSk7XG4gICAgaWYob3B0aW9ucy5hbmd1bGFyRmFjdG9yKXtcbiAgICAgICAgdGhpcy5hbmd1bGFyRmFjdG9yLmNvcHkob3B0aW9ucy5hbmd1bGFyRmFjdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgYWFiYlxuICAgICAqIEB0eXBlIHtBQUJCfVxuICAgICAqL1xuICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIEFBQkIgbmVlZHMgdG8gYmUgdXBkYXRlZCBiZWZvcmUgdXNlLlxuICAgICAqIEBwcm9wZXJ0eSBhYWJiTmVlZHNVcGRhdGVcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB0aGlzLndsYW1iZGEgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYob3B0aW9ucy5zaGFwZSl7XG4gICAgICAgIHRoaXMuYWRkU2hhcGUob3B0aW9ucy5zaGFwZSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xufVxuQm9keS5wcm90b3R5cGUgPSBuZXcgRXZlbnRUYXJnZXQoKTtcbkJvZHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm9keTtcblxuLyoqXG4gKiBEaXNwYXRjaGVkIGFmdGVyIHR3byBib2RpZXMgY29sbGlkZS4gVGhpcyBldmVudCBpcyBkaXNwYXRjaGVkIG9uIGVhY2hcbiAqIG9mIHRoZSB0d28gYm9kaWVzIGludm9sdmVkIGluIHRoZSBjb2xsaXNpb24uXG4gKiBAZXZlbnQgY29sbGlkZVxuICogQHBhcmFtIHtCb2R5fSBib2R5IFRoZSBib2R5IHRoYXQgd2FzIGludm9sdmVkIGluIHRoZSBjb2xsaXNpb24uXG4gKiBAcGFyYW0ge0NvbnRhY3RFcXVhdGlvbn0gY29udGFjdCBUaGUgZGV0YWlscyBvZiB0aGUgY29sbGlzaW9uLlxuICovXG5Cb2R5LkNPTExJREVfRVZFTlRfTkFNRSA9IFwiY29sbGlkZVwiO1xuXG4vKipcbiAqIEEgZHluYW1pYyBib2R5IGlzIGZ1bGx5IHNpbXVsYXRlZC4gQ2FuIGJlIG1vdmVkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyLCBidXQgbm9ybWFsbHkgdGhleSBtb3ZlIGFjY29yZGluZyB0byBmb3JjZXMuIEEgZHluYW1pYyBib2R5IGNhbiBjb2xsaWRlIHdpdGggYWxsIGJvZHkgdHlwZXMuIEEgZHluYW1pYyBib2R5IGFsd2F5cyBoYXMgZmluaXRlLCBub24temVybyBtYXNzLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IERZTkFNSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbkJvZHkuRFlOQU1JQyA9IDE7XG5cbi8qKlxuICogQSBzdGF0aWMgYm9keSBkb2VzIG5vdCBtb3ZlIGR1cmluZyBzaW11bGF0aW9uIGFuZCBiZWhhdmVzIGFzIGlmIGl0IGhhcyBpbmZpbml0ZSBtYXNzLiBTdGF0aWMgYm9kaWVzIGNhbiBiZSBtb3ZlZCBtYW51YWxseSBieSBzZXR0aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keS4gVGhlIHZlbG9jaXR5IG9mIGEgc3RhdGljIGJvZHkgaXMgYWx3YXlzIHplcm8uIFN0YXRpYyBib2RpZXMgZG8gbm90IGNvbGxpZGUgd2l0aCBvdGhlciBzdGF0aWMgb3Iga2luZW1hdGljIGJvZGllcy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSBTVEFUSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbkJvZHkuU1RBVElDID0gMjtcblxuLyoqXG4gKiBBIGtpbmVtYXRpYyBib2R5IG1vdmVzIHVuZGVyIHNpbXVsYXRpb24gYWNjb3JkaW5nIHRvIGl0cyB2ZWxvY2l0eS4gVGhleSBkbyBub3QgcmVzcG9uZCB0byBmb3JjZXMuIFRoZXkgY2FuIGJlIG1vdmVkIG1hbnVhbGx5LCBidXQgbm9ybWFsbHkgYSBraW5lbWF0aWMgYm9keSBpcyBtb3ZlZCBieSBzZXR0aW5nIGl0cyB2ZWxvY2l0eS4gQSBraW5lbWF0aWMgYm9keSBiZWhhdmVzIGFzIGlmIGl0IGhhcyBpbmZpbml0ZSBtYXNzLiBLaW5lbWF0aWMgYm9kaWVzIGRvIG5vdCBjb2xsaWRlIHdpdGggb3RoZXIgc3RhdGljIG9yIGtpbmVtYXRpYyBib2RpZXMuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkgS0lORU1BVElDXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5Cb2R5LktJTkVNQVRJQyA9IDQ7XG5cblxuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSBBV0FLRVxuICogQHR5cGUge251bWJlcn1cbiAqL1xuQm9keS5BV0FLRSA9IDA7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IFNMRUVQWVxuICogQHR5cGUge251bWJlcn1cbiAqL1xuQm9keS5TTEVFUFkgPSAxO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSBTTEVFUElOR1xuICogQHR5cGUge251bWJlcn1cbiAqL1xuQm9keS5TTEVFUElORyA9IDI7XG5cbkJvZHkuaWRDb3VudGVyID0gMDtcblxuLyoqXG4gKiBEaXNwYXRjaGVkIGFmdGVyIGEgc2xlZXBpbmcgYm9keSBoYXMgd29rZW4gdXAuXG4gKiBAZXZlbnQgd2FrZXVwXG4gKi9cbkJvZHkud2FrZXVwRXZlbnQgPSB7XG4gICAgdHlwZTogXCJ3YWtldXBcIlxufTtcblxuLyoqXG4gKiBXYWtlIHRoZSBib2R5IHVwLlxuICogQG1ldGhvZCB3YWtlVXBcbiAqL1xuQm9keS5wcm90b3R5cGUud2FrZVVwID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcyA9IHRoaXMuc2xlZXBTdGF0ZTtcbiAgICB0aGlzLnNsZWVwU3RhdGUgPSAwO1xuICAgIGlmKHMgPT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoQm9keS53YWtldXBFdmVudCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBGb3JjZSBib2R5IHNsZWVwXG4gKiBAbWV0aG9kIHNsZWVwXG4gKi9cbkJvZHkucHJvdG90eXBlLnNsZWVwID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQSU5HO1xuICAgIHRoaXMudmVsb2NpdHkuc2V0KDAsMCwwKTtcbiAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5zZXQoMCwwLDApO1xufTtcblxuLyoqXG4gKiBEaXNwYXRjaGVkIGFmdGVyIGEgYm9keSBoYXMgZ29uZSBpbiB0byB0aGUgc2xlZXB5IHN0YXRlLlxuICogQGV2ZW50IHNsZWVweVxuICovXG5Cb2R5LnNsZWVweUV2ZW50ID0ge1xuICAgIHR5cGU6IFwic2xlZXB5XCJcbn07XG5cbi8qKlxuICogRGlzcGF0Y2hlZCBhZnRlciBhIGJvZHkgaGFzIGZhbGxlbiBhc2xlZXAuXG4gKiBAZXZlbnQgc2xlZXBcbiAqL1xuQm9keS5zbGVlcEV2ZW50ID0ge1xuICAgIHR5cGU6IFwic2xlZXBcIlxufTtcblxuLyoqXG4gKiBDYWxsZWQgZXZlcnkgdGltZXN0ZXAgdG8gdXBkYXRlIGludGVybmFsIHNsZWVwIHRpbWVyIGFuZCBjaGFuZ2Ugc2xlZXAgc3RhdGUgaWYgbmVlZGVkLlxuICogQG1ldGhvZCBzbGVlcFRpY2tcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSB3b3JsZCB0aW1lIGluIHNlY29uZHNcbiAqL1xuQm9keS5wcm90b3R5cGUuc2xlZXBUaWNrID0gZnVuY3Rpb24odGltZSl7XG4gICAgaWYodGhpcy5hbGxvd1NsZWVwKXtcbiAgICAgICAgdmFyIHNsZWVwU3RhdGUgPSB0aGlzLnNsZWVwU3RhdGU7XG4gICAgICAgIHZhciBzcGVlZFNxdWFyZWQgPSB0aGlzLnZlbG9jaXR5Lm5vcm0yKCkgKyB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5ub3JtMigpO1xuICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnNsZWVwU3BlZWRMaW1pdCwyKTtcbiAgICAgICAgaWYoc2xlZXBTdGF0ZT09PUJvZHkuQVdBS0UgJiYgc3BlZWRTcXVhcmVkIDwgc3BlZWRMaW1pdFNxdWFyZWQpe1xuICAgICAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUFk7IC8vIFNsZWVweVxuICAgICAgICAgICAgdGhpcy50aW1lTGFzdFNsZWVweSA9IHRpbWU7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoQm9keS5zbGVlcHlFdmVudCk7XG4gICAgICAgIH0gZWxzZSBpZihzbGVlcFN0YXRlPT09Qm9keS5TTEVFUFkgJiYgc3BlZWRTcXVhcmVkID4gc3BlZWRMaW1pdFNxdWFyZWQpe1xuICAgICAgICAgICAgdGhpcy53YWtlVXAoKTsgLy8gV2FrZSB1cFxuICAgICAgICB9IGVsc2UgaWYoc2xlZXBTdGF0ZT09PUJvZHkuU0xFRVBZICYmICh0aW1lIC0gdGhpcy50aW1lTGFzdFNsZWVweSApID4gdGhpcy5zbGVlcFRpbWVMaW1pdCl7XG4gICAgICAgICAgICB0aGlzLnNsZWVwKCk7IC8vIFNsZWVwaW5nXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoQm9keS5zbGVlcEV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogSWYgdGhlIGJvZHkgaXMgc2xlZXBpbmcsIGl0IHNob3VsZCBiZSBpbW1vdmFibGUgLyBoYXZlIGluZmluaXRlIG1hc3MgZHVyaW5nIHNvbHZlLiBXZSBzb2x2ZSBpdCBieSBoYXZpbmcgYSBzZXBhcmF0ZSBcInNvbHZlIG1hc3NcIi5cbiAqIEBtZXRob2QgdXBkYXRlU29sdmVNYXNzUHJvcGVydGllc1xuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG4gICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUuc2V0WmVybygpO1xuICAgICAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlLnNldFplcm8oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IHRoaXMuaW52TWFzcztcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUuY29weSh0aGlzLmludkluZXJ0aWEpO1xuICAgICAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlLmNvcHkodGhpcy5pbnZJbmVydGlhV29ybGQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhIHdvcmxkIHBvaW50IHRvIGxvY2FsIGJvZHkgZnJhbWUuXG4gKiBAbWV0aG9kIHBvaW50VG9Mb2NhbEZyYW1lXG4gKiBAcGFyYW0gIHtWZWMzfSB3b3JsZFBvaW50XG4gKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cbkJvZHkucHJvdG90eXBlLnBvaW50VG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24od29ybGRQb2ludCxyZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcbiAgICB3b3JsZFBvaW50LnZzdWIodGhpcy5wb3NpdGlvbixyZXN1bHQpO1xuICAgIHRoaXMucXVhdGVybmlvbi5jb25qdWdhdGUoKS52bXVsdChyZXN1bHQscmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgd29ybGQgdmVjdG9yIHRvIGxvY2FsIGJvZHkgZnJhbWUuXG4gKiBAbWV0aG9kIHZlY3RvclRvTG9jYWxGcmFtZVxuICogQHBhcmFtICB7VmVjM30gd29ybGRQb2ludFxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5Cb2R5LnByb3RvdHlwZS52ZWN0b3JUb0xvY2FsRnJhbWUgPSBmdW5jdGlvbih3b3JsZFZlY3RvciwgcmVzdWx0KXtcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLmNvbmp1Z2F0ZSgpLnZtdWx0KHdvcmxkVmVjdG9yLHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIGxvY2FsIGJvZHkgcG9pbnQgdG8gd29ybGQgZnJhbWUuXG4gKiBAbWV0aG9kIHBvaW50VG9Xb3JsZEZyYW1lXG4gKiBAcGFyYW0gIHtWZWMzfSBsb2NhbFBvaW50XG4gKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cbkJvZHkucHJvdG90eXBlLnBvaW50VG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24obG9jYWxQb2ludCxyZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcbiAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxQb2ludCxyZXN1bHQpO1xuICAgIHJlc3VsdC52YWRkKHRoaXMucG9zaXRpb24scmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgbG9jYWwgYm9keSBwb2ludCB0byB3b3JsZCBmcmFtZS5cbiAqIEBtZXRob2QgdmVjdG9yVG9Xb3JsZEZyYW1lXG4gKiBAcGFyYW0gIHtWZWMzfSBsb2NhbFZlY3RvclxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5Cb2R5LnByb3RvdHlwZS52ZWN0b3JUb1dvcmxkRnJhbWUgPSBmdW5jdGlvbihsb2NhbFZlY3RvciwgcmVzdWx0KXtcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLnZtdWx0KGxvY2FsVmVjdG9yLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgdG1wVmVjID0gbmV3IFZlYzMoKTtcbnZhciB0bXBRdWF0ID0gbmV3IFF1YXRlcm5pb24oKTtcblxuLyoqXG4gKiBBZGQgYSBzaGFwZSB0byB0aGUgYm9keSB3aXRoIGEgbG9jYWwgb2Zmc2V0IGFuZCBvcmllbnRhdGlvbi5cbiAqIEBtZXRob2QgYWRkU2hhcGVcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0ge1ZlYzN9IFtfb2Zmc2V0XVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBbX29yaWVudGF0aW9uXVxuICogQHJldHVybiB7Qm9keX0gVGhlIGJvZHkgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICovXG5Cb2R5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlLCBfb2Zmc2V0LCBfb3JpZW50YXRpb24pe1xuICAgIHZhciBvZmZzZXQgPSBuZXcgVmVjMygpO1xuICAgIHZhciBvcmllbnRhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICBpZihfb2Zmc2V0KXtcbiAgICAgICAgb2Zmc2V0LmNvcHkoX29mZnNldCk7XG4gICAgfVxuICAgIGlmKF9vcmllbnRhdGlvbil7XG4gICAgICAgIG9yaWVudGF0aW9uLmNvcHkoX29yaWVudGF0aW9uKTtcbiAgICB9XG5cbiAgICB0aGlzLnNoYXBlcy5wdXNoKHNoYXBlKTtcbiAgICB0aGlzLnNoYXBlT2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgdGhpcy5zaGFwZU9yaWVudGF0aW9ucy5wdXNoKG9yaWVudGF0aW9uKTtcbiAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgcmFkaXVzIG9mIHRoZSBib2R5LiBTaG91bGQgYmUgZG9uZSBpZiBhbnkgb2YgdGhlIHNoYXBlcyBhcmUgY2hhbmdlZC5cbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcbiAgICAgICAgc2hhcGVPZmZzZXRzID0gdGhpcy5zaGFwZU9mZnNldHMsXG4gICAgICAgIE4gPSBzaGFwZXMubGVuZ3RoLFxuICAgICAgICByYWRpdXMgPSAwO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV07XG4gICAgICAgIHNoYXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBzaGFwZU9mZnNldHNbaV0ubm9ybSgpLFxuICAgICAgICAgICAgciA9IHNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzO1xuICAgICAgICBpZihvZmZzZXQgKyByID4gcmFkaXVzKXtcbiAgICAgICAgICAgIHJhZGl1cyA9IG9mZnNldCArIHI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmJvdW5kaW5nUmFkaXVzID0gcmFkaXVzO1xufTtcblxudmFyIGNvbXB1dGVBQUJCX3NoYXBlQUFCQiA9IG5ldyBBQUJCKCk7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgLmFhYmJcbiAqIEBtZXRob2QgY29tcHV0ZUFBQkJcbiAqIEB0b2RvIHJlbmFtZSB0byB1cGRhdGVBQUJCKClcbiAqL1xuQm9keS5wcm90b3R5cGUuY29tcHV0ZUFBQkIgPSBmdW5jdGlvbigpe1xuICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcbiAgICAgICAgc2hhcGVPZmZzZXRzID0gdGhpcy5zaGFwZU9mZnNldHMsXG4gICAgICAgIHNoYXBlT3JpZW50YXRpb25zID0gdGhpcy5zaGFwZU9yaWVudGF0aW9ucyxcbiAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgIG9mZnNldCA9IHRtcFZlYyxcbiAgICAgICAgb3JpZW50YXRpb24gPSB0bXBRdWF0LFxuICAgICAgICBib2R5UXVhdCA9IHRoaXMucXVhdGVybmlvbixcbiAgICAgICAgYWFiYiA9IHRoaXMuYWFiYixcbiAgICAgICAgc2hhcGVBQUJCID0gY29tcHV0ZUFBQkJfc2hhcGVBQUJCO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV07XG5cbiAgICAgICAgLy8gR2V0IHNoYXBlIHdvcmxkIHBvc2l0aW9uXG4gICAgICAgIGJvZHlRdWF0LnZtdWx0KHNoYXBlT2Zmc2V0c1tpXSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0LnZhZGQodGhpcy5wb3NpdGlvbiwgb2Zmc2V0KTtcblxuICAgICAgICAvLyBHZXQgc2hhcGUgd29ybGQgcXVhdGVybmlvblxuICAgICAgICBzaGFwZU9yaWVudGF0aW9uc1tpXS5tdWx0KGJvZHlRdWF0LCBvcmllbnRhdGlvbik7XG5cbiAgICAgICAgLy8gR2V0IHNoYXBlIEFBQkJcbiAgICAgICAgc2hhcGUuY2FsY3VsYXRlV29ybGRBQUJCKG9mZnNldCwgb3JpZW50YXRpb24sIHNoYXBlQUFCQi5sb3dlckJvdW5kLCBzaGFwZUFBQkIudXBwZXJCb3VuZCk7XG5cbiAgICAgICAgaWYoaSA9PT0gMCl7XG4gICAgICAgICAgICBhYWJiLmNvcHkoc2hhcGVBQUJCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFhYmIuZXh0ZW5kKHNoYXBlQUFCQik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IGZhbHNlO1xufTtcblxudmFyIHVpd19tMSA9IG5ldyBNYXQzKCksXG4gICAgdWl3X20yID0gbmV3IE1hdDMoKSxcbiAgICB1aXdfbTMgPSBuZXcgTWF0MygpO1xuXG4vKipcbiAqIFVwZGF0ZSAuaW5lcnRpYVdvcmxkIGFuZCAuaW52SW5lcnRpYVdvcmxkXG4gKiBAbWV0aG9kIHVwZGF0ZUluZXJ0aWFXb3JsZFxuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVJbmVydGlhV29ybGQgPSBmdW5jdGlvbihmb3JjZSl7XG4gICAgdmFyIEkgPSB0aGlzLmludkluZXJ0aWE7XG4gICAgaWYgKEkueCA9PT0gSS55ICYmIEkueSA9PT0gSS56ICYmICFmb3JjZSkge1xuICAgICAgICAvLyBJZiBpbmVydGlhIE0gPSBzKkksIHdoZXJlIEkgaXMgaWRlbnRpdHkgYW5kIHMgYSBzY2FsYXIsIHRoZW5cbiAgICAgICAgLy8gICAgUipNKlInID0gUioocypJKSpSJyA9IHMqUipJKlInID0gcypSKlInID0gcypJID0gTVxuICAgICAgICAvLyB3aGVyZSBSIGlzIHRoZSByb3RhdGlvbiBtYXRyaXguXG4gICAgICAgIC8vIEluIG90aGVyIHdvcmRzLCB3ZSBkb24ndCBoYXZlIHRvIHRyYW5zZm9ybSB0aGUgaW5lcnRpYSBpZiBhbGxcbiAgICAgICAgLy8gaW5lcnRpYSBkaWFnb25hbCBlbnRyaWVzIGFyZSBlcXVhbC5cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbTEgPSB1aXdfbTEsXG4gICAgICAgICAgICBtMiA9IHVpd19tMixcbiAgICAgICAgICAgIG0zID0gdWl3X20zO1xuICAgICAgICBtMS5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgICAgIG0xLnRyYW5zcG9zZShtMik7XG4gICAgICAgIG0xLnNjYWxlKEksbTEpO1xuICAgICAgICBtMS5tbXVsdChtMix0aGlzLmludkluZXJ0aWFXb3JsZCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBcHBseSBmb3JjZSB0byBhIHdvcmxkIHBvaW50LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4gQXBwbHlpbmcgZm9yY2UgdGhpcyB3YXkgd2lsbCBhZGQgdG8gQm9keS5mb3JjZSBhbmQgQm9keS50b3JxdWUuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqIEBwYXJhbSAge1ZlYzN9IGZvcmNlIFRoZSBhbW91bnQgb2YgZm9yY2UgdG8gYWRkLlxuICogQHBhcmFtICB7VmVjM30gcmVsYXRpdmVQb2ludCBBIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyB0byBhcHBseSB0aGUgZm9yY2Ugb24uXG4gKi9cbnZhciBCb2R5X2FwcGx5Rm9yY2VfciA9IG5ldyBWZWMzKCk7XG52YXIgQm9keV9hcHBseUZvcmNlX3JvdEZvcmNlID0gbmV3IFZlYzMoKTtcbkJvZHkucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbihmb3JjZSxyZWxhdGl2ZVBvaW50KXtcbiAgICBpZih0aGlzLnR5cGUgIT09IEJvZHkuRFlOQU1JQyl7IC8vIE5lZWRlZD9cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgcHJvZHVjZWQgcm90YXRpb25hbCBmb3JjZVxuICAgIHZhciByb3RGb3JjZSA9IEJvZHlfYXBwbHlGb3JjZV9yb3RGb3JjZTtcbiAgICByZWxhdGl2ZVBvaW50LmNyb3NzKGZvcmNlLHJvdEZvcmNlKTtcblxuICAgIC8vIEFkZCBsaW5lYXIgZm9yY2VcbiAgICB0aGlzLmZvcmNlLnZhZGQoZm9yY2UsdGhpcy5mb3JjZSk7XG5cbiAgICAvLyBBZGQgcm90YXRpb25hbCBmb3JjZVxuICAgIHRoaXMudG9ycXVlLnZhZGQocm90Rm9yY2UsdGhpcy50b3JxdWUpO1xufTtcblxuLyoqXG4gKiBBcHBseSBmb3JjZSB0byBhIGxvY2FsIHBvaW50IGluIHRoZSBib2R5LlxuICogQG1ldGhvZCBhcHBseUxvY2FsRm9yY2VcbiAqIEBwYXJhbSAge1ZlYzN9IGZvcmNlIFRoZSBmb3JjZSB2ZWN0b3IgdG8gYXBwbHksIGRlZmluZWQgbG9jYWxseSBpbiB0aGUgYm9keSBmcmFtZS5cbiAqIEBwYXJhbSAge1ZlYzN9IGxvY2FsUG9pbnQgQSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keSB0byBhcHBseSB0aGUgZm9yY2Ugb24uXG4gKi9cbnZhciBCb2R5X2FwcGx5TG9jYWxGb3JjZV93b3JsZEZvcmNlID0gbmV3IFZlYzMoKTtcbnZhciBCb2R5X2FwcGx5TG9jYWxGb3JjZV9yZWxhdGl2ZVBvaW50V29ybGQgPSBuZXcgVmVjMygpO1xuQm9keS5wcm90b3R5cGUuYXBwbHlMb2NhbEZvcmNlID0gZnVuY3Rpb24obG9jYWxGb3JjZSwgbG9jYWxQb2ludCl7XG4gICAgaWYodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdvcmxkRm9yY2UgPSBCb2R5X2FwcGx5TG9jYWxGb3JjZV93b3JsZEZvcmNlO1xuICAgIHZhciByZWxhdGl2ZVBvaW50V29ybGQgPSBCb2R5X2FwcGx5TG9jYWxGb3JjZV9yZWxhdGl2ZVBvaW50V29ybGQ7XG5cbiAgICAvLyBUcmFuc2Zvcm0gdGhlIGZvcmNlIHZlY3RvciB0byB3b3JsZCBzcGFjZVxuICAgIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKGxvY2FsRm9yY2UsIHdvcmxkRm9yY2UpO1xuICAgIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKGxvY2FsUG9pbnQsIHJlbGF0aXZlUG9pbnRXb3JsZCk7XG5cbiAgICB0aGlzLmFwcGx5Rm9yY2Uod29ybGRGb3JjZSwgcmVsYXRpdmVQb2ludFdvcmxkKTtcbn07XG5cbi8qKlxuICogQXBwbHkgaW1wdWxzZSB0byBhIHdvcmxkIHBvaW50LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4gQW4gaW1wdWxzZSBpcyBhIGZvcmNlIGFkZGVkIHRvIGEgYm9keSBkdXJpbmcgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSAoaW1wdWxzZSA9IGZvcmNlICogdGltZSkuIEltcHVsc2VzIHdpbGwgYmUgYWRkZWQgdG8gQm9keS52ZWxvY2l0eSBhbmQgQm9keS5hbmd1bGFyVmVsb2NpdHkuXG4gKiBAbWV0aG9kIGFwcGx5SW1wdWxzZVxuICogQHBhcmFtICB7VmVjM30gaW1wdWxzZSBUaGUgYW1vdW50IG9mIGltcHVsc2UgdG8gYWRkLlxuICogQHBhcmFtICB7VmVjM30gcmVsYXRpdmVQb2ludCBBIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgbWFzcyB0byBhcHBseSB0aGUgZm9yY2Ugb24uXG4gKi9cbnZhciBCb2R5X2FwcGx5SW1wdWxzZV9yID0gbmV3IFZlYzMoKTtcbnZhciBCb2R5X2FwcGx5SW1wdWxzZV92ZWxvID0gbmV3IFZlYzMoKTtcbnZhciBCb2R5X2FwcGx5SW1wdWxzZV9yb3RWZWxvID0gbmV3IFZlYzMoKTtcbkJvZHkucHJvdG90eXBlLmFwcGx5SW1wdWxzZSA9IGZ1bmN0aW9uKGltcHVsc2UsIHJlbGF0aXZlUG9pbnQpe1xuICAgIGlmKHRoaXMudHlwZSAhPT0gQm9keS5EWU5BTUlDKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgcG9pbnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJvZHkgY2VudGVyXG4gICAgdmFyIHIgPSByZWxhdGl2ZVBvaW50O1xuXG4gICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCBjZW50cmFsIGltcHVsc2UgdmVsb2NpdHlcbiAgICB2YXIgdmVsbyA9IEJvZHlfYXBwbHlJbXB1bHNlX3ZlbG87XG4gICAgdmVsby5jb3B5KGltcHVsc2UpO1xuICAgIHZlbG8ubXVsdCh0aGlzLmludk1hc3MsdmVsbyk7XG5cbiAgICAvLyBBZGQgbGluZWFyIGltcHVsc2VcbiAgICB0aGlzLnZlbG9jaXR5LnZhZGQodmVsbywgdGhpcy52ZWxvY2l0eSk7XG5cbiAgICAvLyBDb21wdXRlIHByb2R1Y2VkIHJvdGF0aW9uYWwgaW1wdWxzZSB2ZWxvY2l0eVxuICAgIHZhciByb3RWZWxvID0gQm9keV9hcHBseUltcHVsc2Vfcm90VmVsbztcbiAgICByLmNyb3NzKGltcHVsc2Uscm90VmVsbyk7XG5cbiAgICAvKlxuICAgIHJvdFZlbG8ueCAqPSB0aGlzLmludkluZXJ0aWEueDtcbiAgICByb3RWZWxvLnkgKj0gdGhpcy5pbnZJbmVydGlhLnk7XG4gICAgcm90VmVsby56ICo9IHRoaXMuaW52SW5lcnRpYS56O1xuICAgICovXG4gICAgdGhpcy5pbnZJbmVydGlhV29ybGQudm11bHQocm90VmVsbyxyb3RWZWxvKTtcblxuICAgIC8vIEFkZCByb3RhdGlvbmFsIEltcHVsc2VcbiAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eS52YWRkKHJvdFZlbG8sIHRoaXMuYW5ndWxhclZlbG9jaXR5KTtcbn07XG5cbi8qKlxuICogQXBwbHkgbG9jYWxseS1kZWZpbmVkIGltcHVsc2UgdG8gYSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keS5cbiAqIEBtZXRob2QgYXBwbHlMb2NhbEltcHVsc2VcbiAqIEBwYXJhbSAge1ZlYzN9IGZvcmNlIFRoZSBmb3JjZSB2ZWN0b3IgdG8gYXBwbHksIGRlZmluZWQgbG9jYWxseSBpbiB0aGUgYm9keSBmcmFtZS5cbiAqIEBwYXJhbSAge1ZlYzN9IGxvY2FsUG9pbnQgQSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keSB0byBhcHBseSB0aGUgZm9yY2Ugb24uXG4gKi9cbnZhciBCb2R5X2FwcGx5TG9jYWxJbXB1bHNlX3dvcmxkSW1wdWxzZSA9IG5ldyBWZWMzKCk7XG52YXIgQm9keV9hcHBseUxvY2FsSW1wdWxzZV9yZWxhdGl2ZVBvaW50ID0gbmV3IFZlYzMoKTtcbkJvZHkucHJvdG90eXBlLmFwcGx5TG9jYWxJbXB1bHNlID0gZnVuY3Rpb24obG9jYWxJbXB1bHNlLCBsb2NhbFBvaW50KXtcbiAgICBpZih0aGlzLnR5cGUgIT09IEJvZHkuRFlOQU1JQyl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd29ybGRJbXB1bHNlID0gQm9keV9hcHBseUxvY2FsSW1wdWxzZV93b3JsZEltcHVsc2U7XG4gICAgdmFyIHJlbGF0aXZlUG9pbnRXb3JsZCA9IEJvZHlfYXBwbHlMb2NhbEltcHVsc2VfcmVsYXRpdmVQb2ludDtcblxuICAgIC8vIFRyYW5zZm9ybSB0aGUgZm9yY2UgdmVjdG9yIHRvIHdvcmxkIHNwYWNlXG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxJbXB1bHNlLCB3b3JsZEltcHVsc2UpO1xuICAgIHRoaXMudmVjdG9yVG9Xb3JsZEZyYW1lKGxvY2FsUG9pbnQsIHJlbGF0aXZlUG9pbnRXb3JsZCk7XG5cbiAgICB0aGlzLmFwcGx5SW1wdWxzZSh3b3JsZEltcHVsc2UsIHJlbGF0aXZlUG9pbnRXb3JsZCk7XG59O1xuXG52YXIgQm9keV91cGRhdGVNYXNzUHJvcGVydGllc19oYWxmRXh0ZW50cyA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB3aGVuZXZlciB5b3UgY2hhbmdlIHRoZSBib2R5IHNoYXBlIG9yIG1hc3MuXG4gKiBAbWV0aG9kIHVwZGF0ZU1hc3NQcm9wZXJ0aWVzXG4gKi9cbkJvZHkucHJvdG90eXBlLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgaGFsZkV4dGVudHMgPSBCb2R5X3VwZGF0ZU1hc3NQcm9wZXJ0aWVzX2hhbGZFeHRlbnRzO1xuXG4gICAgdGhpcy5pbnZNYXNzID0gdGhpcy5tYXNzID4gMCA/IDEuMCAvIHRoaXMubWFzcyA6IDA7XG4gICAgdmFyIEkgPSB0aGlzLmluZXJ0aWE7XG4gICAgdmFyIGZpeGVkID0gdGhpcy5maXhlZFJvdGF0aW9uO1xuXG4gICAgLy8gQXBwcm94aW1hdGUgd2l0aCBBQUJCIGJveFxuICAgIHRoaXMuY29tcHV0ZUFBQkIoKTtcbiAgICBoYWxmRXh0ZW50cy5zZXQoXG4gICAgICAgICh0aGlzLmFhYmIudXBwZXJCb3VuZC54LXRoaXMuYWFiYi5sb3dlckJvdW5kLngpIC8gMixcbiAgICAgICAgKHRoaXMuYWFiYi51cHBlckJvdW5kLnktdGhpcy5hYWJiLmxvd2VyQm91bmQueSkgLyAyLFxuICAgICAgICAodGhpcy5hYWJiLnVwcGVyQm91bmQuei10aGlzLmFhYmIubG93ZXJCb3VuZC56KSAvIDJcbiAgICApO1xuICAgIEJveC5jYWxjdWxhdGVJbmVydGlhKGhhbGZFeHRlbnRzLCB0aGlzLm1hc3MsIEkpO1xuXG4gICAgdGhpcy5pbnZJbmVydGlhLnNldChcbiAgICAgICAgSS54ID4gMCAmJiAhZml4ZWQgPyAxLjAgLyBJLnggOiAwLFxuICAgICAgICBJLnkgPiAwICYmICFmaXhlZCA/IDEuMCAvIEkueSA6IDAsXG4gICAgICAgIEkueiA+IDAgJiYgIWZpeGVkID8gMS4wIC8gSS56IDogMFxuICAgICk7XG4gICAgdGhpcy51cGRhdGVJbmVydGlhV29ybGQodHJ1ZSk7XG59O1xuXG4vKipcbiAqIEdldCB3b3JsZCB2ZWxvY2l0eSBvZiBhIHBvaW50IGluIHRoZSBib2R5LlxuICogQG1ldGhvZCBnZXRWZWxvY2l0eUF0V29ybGRQb2ludFxuICogQHBhcmFtICB7VmVjM30gd29ybGRQb2ludFxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgcmVzdWx0IHZlY3Rvci5cbiAqL1xuQm9keS5wcm90b3R5cGUuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQgPSBmdW5jdGlvbih3b3JsZFBvaW50LCByZXN1bHQpe1xuICAgIHZhciByID0gbmV3IFZlYzMoKTtcbiAgICB3b3JsZFBvaW50LnZzdWIodGhpcy5wb3NpdGlvbiwgcik7XG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuY3Jvc3MociwgcmVzdWx0KTtcbiAgICB0aGlzLnZlbG9jaXR5LnZhZGQocmVzdWx0LCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgdG9ycXVlID0gbmV3IFZlYzMoKTtcbnZhciBpbnZJX3RhdV9kdCA9IG5ldyBWZWMzKCk7XG52YXIgdyA9IG5ldyBRdWF0ZXJuaW9uKCk7XG52YXIgd3EgPSBuZXcgUXVhdGVybmlvbigpO1xuXG4vKipcbiAqIE1vdmUgdGhlIGJvZHkgZm9yd2FyZCBpbiB0aW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IGR0IFRpbWUgc3RlcFxuICogQHBhcmFtIHtib29sZWFufSBxdWF0Tm9ybWFsaXplIFNldCB0byB0cnVlIHRvIG5vcm1hbGl6ZSB0aGUgYm9keSBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHF1YXROb3JtYWxpemVGYXN0IElmIHRoZSBxdWF0ZXJuaW9uIHNob3VsZCBiZSBub3JtYWxpemVkIHVzaW5nIFwiZmFzdFwiIHF1YXRlcm5pb24gbm9ybWFsaXphdGlvblxuICovXG5Cb2R5LnByb3RvdHlwZS5pbnRlZ3JhdGUgPSBmdW5jdGlvbihkdCwgcXVhdE5vcm1hbGl6ZSwgcXVhdE5vcm1hbGl6ZUZhc3Qpe1xuXG4gICAgLy8gU2F2ZSBwcmV2aW91cyBwb3NpdGlvblxuICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbi5jb3B5KHRoaXMucG9zaXRpb24pO1xuICAgIHRoaXMucHJldmlvdXNRdWF0ZXJuaW9uLmNvcHkodGhpcy5xdWF0ZXJuaW9uKTtcblxuICAgIGlmKCEodGhpcy50eXBlID09PSBCb2R5LkRZTkFNSUMgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQykgfHwgdGhpcy5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HKXsgLy8gT25seSBmb3IgZHluYW1pY1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZlbG8gPSB0aGlzLnZlbG9jaXR5LFxuICAgICAgICBhbmd1bGFyVmVsbyA9IHRoaXMuYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICBwb3MgPSB0aGlzLnBvc2l0aW9uLFxuICAgICAgICBmb3JjZSA9IHRoaXMuZm9yY2UsXG4gICAgICAgIHRvcnF1ZSA9IHRoaXMudG9ycXVlLFxuICAgICAgICBxdWF0ID0gdGhpcy5xdWF0ZXJuaW9uLFxuICAgICAgICBpbnZNYXNzID0gdGhpcy5pbnZNYXNzLFxuICAgICAgICBpbnZJbmVydGlhID0gdGhpcy5pbnZJbmVydGlhV29ybGQsXG4gICAgICAgIGxpbmVhckZhY3RvciA9IHRoaXMubGluZWFyRmFjdG9yO1xuXG4gICAgdmVsby54ICs9IGZvcmNlLnggKiBpbnZNYXNzICogZHQgKiBsaW5lYXJGYWN0b3IueDtcbiAgICB2ZWxvLnkgKz0gZm9yY2UueSAqIGludk1hc3MgKiBkdCAqIGxpbmVhckZhY3Rvci55O1xuICAgIHZlbG8ueiArPSBmb3JjZS56ICogaW52TWFzcyAqIGR0ICogbGluZWFyRmFjdG9yLno7XG5cbiAgICB2YXIgZSA9IGludkluZXJ0aWEuZWxlbWVudHM7XG4gICAgYW5ndWxhclZlbG8ueCArPSBkdCAqIChlWzBdICogdG9ycXVlLnggKyBlWzFdICogdG9ycXVlLnkgKyBlWzJdICogdG9ycXVlLnopO1xuICAgIGFuZ3VsYXJWZWxvLnkgKz0gZHQgKiAoZVszXSAqIHRvcnF1ZS54ICsgZVs0XSAqIHRvcnF1ZS55ICsgZVs1XSAqIHRvcnF1ZS56KTtcbiAgICBhbmd1bGFyVmVsby56ICs9IGR0ICogKGVbNl0gKiB0b3JxdWUueCArIGVbN10gKiB0b3JxdWUueSArIGVbOF0gKiB0b3JxdWUueik7XG5cbiAgICAvLyBVc2UgbmV3IHZlbG9jaXR5ICAtIGxlYXAgZnJvZ1xuICAgIHBvcy54ICs9IHZlbG8ueCAqIGR0O1xuICAgIHBvcy55ICs9IHZlbG8ueSAqIGR0O1xuICAgIHBvcy56ICs9IHZlbG8ueiAqIGR0O1xuXG4gICAgcXVhdC5pbnRlZ3JhdGUodGhpcy5hbmd1bGFyVmVsb2NpdHksIGR0LCB0aGlzLmFuZ3VsYXJGYWN0b3IsIHF1YXQpO1xuXG4gICAgaWYocXVhdE5vcm1hbGl6ZSl7XG4gICAgICAgIGlmKHF1YXROb3JtYWxpemVGYXN0KXtcbiAgICAgICAgICAgIHF1YXQubm9ybWFsaXplRmFzdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXVhdC5ub3JtYWxpemUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIC8vIFVwZGF0ZSB3b3JsZCBpbmVydGlhXG4gICAgdGhpcy51cGRhdGVJbmVydGlhV29ybGQoKTtcbn07IiwidmFyIEJvZHkgPSByZXF1aXJlKCcuL0JvZHknKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFJheWNhc3RSZXN1bHQgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xudmFyIFJheSA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9SYXknKTtcbnZhciBXaGVlbEluZm8gPSByZXF1aXJlKCcuLi9vYmplY3RzL1doZWVsSW5mbycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJheWNhc3RWZWhpY2xlO1xuXG4vKipcbiAqIFZlaGljbGUgaGVscGVyIGNsYXNzIHRoYXQgY2FzdHMgcmF5cyBmcm9tIHRoZSB3aGVlbCBwb3NpdGlvbnMgdG93YXJkcyB0aGUgZ3JvdW5kIGFuZCBhcHBsaWVzIGZvcmNlcy5cbiAqIEBjbGFzcyBSYXljYXN0VmVoaWNsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0JvZHl9IFtvcHRpb25zLmNoYXNzaXNCb2R5XSBUaGUgY2FyIGNoYXNzaXMgYm9keS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuaW5kZXhSaWdodEF4aXNdIEF4aXMgdG8gdXNlIGZvciByaWdodC4geD0wLCB5PTEsIHo9MlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5pbmRleExlZnRBeGlzXVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5pbmRleFVwQXhpc11cbiAqL1xuZnVuY3Rpb24gUmF5Y2FzdFZlaGljbGUob3B0aW9ucyl7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGNoYXNzaXNCb2R5XG4gICAgICovXG4gICAgdGhpcy5jaGFzc2lzQm9keSA9IG9wdGlvbnMuY2hhc3Npc0JvZHk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBXaGVlbEluZm8gb2JqZWN0cy5cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSB3aGVlbEluZm9zXG4gICAgICovXG4gICAgdGhpcy53aGVlbEluZm9zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBjYXIgaXMgc2xpZGluZy5cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNsaWRpbmdcbiAgICAgKi9cbiAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7V29ybGR9IHdvcmxkXG4gICAgICovXG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJbmRleCBvZiB0aGUgcmlnaHQgYXhpcywgMD14LCAxPXksIDI9elxuICAgICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gaW5kZXhSaWdodEF4aXNcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5pbmRleFJpZ2h0QXhpcyA9IHR5cGVvZihvcHRpb25zLmluZGV4UmlnaHRBeGlzKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmluZGV4UmlnaHRBeGlzIDogMTtcblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHRoZSBmb3J3YXJkIGF4aXMsIDA9eCwgMT15LCAyPXpcbiAgICAgKiBAcHJvcGVydHkge2ludGVnZXJ9IGluZGV4Rm9yd2FyZEF4aXNcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5pbmRleEZvcndhcmRBeGlzID0gdHlwZW9mKG9wdGlvbnMuaW5kZXhGb3J3YXJkQXhpcykgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5pbmRleEZvcndhcmRBeGlzIDogMDtcblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHRoZSB1cCBheGlzLCAwPXgsIDE9eSwgMj16XG4gICAgICogQHByb3BlcnR5IHtpbnRlZ2VyfSBpbmRleFVwQXhpc1xuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICB0aGlzLmluZGV4VXBBeGlzID0gdHlwZW9mKG9wdGlvbnMuaW5kZXhVcEF4aXMpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuaW5kZXhVcEF4aXMgOiAyO1xufVxuXG52YXIgdG1wVmVjMSA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjMiA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjMyA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjNCA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjNSA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjNiA9IG5ldyBWZWMzKCk7XG52YXIgdG1wUmF5ID0gbmV3IFJheSgpO1xuXG4vKipcbiAqIEFkZCBhIHdoZWVsLiBGb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9wdGlvbnMsIHNlZSBXaGVlbEluZm8uXG4gKiBAbWV0aG9kIGFkZFdoZWVsXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKi9cblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5hZGRXaGVlbCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGluZm8gPSBuZXcgV2hlZWxJbmZvKG9wdGlvbnMpO1xuICAgIHZhciBpbmRleCA9IHRoaXMud2hlZWxJbmZvcy5sZW5ndGg7XG4gICAgdGhpcy53aGVlbEluZm9zLnB1c2goaW5mbyk7XG5cbiAgICByZXR1cm4gaW5kZXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3RlZXJpbmcgdmFsdWUgb2YgYSB3aGVlbC5cbiAqIEBtZXRob2Qgc2V0U3RlZXJpbmdWYWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnNldFN0ZWVyaW5nVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XG4gICAgdmFyIHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdO1xuICAgIHdoZWVsLnN0ZWVyaW5nID0gdmFsdWU7XG59O1xuXG52YXIgdG9ycXVlID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBTZXQgdGhlIHdoZWVsIGZvcmNlIHRvIGFwcGx5IG9uIG9uZSBvZiB0aGUgd2hlZWxzIGVhY2ggdGltZSBzdGVwXG4gKiBAbWV0aG9kIGFwcGx5RW5naW5lRm9yY2VcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmFwcGx5RW5naW5lRm9yY2UgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XG4gICAgdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdLmVuZ2luZUZvcmNlID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYnJha2luZyBmb3JjZSBvZiBhIHdoZWVsXG4gKiBAbWV0aG9kIHNldEJyYWtlXG4gKiBAcGFyYW0ge251bWJlcn0gYnJha2VcbiAqIEBwYXJhbSB7aW50ZWdlcn0gd2hlZWxJbmRleFxuICovXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuc2V0QnJha2UgPSBmdW5jdGlvbihicmFrZSwgd2hlZWxJbmRleCl7XG4gICAgdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdLmJyYWtlID0gYnJha2U7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIHRvIHRoZSB3b3JsZC5cbiAqIEBtZXRob2QgYWRkVG9Xb3JsZFxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICB3b3JsZC5hZGRCb2R5KHRoaXMuY2hhc3Npc0JvZHkpO1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGlzLnByZVN0ZXBDYWxsYmFjayA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoYXQudXBkYXRlVmVoaWNsZSh3b3JsZC5kdCk7XG4gICAgfTtcbiAgICB3b3JsZC5hZGRFdmVudExpc3RlbmVyKCdwcmVTdGVwJywgdGhpcy5wcmVTdGVwQ2FsbGJhY2spO1xuICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbn07XG5cbi8qKlxuICogR2V0IG9uZSBvZiB0aGUgd2hlZWwgYXhsZXMsIHdvcmxkLW9yaWVudGVkLlxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgZ2V0VmVoaWNsZUF4aXNXb3JsZFxuICogQHBhcmFtICB7aW50ZWdlcn0gYXhpc0luZGV4XG4gKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmdldFZlaGljbGVBeGlzV29ybGQgPSBmdW5jdGlvbihheGlzSW5kZXgsIHJlc3VsdCl7XG4gICAgcmVzdWx0LnNldChcbiAgICAgICAgYXhpc0luZGV4ID09PSAwID8gMSA6IDAsXG4gICAgICAgIGF4aXNJbmRleCA9PT0gMSA/IDEgOiAwLFxuICAgICAgICBheGlzSW5kZXggPT09IDIgPyAxIDogMFxuICAgICk7XG4gICAgdGhpcy5jaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUocmVzdWx0LCByZXN1bHQpO1xufTtcblxuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZVZlaGljbGUgPSBmdW5jdGlvbih0aW1lU3RlcCl7XG4gICAgdmFyIHdoZWVsSW5mb3MgPSB0aGlzLndoZWVsSW5mb3M7XG4gICAgdmFyIG51bVdoZWVscyA9IHdoZWVsSW5mb3MubGVuZ3RoO1xuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm0oaSk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50VmVoaWNsZVNwZWVkS21Ib3VyID0gMy42ICogY2hhc3Npc0JvZHkudmVsb2NpdHkubm9ybSgpO1xuXG4gICAgdmFyIGZvcndhcmRXb3JsZCA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5nZXRWZWhpY2xlQXhpc1dvcmxkKHRoaXMuaW5kZXhGb3J3YXJkQXhpcywgZm9yd2FyZFdvcmxkKTtcblxuICAgIGlmIChmb3J3YXJkV29ybGQuZG90KGNoYXNzaXNCb2R5LnZlbG9jaXR5KSA8IDApe1xuICAgICAgICB0aGlzLmN1cnJlbnRWZWhpY2xlU3BlZWRLbUhvdXIgKj0gLTE7XG4gICAgfVxuXG4gICAgLy8gc2ltdWxhdGUgc3VzcGVuc2lvblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy5jYXN0UmF5KHdoZWVsSW5mb3NbaV0pO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlU3VzcGVuc2lvbih0aW1lU3RlcCk7XG5cbiAgICB2YXIgaW1wdWxzZSA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIHJlbHBvcyA9IG5ldyBWZWMzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xuICAgICAgICAvL2FwcGx5IHN1c3BlbnNpb24gZm9yY2VcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcbiAgICAgICAgdmFyIHN1c3BlbnNpb25Gb3JjZSA9IHdoZWVsLnN1c3BlbnNpb25Gb3JjZTtcbiAgICAgICAgaWYgKHN1c3BlbnNpb25Gb3JjZSA+IHdoZWVsLm1heFN1c3BlbnNpb25Gb3JjZSkge1xuICAgICAgICAgICAgc3VzcGVuc2lvbkZvcmNlID0gd2hlZWwubWF4U3VzcGVuc2lvbkZvcmNlO1xuICAgICAgICB9XG4gICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQuc2NhbGUoc3VzcGVuc2lvbkZvcmNlICogdGltZVN0ZXAsIGltcHVsc2UpO1xuXG4gICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXNCb2R5LnBvc2l0aW9uLCByZWxwb3MpO1xuICAgICAgICBjaGFzc2lzQm9keS5hcHBseUltcHVsc2UoaW1wdWxzZSwgcmVscG9zKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUZyaWN0aW9uKHRpbWVTdGVwKTtcblxuICAgIHZhciBoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgZndkICA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIHZlbCA9IG5ldyBWZWMzKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG4gICAgICAgIC8vdmFyIHJlbHBvcyA9IG5ldyBWZWMzKCk7XG4gICAgICAgIC8vd2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbHBvcyk7XG4gICAgICAgIGNoYXNzaXNCb2R5LmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCwgdmVsKTtcblxuICAgICAgICAvLyBIYWNrIHRvIGdldCB0aGUgcm90YXRpb24gaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uXG4gICAgICAgIHZhciBtID0gMTtcbiAgICAgICAgc3dpdGNoKHRoaXMuaW5kZXhVcEF4aXMpe1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBtID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aGVlbC5pc0luQ29udGFjdCkge1xuXG4gICAgICAgICAgICB0aGlzLmdldFZlaGljbGVBeGlzV29ybGQodGhpcy5pbmRleEZvcndhcmRBeGlzLCBmd2QpO1xuICAgICAgICAgICAgdmFyIHByb2ogPSBmd2QuZG90KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQpO1xuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5zY2FsZShwcm9qLCBoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qKTtcblxuICAgICAgICAgICAgZndkLnZzdWIoaGl0Tm9ybWFsV29ybGRTY2FsZWRXaXRoUHJvaiwgZndkKTtcblxuICAgICAgICAgICAgdmFyIHByb2oyID0gZndkLmRvdCh2ZWwpO1xuICAgICAgICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiA9IG0gKiBwcm9qMiAqIHRpbWVTdGVwIC8gd2hlZWwucmFkaXVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoKHdoZWVsLnNsaWRpbmcgfHwgIXdoZWVsLmlzSW5Db250YWN0KSAmJiB3aGVlbC5lbmdpbmVGb3JjZSAhPT0gMCAmJiB3aGVlbC51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkKXtcbiAgICAgICAgICAgIC8vIEFwcGx5IGN1c3RvbSByb3RhdGlvbiB3aGVuIGFjY2VsZXJhdGluZyBhbmQgc2xpZGluZ1xuICAgICAgICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiA9ICh3aGVlbC5lbmdpbmVGb3JjZSA+IDAgPyAxIDogLTEpICogd2hlZWwuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCAqIHRpbWVTdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9jayB3aGVlbHNcbiAgICAgICAgaWYoTWF0aC5hYnMod2hlZWwuYnJha2UpID4gTWF0aC5hYnMod2hlZWwuZW5naW5lRm9yY2UpKXtcbiAgICAgICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hlZWwucm90YXRpb24gKz0gd2hlZWwuZGVsdGFSb3RhdGlvbjsgLy8gVXNlIHRoZSBvbGQgdmFsdWVcbiAgICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiAqPSAwLjk5OyAvLyBkYW1waW5nIG9mIHJvdGF0aW9uIHdoZW4gbm90IGluIGNvbnRhY3RcbiAgICB9XG59O1xuXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUudXBkYXRlU3VzcGVuc2lvbiA9IGZ1bmN0aW9uKGRlbHRhVGltZSkge1xuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG4gICAgdmFyIGNoYXNzaXNNYXNzID0gY2hhc3Npc0JvZHkubWFzcztcbiAgICB2YXIgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvcztcbiAgICB2YXIgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciB3X2l0ID0gMDsgd19pdCA8IG51bVdoZWVsczsgd19pdCsrKXtcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1t3X2l0XTtcblxuICAgICAgICBpZiAod2hlZWwuaXNJbkNvbnRhY3Qpe1xuICAgICAgICAgICAgdmFyIGZvcmNlO1xuXG4gICAgICAgICAgICAvLyBTcHJpbmdcbiAgICAgICAgICAgIHZhciBzdXNwX2xlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRfbGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvbkxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsZW5ndGhfZGlmZiA9IChzdXNwX2xlbmd0aCAtIGN1cnJlbnRfbGVuZ3RoKTtcblxuICAgICAgICAgICAgZm9yY2UgPSB3aGVlbC5zdXNwZW5zaW9uU3RpZmZuZXNzICogbGVuZ3RoX2RpZmYgKiB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb247XG5cbiAgICAgICAgICAgIC8vIERhbXBlclxuICAgICAgICAgICAgdmFyIHByb2plY3RlZF9yZWxfdmVsID0gd2hlZWwuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHk7XG4gICAgICAgICAgICB2YXIgc3VzcF9kYW1waW5nO1xuICAgICAgICAgICAgaWYgKHByb2plY3RlZF9yZWxfdmVsIDwgMCkge1xuICAgICAgICAgICAgICAgIHN1c3BfZGFtcGluZyA9IHdoZWVsLmRhbXBpbmdDb21wcmVzc2lvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VzcF9kYW1waW5nID0gd2hlZWwuZGFtcGluZ1JlbGF4YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3JjZSAtPSBzdXNwX2RhbXBpbmcgKiBwcm9qZWN0ZWRfcmVsX3ZlbDtcblxuICAgICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkZvcmNlID0gZm9yY2UgKiBjaGFzc2lzTWFzcztcbiAgICAgICAgICAgIGlmICh3aGVlbC5zdXNwZW5zaW9uRm9yY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkZvcmNlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25Gb3JjZSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIGZyb20gdGhlIHdvcmxkLlxuICogQG1ldGhvZCByZW1vdmVGcm9tV29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5yZW1vdmVGcm9tV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICB3b3JsZC5yZW1vdmUodGhpcy5jaGFzc2lzQm9keSk7XG4gICAgd29ybGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTtcbiAgICB0aGlzLndvcmxkID0gbnVsbDtcbn07XG5cbnZhciBjYXN0UmF5X3JheXZlY3RvciA9IG5ldyBWZWMzKCk7XG52YXIgY2FzdFJheV90YXJnZXQgPSBuZXcgVmVjMygpO1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmNhc3RSYXkgPSBmdW5jdGlvbih3aGVlbCkge1xuICAgIHZhciByYXl2ZWN0b3IgPSBjYXN0UmF5X3JheXZlY3RvcjtcbiAgICB2YXIgdGFyZ2V0ID0gY2FzdFJheV90YXJnZXQ7XG5cbiAgICB0aGlzLnVwZGF0ZVdoZWVsVHJhbnNmb3JtV29ybGQod2hlZWwpO1xuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG5cbiAgICB2YXIgZGVwdGggPSAtMTtcblxuICAgIHZhciByYXlsZW4gPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aCArIHdoZWVsLnJhZGl1cztcblxuICAgIHdoZWVsLmRpcmVjdGlvbldvcmxkLnNjYWxlKHJheWxlbiwgcmF5dmVjdG9yKTtcbiAgICB2YXIgc291cmNlID0gd2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkO1xuICAgIHNvdXJjZS52YWRkKHJheXZlY3RvciwgdGFyZ2V0KTtcbiAgICB2YXIgcmF5Y2FzdFJlc3VsdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQ7XG5cbiAgICB2YXIgcGFyYW0gPSAwO1xuXG4gICAgcmF5Y2FzdFJlc3VsdC5yZXNldCgpO1xuICAgIC8vIFR1cm4gb2ZmIHJheSBjb2xsaXNpb24gd2l0aCB0aGUgY2hhc3NpcyB0ZW1wb3JhcmlseVxuICAgIHZhciBvbGRTdGF0ZSA9IGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlO1xuICAgIGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlID0gZmFsc2U7XG5cbiAgICAvLyBDYXN0IHJheSBhZ2FpbnN0IHdvcmxkXG4gICAgdGhpcy53b3JsZC5yYXlUZXN0KHNvdXJjZSwgdGFyZ2V0LCByYXljYXN0UmVzdWx0KTtcbiAgICBjaGFzc2lzQm9keS5jb2xsaXNpb25SZXNwb25zZSA9IG9sZFN0YXRlO1xuXG4gICAgdmFyIG9iamVjdCA9IHJheWNhc3RSZXN1bHQuYm9keTtcblxuICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuZ3JvdW5kT2JqZWN0ID0gMDtcblxuICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgZGVwdGggPSByYXljYXN0UmVzdWx0LmRpc3RhbmNlO1xuICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkICA9IHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQ7XG4gICAgICAgIHdoZWVsLmlzSW5Db250YWN0ID0gdHJ1ZTtcblxuICAgICAgICB2YXIgaGl0RGlzdGFuY2UgPSByYXljYXN0UmVzdWx0LmRpc3RhbmNlO1xuICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gaGl0RGlzdGFuY2UgLSB3aGVlbC5yYWRpdXM7XG5cbiAgICAgICAgLy8gY2xhbXAgb24gbWF4IHN1c3BlbnNpb24gdHJhdmVsXG4gICAgICAgIHZhciBtaW5TdXNwZW5zaW9uTGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvblJlc3RMZW5ndGggLSB3aGVlbC5tYXhTdXNwZW5zaW9uVHJhdmVsO1xuICAgICAgICB2YXIgbWF4U3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwubWF4U3VzcGVuc2lvblRyYXZlbDtcbiAgICAgICAgaWYgKHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPCBtaW5TdXNwZW5zaW9uTGVuZ3RoKSB7XG4gICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gbWluU3VzcGVuc2lvbkxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA+IG1heFN1c3BlbnNpb25MZW5ndGgpIHtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPSBtYXhTdXNwZW5zaW9uTGVuZ3RoO1xuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5yZXNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3Qod2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuXG4gICAgICAgIHZhciBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCA9IG5ldyBWZWMzKCk7XG4gICAgICAgIGNoYXNzaXNCb2R5LmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCwgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQpO1xuXG4gICAgICAgIHZhciBwcm9qVmVsID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QoIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ICk7XG5cbiAgICAgICAgaWYgKGRlbm9taW5hdG9yID49IC0wLjEpIHtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEgLyAwLjE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW52ID0gLTEgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gcHJvalZlbCAqIGludjtcbiAgICAgICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IGludjtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvL3B1dCB3aGVlbCBpbmZvIGFzIGluIHJlc3QgcG9zaXRpb25cbiAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgMCAqIHdoZWVsLm1heFN1c3BlbnNpb25UcmF2ZWw7XG4gICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMC4wO1xuICAgICAgICB3aGVlbC5kaXJlY3Rpb25Xb3JsZC5zY2FsZSgtMSwgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZCk7XG4gICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVwdGg7XG59O1xuXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUudXBkYXRlV2hlZWxUcmFuc2Zvcm1Xb3JsZCA9IGZ1bmN0aW9uKHdoZWVsKXtcbiAgICB3aGVlbC5pc0luQ29udGFjdCA9IGZhbHNlO1xuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG4gICAgY2hhc3Npc0JvZHkucG9pbnRUb1dvcmxkRnJhbWUod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsLCB3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQpO1xuICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh3aGVlbC5kaXJlY3Rpb25Mb2NhbCwgd2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh3aGVlbC5heGxlTG9jYWwsIHdoZWVsLmF4bGVXb3JsZCk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIG9uZSBvZiB0aGUgd2hlZWwgdHJhbnNmb3JtLlxuICogTm90ZSB3aGVuIHJlbmRlcmluZyB3aGVlbHM6IGR1cmluZyBlYWNoIHN0ZXAsIHdoZWVsIHRyYW5zZm9ybXMgYXJlIHVwZGF0ZWQgQkVGT1JFIHRoZSBjaGFzc2lzOyBpZS4gdGhlaXIgcG9zaXRpb24gYmVjb21lcyBpbnZhbGlkIGFmdGVyIHRoZSBzdGVwLiBUaHVzIHdoZW4geW91IHJlbmRlciB3aGVlbHMsIHlvdSBtdXN0IHVwZGF0ZSB3aGVlbCB0cmFuc2Zvcm1zIGJlZm9yZSByZW5kZXJpbmcgdGhlbS4gU2VlIHJheWNhc3RWZWhpY2xlIGRlbW8gZm9yIGFuIGV4YW1wbGUuXG4gKiBAbWV0aG9kIHVwZGF0ZVdoZWVsVHJhbnNmb3JtXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXggVGhlIHdoZWVsIGluZGV4IHRvIHVwZGF0ZS5cbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZVdoZWVsVHJhbnNmb3JtID0gZnVuY3Rpb24od2hlZWxJbmRleCl7XG4gICAgdmFyIHVwID0gdG1wVmVjNDtcbiAgICB2YXIgcmlnaHQgPSB0bXBWZWM1O1xuICAgIHZhciBmd2QgPSB0bXBWZWM2O1xuXG4gICAgdmFyIHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdO1xuICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm1Xb3JsZCh3aGVlbCk7XG5cbiAgICB3aGVlbC5kaXJlY3Rpb25Mb2NhbC5zY2FsZSgtMSwgdXApO1xuICAgIHJpZ2h0LmNvcHkod2hlZWwuYXhsZUxvY2FsKTtcbiAgICB1cC5jcm9zcyhyaWdodCwgZndkKTtcbiAgICBmd2Qubm9ybWFsaXplKCk7XG4gICAgcmlnaHQubm9ybWFsaXplKCk7XG5cbiAgICAvLyBSb3RhdGUgYXJvdW5kIHN0ZWVyaW5nIG92ZXIgdGhlIHdoZWVsQXhsZVxuICAgIHZhciBzdGVlcmluZyA9IHdoZWVsLnN0ZWVyaW5nO1xuICAgIHZhciBzdGVlcmluZ09ybiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgc3RlZXJpbmdPcm4uc2V0RnJvbUF4aXNBbmdsZSh1cCwgc3RlZXJpbmcpO1xuXG4gICAgdmFyIHJvdGF0aW5nT3JuID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICByb3RhdGluZ09ybi5zZXRGcm9tQXhpc0FuZ2xlKHJpZ2h0LCB3aGVlbC5yb3RhdGlvbik7XG5cbiAgICAvLyBXb3JsZCByb3RhdGlvbiBvZiB0aGUgd2hlZWxcbiAgICB2YXIgcSA9IHdoZWVsLndvcmxkVHJhbnNmb3JtLnF1YXRlcm5pb247XG4gICAgdGhpcy5jaGFzc2lzQm9keS5xdWF0ZXJuaW9uLm11bHQoc3RlZXJpbmdPcm4sIHEpO1xuICAgIHEubXVsdChyb3RhdGluZ09ybiwgcSk7XG5cbiAgICBxLm5vcm1hbGl6ZSgpO1xuXG4gICAgLy8gd29ybGQgcG9zaXRpb24gb2YgdGhlIHdoZWVsXG4gICAgdmFyIHAgPSB3aGVlbC53b3JsZFRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBwLmNvcHkod2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuICAgIHAuc2NhbGUod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCwgcCk7XG4gICAgcC52YWRkKHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCwgcCk7XG59O1xuXG52YXIgZGlyZWN0aW9ucyA9IFtcbiAgICBuZXcgVmVjMygxLCAwLCAwKSxcbiAgICBuZXcgVmVjMygwLCAxLCAwKSxcbiAgICBuZXcgVmVjMygwLCAwLCAxKVxuXTtcblxuLyoqXG4gKiBHZXQgdGhlIHdvcmxkIHRyYW5zZm9ybSBvZiBvbmUgb2YgdGhlIHdoZWVsc1xuICogQG1ldGhvZCBnZXRXaGVlbFRyYW5zZm9ybVdvcmxkXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm19XG4gKi9cblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5nZXRXaGVlbFRyYW5zZm9ybVdvcmxkID0gZnVuY3Rpb24od2hlZWxJbmRleCkge1xuICAgIHJldHVybiB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0ud29ybGRUcmFuc2Zvcm07XG59O1xuXG5cbnZhciB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSBuZXcgVmVjMygpO1xudmFyIHVwZGF0ZUZyaWN0aW9uX2F4bGUgPSBbXTtcbnZhciB1cGRhdGVGcmljdGlvbl9mb3J3YXJkV1MgPSBbXTtcbnZhciBzaWRlRnJpY3Rpb25TdGlmZm5lc3MyID0gMTtcblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS51cGRhdGVGcmljdGlvbiA9IGZ1bmN0aW9uKHRpbWVTdGVwKSB7XG4gICAgdmFyIHN1cmZOb3JtYWxXU19zY2FsZWRfcHJvaiA9IHVwZGF0ZUZyaWN0aW9uX3N1cmZOb3JtYWxXU19zY2FsZWRfcHJvajtcblxuICAgIC8vY2FsY3VsYXRlIHRoZSBpbXB1bHNlLCBzbyB0aGF0IHRoZSB3aGVlbHMgZG9uJ3QgbW92ZSBzaWRld2FyZHNcbiAgICB2YXIgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvcztcbiAgICB2YXIgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XG4gICAgdmFyIGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTtcbiAgICB2YXIgZm9yd2FyZFdTID0gdXBkYXRlRnJpY3Rpb25fZm9yd2FyZFdTO1xuICAgIHZhciBheGxlID0gdXBkYXRlRnJpY3Rpb25fYXhsZTtcblxuICAgIHZhciBudW1XaGVlbHNPbkdyb3VuZCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG5cbiAgICAgICAgdmFyIGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTtcbiAgICAgICAgaWYgKGdyb3VuZE9iamVjdCl7XG4gICAgICAgICAgICBudW1XaGVlbHNPbkdyb3VuZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hlZWwuc2lkZUltcHVsc2UgPSAwO1xuICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSA9IDA7XG4gICAgICAgIGlmKCFmb3J3YXJkV1NbaV0pe1xuICAgICAgICAgICAgZm9yd2FyZFdTW2ldID0gbmV3IFZlYzMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZighYXhsZVtpXSl7XG4gICAgICAgICAgICBheGxlW2ldID0gbmV3IFZlYzMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspe1xuICAgICAgICB2YXIgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xuXG4gICAgICAgIHZhciBncm91bmRPYmplY3QgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmJvZHk7XG5cbiAgICAgICAgaWYgKGdyb3VuZE9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGF4bGVpID0gYXhsZVtpXTtcbiAgICAgICAgICAgIHZhciB3aGVlbFRyYW5zID0gdGhpcy5nZXRXaGVlbFRyYW5zZm9ybVdvcmxkKGkpO1xuXG4gICAgICAgICAgICAvLyBHZXQgd29ybGQgYXhsZVxuICAgICAgICAgICAgd2hlZWxUcmFucy52ZWN0b3JUb1dvcmxkRnJhbWUoZGlyZWN0aW9uc1t0aGlzLmluZGV4UmlnaHRBeGlzXSwgYXhsZWkpO1xuXG4gICAgICAgICAgICB2YXIgc3VyZk5vcm1hbFdTID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZDtcbiAgICAgICAgICAgIHZhciBwcm9qID0gYXhsZWkuZG90KHN1cmZOb3JtYWxXUyk7XG4gICAgICAgICAgICBzdXJmTm9ybWFsV1Muc2NhbGUocHJvaiwgc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qKTtcbiAgICAgICAgICAgIGF4bGVpLnZzdWIoc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qLCBheGxlaSk7XG4gICAgICAgICAgICBheGxlaS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgc3VyZk5vcm1hbFdTLmNyb3NzKGF4bGVpLCBmb3J3YXJkV1NbaV0pO1xuICAgICAgICAgICAgZm9yd2FyZFdTW2ldLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICB3aGVlbC5zaWRlSW1wdWxzZSA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWwoXG4gICAgICAgICAgICAgICAgY2hhc3Npc0JvZHksXG4gICAgICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgICAgIGdyb3VuZE9iamVjdCxcbiAgICAgICAgICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICAgICAgYXhsZWlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlICo9IHNpZGVGcmljdGlvblN0aWZmbmVzczI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2lkZUZhY3RvciA9IDE7XG4gICAgdmFyIGZ3ZEZhY3RvciA9IDAuNTtcblxuICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcbiAgICAgICAgdmFyIGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTtcblxuICAgICAgICB2YXIgcm9sbGluZ0ZyaWN0aW9uID0gMDtcblxuICAgICAgICB3aGVlbC5zbGlwSW5mbyA9IDE7XG4gICAgICAgIGlmIChncm91bmRPYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Um9sbGluZ0ZyaWN0aW9uSW1wdWxzZSA9IDA7XG4gICAgICAgICAgICB2YXIgbWF4SW1wdWxzZSA9IHdoZWVsLmJyYWtlID8gd2hlZWwuYnJha2UgOiBkZWZhdWx0Um9sbGluZ0ZyaWN0aW9uSW1wdWxzZTtcblxuICAgICAgICAgICAgLy8gYnRXaGVlbENvbnRhY3RQb2ludCBjb250YWN0UHQoY2hhc3Npc0JvZHksZ3JvdW5kT2JqZWN0LHdoZWVsSW5mcmF5Y2FzdEluZm8uaGl0UG9pbnRXb3JsZCxmb3J3YXJkV1Nbd2hlZWxdLG1heEltcHVsc2UpO1xuICAgICAgICAgICAgLy8gcm9sbGluZ0ZyaWN0aW9uID0gY2FsY1JvbGxpbmdGcmljdGlvbihjb250YWN0UHQpO1xuICAgICAgICAgICAgcm9sbGluZ0ZyaWN0aW9uID0gY2FsY1JvbGxpbmdGcmljdGlvbihjaGFzc2lzQm9keSwgZ3JvdW5kT2JqZWN0LCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQsIGZvcndhcmRXU1tpXSwgbWF4SW1wdWxzZSk7XG5cbiAgICAgICAgICAgIHJvbGxpbmdGcmljdGlvbiArPSB3aGVlbC5lbmdpbmVGb3JjZSAqIHRpbWVTdGVwO1xuXG4gICAgICAgICAgICAvLyByb2xsaW5nRnJpY3Rpb24gPSAwO1xuICAgICAgICAgICAgdmFyIGZhY3RvciA9IG1heEltcHVsc2UgLyByb2xsaW5nRnJpY3Rpb247XG4gICAgICAgICAgICB3aGVlbC5zbGlwSW5mbyAqPSBmYWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICAvL3N3aXRjaCBiZXR3ZWVuIGFjdGl2ZSByb2xsaW5nICh0aHJvdHRsZSksIGJyYWtpbmcgYW5kIG5vbi1hY3RpdmUgcm9sbGluZyBmcmljdGlvbiAobnRocm90dGxlL2JyZWFrKVxuXG4gICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlID0gMDtcbiAgICAgICAgd2hlZWwuc2tpZEluZm8gPSAxO1xuXG4gICAgICAgIGlmIChncm91bmRPYmplY3QpIHtcbiAgICAgICAgICAgIHdoZWVsLnNraWRJbmZvID0gMTtcblxuICAgICAgICAgICAgdmFyIG1heGltcCA9IHdoZWVsLnN1c3BlbnNpb25Gb3JjZSAqIHRpbWVTdGVwICogd2hlZWwuZnJpY3Rpb25TbGlwO1xuICAgICAgICAgICAgdmFyIG1heGltcFNpZGUgPSBtYXhpbXA7XG5cbiAgICAgICAgICAgIHZhciBtYXhpbXBTcXVhcmVkID0gbWF4aW1wICogbWF4aW1wU2lkZTtcblxuICAgICAgICAgICAgd2hlZWwuZm9yd2FyZEltcHVsc2UgPSByb2xsaW5nRnJpY3Rpb247Ly93aGVlbEluZm8uZW5naW5lRm9yY2UqIHRpbWVTdGVwO1xuXG4gICAgICAgICAgICB2YXIgeCA9IHdoZWVsLmZvcndhcmRJbXB1bHNlICogZndkRmFjdG9yO1xuICAgICAgICAgICAgdmFyIHkgPSB3aGVlbC5zaWRlSW1wdWxzZSAqIHNpZGVGYWN0b3I7XG5cbiAgICAgICAgICAgIHZhciBpbXB1bHNlU3F1YXJlZCA9IHggKiB4ICsgeSAqIHk7XG5cbiAgICAgICAgICAgIHdoZWVsLnNsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpbXB1bHNlU3F1YXJlZCA+IG1heGltcFNxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNsaWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdoZWVsLnNsaWRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IG1heGltcCAvIE1hdGguc3FydChpbXB1bHNlU3F1YXJlZCk7XG5cbiAgICAgICAgICAgICAgICB3aGVlbC5za2lkSW5mbyAqPSBmYWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zbGlkaW5nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG4gICAgICAgICAgICBpZiAod2hlZWwuc2lkZUltcHVsc2UgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAod2hlZWwuc2tpZEluZm8gPCAxKXtcbiAgICAgICAgICAgICAgICAgICAgd2hlZWwuZm9yd2FyZEltcHVsc2UgKj0gd2hlZWwuc2tpZEluZm87XG4gICAgICAgICAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlICo9IHdoZWVsLnNraWRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRoZSBpbXB1bHNlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcblxuICAgICAgICB2YXIgcmVsX3BvcyA9IG5ldyBWZWMzKCk7XG4gICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXNCb2R5LnBvc2l0aW9uLCByZWxfcG9zKTtcbiAgICAgICAgLy8gY2Fubm9ucyBhcHBseWltcHVsc2UgaXMgdXNpbmcgd29ybGQgY29vcmQgZm9yIHRoZSBwb3NpdGlvblxuICAgICAgICAvL3JlbF9wb3MuY29weSh3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQpO1xuXG4gICAgICAgIGlmICh3aGVlbC5mb3J3YXJkSW1wdWxzZSAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIGltcHVsc2UgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgZm9yd2FyZFdTW2ldLnNjYWxlKHdoZWVsLmZvcndhcmRJbXB1bHNlLCBpbXB1bHNlKTtcbiAgICAgICAgICAgIGNoYXNzaXNCb2R5LmFwcGx5SW1wdWxzZShpbXB1bHNlLCByZWxfcG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aGVlbC5zaWRlSW1wdWxzZSAhPT0gMCl7XG4gICAgICAgICAgICB2YXIgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5O1xuXG4gICAgICAgICAgICB2YXIgcmVsX3BvczIgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoZ3JvdW5kT2JqZWN0LnBvc2l0aW9uLCByZWxfcG9zMik7XG4gICAgICAgICAgICAvL3JlbF9wb3MyLmNvcHkod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkKTtcbiAgICAgICAgICAgIHZhciBzaWRlSW1wID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIGF4bGVbaV0uc2NhbGUod2hlZWwuc2lkZUltcHVsc2UsIHNpZGVJbXApO1xuXG4gICAgICAgICAgICAvLyBTY2FsZSB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlIHVwIGRpcmVjdGlvbiB3aXRoIHJvbGxJbmZsdWVuY2UuXG4gICAgICAgICAgICAvLyBJZiByb2xsSW5mbHVlbmNlIGlzIDEsIHRoZSBpbXB1bHNlIHdpbGwgYmUgYXBwbGllZCBvbiB0aGUgaGl0UG9pbnQgKGVhc3kgdG8gcm9sbCBvdmVyKSwgaWYgaXQgaXMgemVybyBpdCB3aWxsIGJlIGFwcGxpZWQgaW4gdGhlIHNhbWUgcGxhbmUgYXMgdGhlIGNlbnRlciBvZiBtYXNzIChub3QgZWFzeSB0byByb2xsIG92ZXIpLlxuICAgICAgICAgICAgY2hhc3Npc0JvZHkudmVjdG9yVG9Mb2NhbEZyYW1lKHJlbF9wb3MsIHJlbF9wb3MpO1xuICAgICAgICAgICAgcmVsX3Bvc1sneHl6J1t0aGlzLmluZGV4VXBBeGlzXV0gKj0gd2hlZWwucm9sbEluZmx1ZW5jZTtcbiAgICAgICAgICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShyZWxfcG9zLCByZWxfcG9zKTtcbiAgICAgICAgICAgIGNoYXNzaXNCb2R5LmFwcGx5SW1wdWxzZShzaWRlSW1wLCByZWxfcG9zKTtcblxuICAgICAgICAgICAgLy9hcHBseSBmcmljdGlvbiBpbXB1bHNlIG9uIHRoZSBncm91bmRcbiAgICAgICAgICAgIHNpZGVJbXAuc2NhbGUoLTEsIHNpZGVJbXApO1xuICAgICAgICAgICAgZ3JvdW5kT2JqZWN0LmFwcGx5SW1wdWxzZShzaWRlSW1wLCByZWxfcG9zMik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwxID0gbmV3IFZlYzMoKTtcbnZhciBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbDIgPSBuZXcgVmVjMygpO1xudmFyIGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsID0gbmV3IFZlYzMoKTtcblxuZnVuY3Rpb24gY2FsY1JvbGxpbmdGcmljdGlvbihib2R5MCwgYm9keTEsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQsIG1heEltcHVsc2UpIHtcbiAgICB2YXIgajEgPSAwO1xuICAgIHZhciBjb250YWN0UG9zV29ybGQgPSBmcmljdGlvblBvc1dvcmxkO1xuXG4gICAgLy8gdmFyIHJlbF9wb3MxID0gbmV3IFZlYzMoKTtcbiAgICAvLyB2YXIgcmVsX3BvczIgPSBuZXcgVmVjMygpO1xuICAgIHZhciB2ZWwxID0gY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwxO1xuICAgIHZhciB2ZWwyID0gY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwyO1xuICAgIHZhciB2ZWwgPSBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbDtcbiAgICAvLyBjb250YWN0UG9zV29ybGQudnN1Yihib2R5MC5wb3NpdGlvbiwgcmVsX3BvczEpO1xuICAgIC8vIGNvbnRhY3RQb3NXb3JsZC52c3ViKGJvZHkxLnBvc2l0aW9uLCByZWxfcG9zMik7XG5cbiAgICBib2R5MC5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChjb250YWN0UG9zV29ybGQsIHZlbDEpO1xuICAgIGJvZHkxLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KGNvbnRhY3RQb3NXb3JsZCwgdmVsMik7XG4gICAgdmVsMS52c3ViKHZlbDIsIHZlbCk7XG5cbiAgICB2YXIgdnJlbCA9IGZyaWN0aW9uRGlyZWN0aW9uV29ybGQuZG90KHZlbCk7XG5cbiAgICB2YXIgZGVub20wID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcihib2R5MCwgZnJpY3Rpb25Qb3NXb3JsZCwgZnJpY3Rpb25EaXJlY3Rpb25Xb3JsZCk7XG4gICAgdmFyIGRlbm9tMSA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keTEsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQpO1xuICAgIHZhciByZWxheGF0aW9uID0gMTtcbiAgICB2YXIgamFjRGlhZ0FCSW52ID0gcmVsYXhhdGlvbiAvIChkZW5vbTAgKyBkZW5vbTEpO1xuXG4gICAgLy8gY2FsY3VsYXRlIGogdGhhdCBtb3ZlcyB1cyB0byB6ZXJvIHJlbGF0aXZlIHZlbG9jaXR5XG4gICAgajEgPSAtdnJlbCAqIGphY0RpYWdBQkludjtcblxuICAgIGlmIChtYXhJbXB1bHNlIDwgajEpIHtcbiAgICAgICAgajEgPSBtYXhJbXB1bHNlO1xuICAgIH1cbiAgICBpZiAoajEgPCAtbWF4SW1wdWxzZSkge1xuICAgICAgICBqMSA9IC1tYXhJbXB1bHNlO1xuICAgIH1cblxuICAgIHJldHVybiBqMTtcbn1cblxudmFyIGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfcjAgPSBuZXcgVmVjMygpO1xudmFyIGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfYzAgPSBuZXcgVmVjMygpO1xudmFyIGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfdmVjID0gbmV3IFZlYzMoKTtcbnZhciBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX20gPSBuZXcgVmVjMygpO1xuZnVuY3Rpb24gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcihib2R5LCBwb3MsIG5vcm1hbCkge1xuICAgIHZhciByMCA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfcjA7XG4gICAgdmFyIGMwID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9jMDtcbiAgICB2YXIgdmVjID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl92ZWM7XG4gICAgdmFyIG0gPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX207XG5cbiAgICBwb3MudnN1Yihib2R5LnBvc2l0aW9uLCByMCk7XG4gICAgcjAuY3Jvc3Mobm9ybWFsLCBjMCk7XG4gICAgYm9keS5pbnZJbmVydGlhV29ybGQudm11bHQoYzAsIG0pO1xuICAgIG0uY3Jvc3MocjAsIHZlYyk7XG5cbiAgICByZXR1cm4gYm9keS5pbnZNYXNzICsgbm9ybWFsLmRvdCh2ZWMpO1xufVxuXG5cbnZhciByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDEgPSBuZXcgVmVjMygpO1xudmFyIHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMiA9IG5ldyBWZWMzKCk7XG52YXIgcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwgPSBuZXcgVmVjMygpO1xuXG4vL2JpbGF0ZXJhbCBjb25zdHJhaW50IGJldHdlZW4gdHdvIGR5bmFtaWMgb2JqZWN0c1xuZnVuY3Rpb24gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbChib2R5MSwgcG9zMSwgYm9keTIsIHBvczIsIG5vcm1hbCwgaW1wdWxzZSl7XG4gICAgdmFyIG5vcm1hbExlblNxciA9IG5vcm1hbC5ub3JtMigpO1xuICAgIGlmIChub3JtYWxMZW5TcXIgPiAxLjEpe1xuICAgICAgICByZXR1cm4gMDsgLy8gbm8gaW1wdWxzZVxuICAgIH1cbiAgICAvLyB2YXIgcmVsX3BvczEgPSBuZXcgVmVjMygpO1xuICAgIC8vIHZhciByZWxfcG9zMiA9IG5ldyBWZWMzKCk7XG4gICAgLy8gcG9zMS52c3ViKGJvZHkxLnBvc2l0aW9uLCByZWxfcG9zMSk7XG4gICAgLy8gcG9zMi52c3ViKGJvZHkyLnBvc2l0aW9uLCByZWxfcG9zMik7XG5cbiAgICB2YXIgdmVsMSA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMTtcbiAgICB2YXIgdmVsMiA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMjtcbiAgICB2YXIgdmVsID0gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWw7XG4gICAgYm9keTEuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocG9zMSwgdmVsMSk7XG4gICAgYm9keTIuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocG9zMiwgdmVsMik7XG5cbiAgICB2ZWwxLnZzdWIodmVsMiwgdmVsKTtcblxuICAgIHZhciByZWxfdmVsID0gbm9ybWFsLmRvdCh2ZWwpO1xuXG4gICAgdmFyIGNvbnRhY3REYW1waW5nID0gMC4yO1xuICAgIHZhciBtYXNzVGVybSA9IDEgLyAoYm9keTEuaW52TWFzcyArIGJvZHkyLmludk1hc3MpO1xuICAgIHZhciBpbXB1bHNlID0gLSBjb250YWN0RGFtcGluZyAqIHJlbF92ZWwgKiBtYXNzVGVybTtcblxuICAgIHJldHVybiBpbXB1bHNlO1xufSIsInZhciBCb2R5ID0gcmVxdWlyZSgnLi9Cb2R5Jyk7XG52YXIgU3BoZXJlID0gcmVxdWlyZSgnLi4vc2hhcGVzL1NwaGVyZScpO1xudmFyIEJveCA9IHJlcXVpcmUoJy4uL3NoYXBlcy9Cb3gnKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgSGluZ2VDb25zdHJhaW50ID0gcmVxdWlyZSgnLi4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmlnaWRWZWhpY2xlO1xuXG4vKipcbiAqIFNpbXBsZSB2ZWhpY2xlIGhlbHBlciBjbGFzcyB3aXRoIHNwaGVyaWNhbCByaWdpZCBib2R5IHdoZWVscy5cbiAqIEBjbGFzcyBSaWdpZFZlaGljbGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5jaGFzc2lzQm9keV1cbiAqL1xuZnVuY3Rpb24gUmlnaWRWZWhpY2xlKG9wdGlvbnMpe1xuICAgIHRoaXMud2hlZWxCb2RpZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBjb29yZGluYXRlU3lzdGVtXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlU3lzdGVtID0gdHlwZW9mKG9wdGlvbnMuY29vcmRpbmF0ZVN5c3RlbSk9PT0ndW5kZWZpbmVkJyA/IG5ldyBWZWMzKDEsIDIsIDMpIDogb3B0aW9ucy5jb29yZGluYXRlU3lzdGVtLmNsb25lKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGNoYXNzaXNCb2R5XG4gICAgICovXG4gICAgdGhpcy5jaGFzc2lzQm9keSA9IG9wdGlvbnMuY2hhc3Npc0JvZHk7XG5cbiAgICBpZighdGhpcy5jaGFzc2lzQm9keSl7XG4gICAgICAgIC8vIE5vIGNoYXNzaXMgYm9keSBnaXZlbi4gQ3JlYXRlIGl0IVxuICAgICAgICB2YXIgY2hhc3Npc1NoYXBlID0gbmV3IEJveChuZXcgVmVjMyg1LCAyLCAwLjUpKTtcbiAgICAgICAgdGhpcy5jaGFzc2lzQm9keSA9IG5ldyBCb2R5KDEsIGNoYXNzaXNTaGFwZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcblxuICAgIHRoaXMud2hlZWxBeGVzID0gW107XG4gICAgdGhpcy53aGVlbEZvcmNlcyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIHdoZWVsXG4gKiBAbWV0aG9kIGFkZFdoZWVsXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc0Zyb250V2hlZWxdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBvc2l0aW9uXSBQb3NpdGlvbiBvZiB0aGUgd2hlZWwsIGxvY2FsbHkgaW4gdGhlIGNoYXNzaXMgYm9keS5cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuZGlyZWN0aW9uXSBTbGlkZSBkaXJlY3Rpb24gb2YgdGhlIHdoZWVsIGFsb25nIHRoZSBzdXNwZW5zaW9uLlxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzXSBBeGlzIG9mIHJvdGF0aW9uIG9mIHRoZSB3aGVlbCwgbG9jYWxseSBkZWZpbmVkIGluIHRoZSBjaGFzc2lzLlxuICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5ib2R5XSBUaGUgd2hlZWwgYm9keS5cbiAqL1xuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5hZGRXaGVlbCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB3aGVlbEJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgaWYoIXdoZWVsQm9keSl7XG4gICAgICAgIHdoZWVsQm9keSA9ICBuZXcgQm9keSgxLCBuZXcgU3BoZXJlKDEuMikpO1xuICAgIH1cbiAgICB0aGlzLndoZWVsQm9kaWVzLnB1c2god2hlZWxCb2R5KTtcbiAgICB0aGlzLndoZWVsRm9yY2VzLnB1c2goMCk7XG5cbiAgICAvLyBQb3NpdGlvbiBjb25zdHJhaW4gd2hlZWxzXG4gICAgdmFyIHplcm8gPSBuZXcgVmVjMygpO1xuICAgIHZhciBwb3NpdGlvbiA9IHR5cGVvZihvcHRpb25zLnBvc2l0aW9uKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnBvc2l0aW9uLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuXG4gICAgLy8gU2V0IHBvc2l0aW9uIGxvY2FsbHkgdG8gdGhlIGNoYXNzaXNcbiAgICB2YXIgd29ybGRQb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5jaGFzc2lzQm9keS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgd29ybGRQb3NpdGlvbik7XG4gICAgd2hlZWxCb2R5LnBvc2l0aW9uLnNldCh3b3JsZFBvc2l0aW9uLngsIHdvcmxkUG9zaXRpb24ueSwgd29ybGRQb3NpdGlvbi56KTtcblxuICAgIC8vIENvbnN0cmFpbiB3aGVlbFxuICAgIHZhciBheGlzID0gdHlwZW9mKG9wdGlvbnMuYXhpcykgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5heGlzLmNsb25lKCkgOiBuZXcgVmVjMygwLCAxLCAwKTtcbiAgICB0aGlzLndoZWVsQXhlcy5wdXNoKGF4aXMpO1xuXG4gICAgdmFyIGhpbmdlQ29uc3RyYWludCA9IG5ldyBIaW5nZUNvbnN0cmFpbnQodGhpcy5jaGFzc2lzQm9keSwgd2hlZWxCb2R5LCB7XG4gICAgICAgIHBpdm90QTogcG9zaXRpb24sXG4gICAgICAgIGF4aXNBOiBheGlzLFxuICAgICAgICBwaXZvdEI6IFZlYzMuWkVSTyxcbiAgICAgICAgYXhpc0I6IGF4aXMsXG4gICAgICAgIGNvbGxpZGVDb25uZWN0ZWQ6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5jb25zdHJhaW50cy5wdXNoKGhpbmdlQ29uc3RyYWludCk7XG5cbiAgICByZXR1cm4gdGhpcy53aGVlbEJvZGllcy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHN0ZWVyaW5nIHZhbHVlIG9mIGEgd2hlZWwuXG4gKiBAbWV0aG9kIHNldFN0ZWVyaW5nVmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKiBAdG9kbyBjaGVjayBjb29yZGluYXRlU3lzdGVtXG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuc2V0U3RlZXJpbmdWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcbiAgICAvLyBTZXQgYW5nbGUgb2YgdGhlIGhpbmdlIGF4aXNcbiAgICB2YXIgYXhpcyA9IHRoaXMud2hlZWxBeGVzW3doZWVsSW5kZXhdO1xuXG4gICAgdmFyIGMgPSBNYXRoLmNvcyh2YWx1ZSksXG4gICAgICAgIHMgPSBNYXRoLnNpbih2YWx1ZSksXG4gICAgICAgIHggPSBheGlzLngsXG4gICAgICAgIHkgPSBheGlzLnk7XG4gICAgdGhpcy5jb25zdHJhaW50c1t3aGVlbEluZGV4XS5heGlzQS5zZXQoXG4gICAgICAgIGMqeCAtcyp5LFxuICAgICAgICBzKnggK2MqeSxcbiAgICAgICAgMFxuICAgICk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdGFyZ2V0IHJvdGF0aW9uYWwgc3BlZWQgb2YgdGhlIGhpbmdlIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIHNldE1vdG9yU3BlZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuc2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcbiAgICB2YXIgaGluZ2VDb25zdHJhaW50ID0gdGhpcy5jb25zdHJhaW50c1t3aGVlbEluZGV4XTtcbiAgICBoaW5nZUNvbnN0cmFpbnQuZW5hYmxlTW90b3IoKTtcbiAgICBoaW5nZUNvbnN0cmFpbnQubW90b3JUYXJnZXRWZWxvY2l0eSA9IHZhbHVlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHRhcmdldCByb3RhdGlvbmFsIHNwZWVkIG9mIHRoZSBoaW5nZSBjb25zdHJhaW50LlxuICogQG1ldGhvZCBkaXNhYmxlTW90b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24od2hlZWxJbmRleCl7XG4gICAgdmFyIGhpbmdlQ29uc3RyYWludCA9IHRoaXMuY29uc3RyYWludHNbd2hlZWxJbmRleF07XG4gICAgaGluZ2VDb25zdHJhaW50LmRpc2FibGVNb3RvcigpO1xufTtcblxudmFyIHRvcnF1ZSA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogU2V0IHRoZSB3aGVlbCBmb3JjZSB0byBhcHBseSBvbiBvbmUgb2YgdGhlIHdoZWVscyBlYWNoIHRpbWUgc3RlcFxuICogQG1ldGhvZCBzZXRXaGVlbEZvcmNlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuc2V0V2hlZWxGb3JjZSA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcbiAgICB0aGlzLndoZWVsRm9yY2VzW3doZWVsSW5kZXhdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEFwcGx5IGEgdG9ycXVlIG9uIG9uZSBvZiB0aGUgd2hlZWxzLlxuICogQG1ldGhvZCBhcHBseVdoZWVsRm9yY2VcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAqL1xuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5hcHBseVdoZWVsRm9yY2UgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XG4gICAgdmFyIGF4aXMgPSB0aGlzLndoZWVsQXhlc1t3aGVlbEluZGV4XTtcbiAgICB2YXIgd2hlZWxCb2R5ID0gdGhpcy53aGVlbEJvZGllc1t3aGVlbEluZGV4XTtcbiAgICB2YXIgYm9keVRvcnF1ZSA9IHdoZWVsQm9keS50b3JxdWU7XG5cbiAgICBheGlzLnNjYWxlKHZhbHVlLCB0b3JxdWUpO1xuICAgIHdoZWVsQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUodG9ycXVlLCB0b3JxdWUpO1xuICAgIGJvZHlUb3JxdWUudmFkZCh0b3JxdWUsIGJvZHlUb3JxdWUpO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIHZlaGljbGUgaW5jbHVkaW5nIGl0cyBjb25zdHJhaW50cyB0byB0aGUgd29ybGQuXG4gKiBAbWV0aG9kIGFkZFRvV29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuYWRkVG9Xb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgIHZhciBib2RpZXMgPSB0aGlzLndoZWVsQm9kaWVzLmNvbmNhdChbdGhpcy5jaGFzc2lzQm9keV0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29ybGQuYWRkQm9keShib2RpZXNbaV0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50c1tpXSk7XG4gICAgfVxuXG4gICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpKTtcbn07XG5cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHdoZWVsRm9yY2VzID0gdGhpcy53aGVlbEZvcmNlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdoZWVsRm9yY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYXBwbHlXaGVlbEZvcmNlKHdoZWVsRm9yY2VzW2ldLCBpKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIGZyb20gdGhlIHdvcmxkLlxuICogQG1ldGhvZCByZW1vdmVGcm9tV29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUucmVtb3ZlRnJvbVdvcmxkID0gZnVuY3Rpb24od29ybGQpe1xuICAgIHZhciBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMud2hlZWxCb2RpZXMuY29uY2F0KFt0aGlzLmNoYXNzaXNCb2R5XSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3b3JsZC5yZW1vdmUoYm9kaWVzW2ldKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdvcmxkLnJlbW92ZUNvbnN0cmFpbnQoY29uc3RyYWludHNbaV0pO1xuICAgIH1cbn07XG5cbnZhciB3b3JsZEF4aXMgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEdldCBjdXJyZW50IHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgYSB3aGVlbFxuICogQG1ldGhvZCBnZXRXaGVlbFNwZWVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAqL1xuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5nZXRXaGVlbFNwZWVkID0gZnVuY3Rpb24od2hlZWxJbmRleCl7XG4gICAgdmFyIGF4aXMgPSB0aGlzLndoZWVsQXhlc1t3aGVlbEluZGV4XTtcbiAgICB2YXIgd2hlZWxCb2R5ID0gdGhpcy53aGVlbEJvZGllc1t3aGVlbEluZGV4XTtcbiAgICB2YXIgdyA9IHdoZWVsQm9keS5hbmd1bGFyVmVsb2NpdHk7XG4gICAgdGhpcy5jaGFzc2lzQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUoYXhpcywgd29ybGRBeGlzKTtcbiAgICByZXR1cm4gdy5kb3Qod29ybGRBeGlzKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFNQSFN5c3RlbTtcblxudmFyIFNoYXBlID0gcmVxdWlyZSgnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBQYXJ0aWNsZSA9IHJlcXVpcmUoJy4uL3NoYXBlcy9QYXJ0aWNsZScpO1xudmFyIEJvZHkgPSByZXF1aXJlKCcuLi9vYmplY3RzL0JvZHknKTtcbnZhciBNYXRlcmlhbCA9IHJlcXVpcmUoJy4uL21hdGVyaWFsL01hdGVyaWFsJyk7XG5cbi8qKlxuICogU21vb3RoZWQtcGFydGljbGUgaHlkcm9keW5hbWljcyBzeXN0ZW1cbiAqIEBjbGFzcyBTUEhTeXN0ZW1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTUEhTeXN0ZW0oKXtcbiAgICB0aGlzLnBhcnRpY2xlcyA9IFtdO1xuXHRcbiAgICAvKipcbiAgICAgKiBEZW5zaXR5IG9mIHRoZSBzeXN0ZW0gKGtnL20zKS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGVuc2l0eVxuICAgICAqL1xuICAgIHRoaXMuZGVuc2l0eSA9IDE7XG5cdFxuICAgIC8qKlxuICAgICAqIERpc3RhbmNlIGJlbG93IHdoaWNoIHR3byBwYXJ0aWNsZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgbmVpZ2hib3JzLlxuICAgICAqIEl0IHNob3VsZCBiZSBhZGp1c3RlZCBzbyB0aGVyZSBhcmUgYWJvdXQgMTUtMjAgbmVpZ2hib3IgcGFydGljbGVzIHdpdGhpbiB0aGlzIHJhZGl1cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc21vb3RoaW5nUmFkaXVzXG4gICAgICovXG4gICAgdGhpcy5zbW9vdGhpbmdSYWRpdXMgPSAxO1xuICAgIHRoaXMuc3BlZWRPZlNvdW5kID0gMTtcblx0XG4gICAgLyoqXG4gICAgICogVmlzY29zaXR5IG9mIHRoZSBzeXN0ZW0uXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZpc2Nvc2l0eVxuICAgICAqL1xuICAgIHRoaXMudmlzY29zaXR5ID0gMC4wMTtcbiAgICB0aGlzLmVwcyA9IDAuMDAwMDAxO1xuXG4gICAgLy8gU3R1ZmYgQ29tcHV0ZWQgcGVyIHBhcnRpY2xlXG4gICAgdGhpcy5wcmVzc3VyZXMgPSBbXTtcbiAgICB0aGlzLmRlbnNpdGllcyA9IFtdO1xuICAgIHRoaXMubmVpZ2hib3JzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgcGFydGljbGUgdG8gdGhlIHN5c3RlbS5cbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge0JvZHl9IHBhcnRpY2xlXG4gKi9cblNQSFN5c3RlbS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocGFydGljbGUpe1xuICAgIHRoaXMucGFydGljbGVzLnB1c2gocGFydGljbGUpO1xuICAgIGlmKHRoaXMubmVpZ2hib3JzLmxlbmd0aCA8IHRoaXMucGFydGljbGVzLmxlbmd0aCl7XG4gICAgICAgIHRoaXMubmVpZ2hib3JzLnB1c2goW10pO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgcGFydGljbGUgZnJvbSB0aGUgc3lzdGVtLlxuICogQG1ldGhvZCByZW1vdmVcbiAqIEBwYXJhbSB7Qm9keX0gcGFydGljbGVcbiAqL1xuU1BIU3lzdGVtLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihwYXJ0aWNsZSl7XG4gICAgdmFyIGlkeCA9IHRoaXMucGFydGljbGVzLmluZGV4T2YocGFydGljbGUpO1xuICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICB0aGlzLnBhcnRpY2xlcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICBpZih0aGlzLm5laWdoYm9ycy5sZW5ndGggPiB0aGlzLnBhcnRpY2xlcy5sZW5ndGgpe1xuICAgICAgICAgICAgdGhpcy5uZWlnaGJvcnMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBuZWlnaGJvcnMgd2l0aGluIHNtb290aGluZyB2b2x1bWUsIHNhdmUgaW4gdGhlIGFycmF5IG5laWdoYm9yc1xuICogQG1ldGhvZCBnZXROZWlnaGJvcnNcbiAqIEBwYXJhbSB7Qm9keX0gcGFydGljbGVcbiAqIEBwYXJhbSB7QXJyYXl9IG5laWdoYm9yc1xuICovXG52YXIgU1BIU3lzdGVtX2dldE5laWdoYm9yc19kaXN0ID0gbmV3IFZlYzMoKTtcblNQSFN5c3RlbS5wcm90b3R5cGUuZ2V0TmVpZ2hib3JzID0gZnVuY3Rpb24ocGFydGljbGUsbmVpZ2hib3JzKXtcbiAgICB2YXIgTiA9IHRoaXMucGFydGljbGVzLmxlbmd0aCxcbiAgICAgICAgaWQgPSBwYXJ0aWNsZS5pZCxcbiAgICAgICAgUjIgPSB0aGlzLnNtb290aGluZ1JhZGl1cyAqIHRoaXMuc21vb3RoaW5nUmFkaXVzLFxuICAgICAgICBkaXN0ID0gU1BIU3lzdGVtX2dldE5laWdoYm9yc19kaXN0O1xuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBhcnRpY2xlc1tpXTtcbiAgICAgICAgcC5wb3NpdGlvbi52c3ViKHBhcnRpY2xlLnBvc2l0aW9uLGRpc3QpO1xuICAgICAgICBpZihpZCE9PXAuaWQgJiYgZGlzdC5ub3JtMigpIDwgUjIpe1xuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBUZW1wIHZlY3RvcnMgZm9yIGNhbGN1bGF0aW9uXG52YXIgU1BIU3lzdGVtX3VwZGF0ZV9kaXN0ID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX2FfcHJlc3N1cmUgPSBuZXcgVmVjMygpLFxuICAgIFNQSFN5c3RlbV91cGRhdGVfYV92aXNjID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX2dyYWRXID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX3JfdmVjID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX3UgPSBuZXcgVmVjMygpOyAvLyBSZWxhdGl2ZSB2ZWxvY2l0eVxuU1BIU3lzdGVtLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBOID0gdGhpcy5wYXJ0aWNsZXMubGVuZ3RoLFxuICAgICAgICBkaXN0ID0gU1BIU3lzdGVtX3VwZGF0ZV9kaXN0LFxuICAgICAgICBjcyA9IHRoaXMuc3BlZWRPZlNvdW5kLFxuICAgICAgICBlcHMgPSB0aGlzLmVwcztcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBhcnRpY2xlc1tpXTsgLy8gQ3VycmVudCBwYXJ0aWNsZVxuICAgICAgICB2YXIgbmVpZ2hib3JzID0gdGhpcy5uZWlnaGJvcnNbaV07XG5cbiAgICAgICAgLy8gR2V0IG5laWdoYm9yc1xuICAgICAgICBuZWlnaGJvcnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5nZXROZWlnaGJvcnMocCxuZWlnaGJvcnMpO1xuICAgICAgICBuZWlnaGJvcnMucHVzaCh0aGlzLnBhcnRpY2xlc1tpXSk7IC8vIEFkZCBjdXJyZW50IHRvb1xuICAgICAgICB2YXIgbnVtTmVpZ2hib3JzID0gbmVpZ2hib3JzLmxlbmd0aDtcblxuICAgICAgICAvLyBBY2N1bXVsYXRlIGRlbnNpdHkgZm9yIHRoZSBwYXJ0aWNsZVxuICAgICAgICB2YXIgc3VtID0gMC4wO1xuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PW51bU5laWdoYm9yczsgaisrKXtcblxuICAgICAgICAgICAgLy9wcmludGYoXCJDdXJyZW50IHBhcnRpY2xlIGhhcyBwb3NpdGlvbiAlZiAlZiAlZlxcblwiLG9iamVjdHNbaWRdLnBvcy54KCksb2JqZWN0c1tpZF0ucG9zLnkoKSxvYmplY3RzW2lkXS5wb3MueigpKTtcbiAgICAgICAgICAgIHAucG9zaXRpb24udnN1YihuZWlnaGJvcnNbal0ucG9zaXRpb24sIGRpc3QpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGRpc3Qubm9ybSgpO1xuXG4gICAgICAgICAgICB2YXIgd2VpZ2h0ID0gdGhpcy53KGxlbik7XG4gICAgICAgICAgICBzdW0gKz0gbmVpZ2hib3JzW2pdLm1hc3MgKiB3ZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlXG4gICAgICAgIHRoaXMuZGVuc2l0aWVzW2ldID0gc3VtO1xuICAgICAgICB0aGlzLnByZXNzdXJlc1tpXSA9IGNzICogY3MgKiAodGhpcy5kZW5zaXRpZXNbaV0gLSB0aGlzLmRlbnNpdHkpO1xuICAgIH1cblxuICAgIC8vIEFkZCBmb3JjZXNcblxuICAgIC8vIFN1bSB0byB0aGVzZSBhY2NlbGVyYXRpb25zXG4gICAgdmFyIGFfcHJlc3N1cmU9IFNQSFN5c3RlbV91cGRhdGVfYV9wcmVzc3VyZTtcbiAgICB2YXIgYV92aXNjID0gICAgU1BIU3lzdGVtX3VwZGF0ZV9hX3Zpc2M7XG4gICAgdmFyIGdyYWRXID0gICAgIFNQSFN5c3RlbV91cGRhdGVfZ3JhZFc7XG4gICAgdmFyIHJfdmVjID0gICAgIFNQSFN5c3RlbV91cGRhdGVfcl92ZWM7XG4gICAgdmFyIHUgPSAgICAgICAgIFNQSFN5c3RlbV91cGRhdGVfdTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcblxuICAgICAgICB2YXIgcGFydGljbGUgPSB0aGlzLnBhcnRpY2xlc1tpXTtcblxuICAgICAgICBhX3ByZXNzdXJlLnNldCgwLDAsMCk7XG4gICAgICAgIGFfdmlzYy5zZXQoMCwwLDApO1xuXG4gICAgICAgIC8vIEluaXQgdmFyc1xuICAgICAgICB2YXIgUGlqO1xuICAgICAgICB2YXIgbmFibGE7XG4gICAgICAgIHZhciBWaWo7XG5cbiAgICAgICAgLy8gU3VtIHVwIGZvciBhbGwgb3RoZXIgbmVpZ2hib3JzXG4gICAgICAgIHZhciBuZWlnaGJvcnMgPSB0aGlzLm5laWdoYm9yc1tpXTtcbiAgICAgICAgdmFyIG51bU5laWdoYm9ycyA9IG5laWdoYm9ycy5sZW5ndGg7XG5cbiAgICAgICAgLy9wcmludGYoXCJOZWlnaGJvcnM6IFwiKTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT1udW1OZWlnaGJvcnM7IGorKyl7XG5cbiAgICAgICAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tqXTtcbiAgICAgICAgICAgIC8vcHJpbnRmKFwiJWQgXCIsbmopO1xuXG4gICAgICAgICAgICAvLyBHZXQgciBvbmNlIGZvciBhbGwuLlxuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24udnN1YihuZWlnaGJvci5wb3NpdGlvbixyX3ZlYyk7XG4gICAgICAgICAgICB2YXIgciA9IHJfdmVjLm5vcm0oKTtcblxuICAgICAgICAgICAgLy8gUHJlc3N1cmUgY29udHJpYnV0aW9uXG4gICAgICAgICAgICBQaWogPSAtbmVpZ2hib3IubWFzcyAqICh0aGlzLnByZXNzdXJlc1tpXSAvICh0aGlzLmRlbnNpdGllc1tpXSp0aGlzLmRlbnNpdGllc1tpXSArIGVwcykgKyB0aGlzLnByZXNzdXJlc1tqXSAvICh0aGlzLmRlbnNpdGllc1tqXSp0aGlzLmRlbnNpdGllc1tqXSArIGVwcykpO1xuICAgICAgICAgICAgdGhpcy5ncmFkdyhyX3ZlYywgZ3JhZFcpO1xuICAgICAgICAgICAgLy8gQWRkIHRvIHByZXNzdXJlIGFjY2VsZXJhdGlvblxuICAgICAgICAgICAgZ3JhZFcubXVsdChQaWogLCBncmFkVyk7XG4gICAgICAgICAgICBhX3ByZXNzdXJlLnZhZGQoZ3JhZFcsIGFfcHJlc3N1cmUpO1xuXG4gICAgICAgICAgICAvLyBWaXNjb3NpdHkgY29udHJpYnV0aW9uXG4gICAgICAgICAgICBuZWlnaGJvci52ZWxvY2l0eS52c3ViKHBhcnRpY2xlLnZlbG9jaXR5LCB1KTtcbiAgICAgICAgICAgIHUubXVsdCggMS4wIC8gKDAuMDAwMSt0aGlzLmRlbnNpdGllc1tpXSAqIHRoaXMuZGVuc2l0aWVzW2pdKSAqIHRoaXMudmlzY29zaXR5ICogbmVpZ2hib3IubWFzcyAsIHUgKTtcbiAgICAgICAgICAgIG5hYmxhID0gdGhpcy5uYWJsYXcocik7XG4gICAgICAgICAgICB1Lm11bHQobmFibGEsdSk7XG4gICAgICAgICAgICAvLyBBZGQgdG8gdmlzY29zaXR5IGFjY2VsZXJhdGlvblxuICAgICAgICAgICAgYV92aXNjLnZhZGQoIHUsIGFfdmlzYyApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGZvcmNlXG4gICAgICAgIGFfdmlzYy5tdWx0KHBhcnRpY2xlLm1hc3MsIGFfdmlzYyk7XG4gICAgICAgIGFfcHJlc3N1cmUubXVsdChwYXJ0aWNsZS5tYXNzLCBhX3ByZXNzdXJlKTtcblxuICAgICAgICAvLyBBZGQgZm9yY2UgdG8gcGFydGljbGVzXG4gICAgICAgIHBhcnRpY2xlLmZvcmNlLnZhZGQoYV92aXNjLCBwYXJ0aWNsZS5mb3JjZSk7XG4gICAgICAgIHBhcnRpY2xlLmZvcmNlLnZhZGQoYV9wcmVzc3VyZSwgcGFydGljbGUuZm9yY2UpO1xuICAgIH1cbn07XG5cbi8vIENhbGN1bGF0ZSB0aGUgd2VpZ2h0IHVzaW5nIHRoZSBXKHIpIHdlaWdodGZ1bmN0aW9uXG5TUEhTeXN0ZW0ucHJvdG90eXBlLncgPSBmdW5jdGlvbihyKXtcbiAgICAvLyAzMTVcbiAgICB2YXIgaCA9IHRoaXMuc21vb3RoaW5nUmFkaXVzO1xuICAgIHJldHVybiAzMTUuMC8oNjQuMCpNYXRoLlBJKk1hdGgucG93KGgsOSkpICogTWF0aC5wb3coaCpoLXIqciwzKTtcbn07XG5cbi8vIGNhbGN1bGF0ZSBncmFkaWVudCBvZiB0aGUgd2VpZ2h0IGZ1bmN0aW9uXG5TUEhTeXN0ZW0ucHJvdG90eXBlLmdyYWR3ID0gZnVuY3Rpb24oclZlYyxyZXN1bHRWZWMpe1xuICAgIHZhciByID0gclZlYy5ub3JtKCksXG4gICAgICAgIGggPSB0aGlzLnNtb290aGluZ1JhZGl1cztcbiAgICByVmVjLm11bHQoOTQ1LjAvKDMyLjAqTWF0aC5QSSpNYXRoLnBvdyhoLDkpKSAqIE1hdGgucG93KChoKmgtcipyKSwyKSAsIHJlc3VsdFZlYyk7XG59O1xuXG4vLyBDYWxjdWxhdGUgbmFibGEoVylcblNQSFN5c3RlbS5wcm90b3R5cGUubmFibGF3ID0gZnVuY3Rpb24ocil7XG4gICAgdmFyIGggPSB0aGlzLnNtb290aGluZ1JhZGl1cztcbiAgICB2YXIgbmFibGEgPSA5NDUuMC8oMzIuMCpNYXRoLlBJKk1hdGgucG93KGgsOSkpICogKGgqaC1yKnIpKig3KnIqciAtIDMqaCpoKTtcbiAgICByZXR1cm4gbmFibGE7XG59O1xuIiwidmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpbmc7XG5cbi8qKlxuICogQSBzcHJpbmcsIGNvbm5lY3RpbmcgdHdvIGJvZGllcy5cbiAqXG4gKiBAY2xhc3MgU3ByaW5nXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXN0TGVuZ3RoXSAgIEEgbnVtYmVyID4gMC4gRGVmYXVsdDogMVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzc10gICAgQSBudW1iZXIgPj0gMC4gRGVmYXVsdDogMTAwXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZ10gICAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxXG4gKiBAcGFyYW0ge1ZlYzN9ICBbb3B0aW9ucy53b3JsZEFuY2hvckFdIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMud29ybGRBbmNob3JCXVxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMubG9jYWxBbmNob3JBXSBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiBsb2NhbCBib2R5IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMubG9jYWxBbmNob3JCXVxuICovXG5mdW5jdGlvbiBTcHJpbmcoYm9keUEsYm9keUIsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBSZXN0IGxlbmd0aCBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0TGVuZ3RoXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RMZW5ndGggPSB0eXBlb2Yob3B0aW9ucy5yZXN0TGVuZ3RoKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucmVzdExlbmd0aCA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0aWZmbmVzcyA9IG9wdGlvbnMuc3RpZmZuZXNzIHx8IDEwMDtcblxuICAgIC8qKlxuICAgICAqIERhbXBpbmcgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgZGFtcGluZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kYW1waW5nID0gb3B0aW9ucy5kYW1waW5nIHx8IDE7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBjb25uZWN0ZWQgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgYm9keUFcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgY29ubmVjdGVkIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGJvZHlCXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9yIGZvciBib2R5QSBpbiBsb2NhbCBib2R5QSBjb29yZGluYXRlcy5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JBXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckEgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9yIGZvciBib2R5QiBpbiBsb2NhbCBib2R5QiBjb29yZGluYXRlcy5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JCXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckEpe1xuICAgICAgICB0aGlzLmxvY2FsQW5jaG9yQS5jb3B5KG9wdGlvbnMubG9jYWxBbmNob3JBKTtcbiAgICB9XG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckIpe1xuICAgICAgICB0aGlzLmxvY2FsQW5jaG9yQi5jb3B5KG9wdGlvbnMubG9jYWxBbmNob3JCKTtcbiAgICB9XG4gICAgaWYob3B0aW9ucy53b3JsZEFuY2hvckEpe1xuICAgICAgICB0aGlzLnNldFdvcmxkQW5jaG9yQShvcHRpb25zLndvcmxkQW5jaG9yQSk7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMud29ybGRBbmNob3JCKXtcbiAgICAgICAgdGhpcy5zZXRXb3JsZEFuY2hvckIob3B0aW9ucy53b3JsZEFuY2hvckIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBzZXRXb3JsZEFuY2hvckFcbiAqIEBwYXJhbSB7VmVjM30gd29ybGRBbmNob3JBXG4gKi9cblNwcmluZy5wcm90b3R5cGUuc2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24od29ybGRBbmNob3JBKXtcbiAgICB0aGlzLmJvZHlBLnBvaW50VG9Mb2NhbEZyYW1lKHdvcmxkQW5jaG9yQSx0aGlzLmxvY2FsQW5jaG9yQSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtWZWMzfSB3b3JsZEFuY2hvckJcbiAqL1xuU3ByaW5nLnByb3RvdHlwZS5zZXRXb3JsZEFuY2hvckIgPSBmdW5jdGlvbih3b3JsZEFuY2hvckIpe1xuICAgIHRoaXMuYm9keUIucG9pbnRUb0xvY2FsRnJhbWUod29ybGRBbmNob3JCLHRoaXMubG9jYWxBbmNob3JCKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JBXG4gKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdCBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXG4gKi9cblNwcmluZy5wcm90b3R5cGUuZ2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB0aGlzLmJvZHlBLnBvaW50VG9Xb3JsZEZyYW1lKHRoaXMubG9jYWxBbmNob3JBLHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIGdldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtWZWMzfSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxuICovXG5TcHJpbmcucHJvdG90eXBlLmdldFdvcmxkQW5jaG9yQiA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdGhpcy5ib2R5Qi5wb2ludFRvV29ybGRGcmFtZSh0aGlzLmxvY2FsQW5jaG9yQixyZXN1bHQpO1xufTtcblxudmFyIGFwcGx5Rm9yY2VfciA9ICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2Vfcl91bml0ID0gICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfdSA9ICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfZiA9ICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBID0gICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCID0gICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmkgPSAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmogPSAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmlfeF9mID0gICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmpfeF9mID0gICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfdG1wID0gICAgICAgICAgICBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqL1xuU3ByaW5nLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLFxuICAgICAgICBkID0gdGhpcy5kYW1waW5nLFxuICAgICAgICBsID0gdGhpcy5yZXN0TGVuZ3RoLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgciA9IGFwcGx5Rm9yY2VfcixcbiAgICAgICAgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQsXG4gICAgICAgIHUgPSBhcHBseUZvcmNlX3UsXG4gICAgICAgIGYgPSBhcHBseUZvcmNlX2YsXG4gICAgICAgIHRtcCA9IGFwcGx5Rm9yY2VfdG1wO1xuXG4gICAgdmFyIHdvcmxkQW5jaG9yQSA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBLFxuICAgICAgICB3b3JsZEFuY2hvckIgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQixcbiAgICAgICAgcmkgPSBhcHBseUZvcmNlX3JpLFxuICAgICAgICByaiA9IGFwcGx5Rm9yY2VfcmosXG4gICAgICAgIHJpX3hfZiA9IGFwcGx5Rm9yY2VfcmlfeF9mLFxuICAgICAgICByal94X2YgPSBhcHBseUZvcmNlX3JqX3hfZjtcblxuICAgIC8vIEdldCB3b3JsZCBhbmNob3JzXG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckEod29ybGRBbmNob3JBKTtcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xuXG4gICAgLy8gR2V0IG9mZnNldCBwb2ludHNcbiAgICB3b3JsZEFuY2hvckEudnN1Yihib2R5QS5wb3NpdGlvbixyaSk7XG4gICAgd29ybGRBbmNob3JCLnZzdWIoYm9keUIucG9zaXRpb24scmopO1xuXG4gICAgLy8gQ29tcHV0ZSBkaXN0YW5jZSB2ZWN0b3IgYmV0d2VlbiB3b3JsZCBhbmNob3IgcG9pbnRzXG4gICAgd29ybGRBbmNob3JCLnZzdWIod29ybGRBbmNob3JBLHIpO1xuICAgIHZhciBybGVuID0gci5ub3JtKCk7XG4gICAgcl91bml0LmNvcHkocik7XG4gICAgcl91bml0Lm5vcm1hbGl6ZSgpO1xuXG4gICAgLy8gQ29tcHV0ZSByZWxhdGl2ZSB2ZWxvY2l0eSBvZiB0aGUgYW5jaG9yIHBvaW50cywgdVxuICAgIGJvZHlCLnZlbG9jaXR5LnZzdWIoYm9keUEudmVsb2NpdHksdSk7XG4gICAgLy8gQWRkIHJvdGF0aW9uYWwgdmVsb2NpdHlcblxuICAgIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eS5jcm9zcyhyaix0bXApO1xuICAgIHUudmFkZCh0bXAsdSk7XG4gICAgYm9keUEuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHJpLHRtcCk7XG4gICAgdS52c3ViKHRtcCx1KTtcblxuICAgIC8vIEYgPSAtIGsgKiAoIHggLSBMICkgLSBEICogKCB1IClcbiAgICByX3VuaXQubXVsdCgtayoocmxlbi1sKSAtIGQqdS5kb3Qocl91bml0KSwgZik7XG5cbiAgICAvLyBBZGQgZm9yY2VzIHRvIGJvZGllc1xuICAgIGJvZHlBLmZvcmNlLnZzdWIoZixib2R5QS5mb3JjZSk7XG4gICAgYm9keUIuZm9yY2UudmFkZChmLGJvZHlCLmZvcmNlKTtcblxuICAgIC8vIEFuZ3VsYXIgZm9yY2VcbiAgICByaS5jcm9zcyhmLHJpX3hfZik7XG4gICAgcmouY3Jvc3MoZixyal94X2YpO1xuICAgIGJvZHlBLnRvcnF1ZS52c3ViKHJpX3hfZixib2R5QS50b3JxdWUpO1xuICAgIGJvZHlCLnRvcnF1ZS52YWRkKHJqX3hfZixib2R5Qi50b3JxdWUpO1xufTtcbiIsInZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcbnZhciBSYXljYXN0UmVzdWx0ID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKTtcbnZhciBVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2hlZWxJbmZvO1xuXG4vKipcbiAqIEBjbGFzcyBXaGVlbEluZm9cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICpcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGRdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmRpcmVjdGlvbkxvY2FsXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5kaXJlY3Rpb25Xb3JsZF1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhsZUxvY2FsXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGxlV29ybGRdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvblJlc3RMZW5ndGg9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoPTJdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmFkaXVzPTFdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvblN0aWZmbmVzcz0xMDBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZ0NvbXByZXNzaW9uPTEwXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmdSZWxheGF0aW9uPTEwXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmZyaWN0aW9uU2xpcD0xMDAwMF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGVlcmluZz0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJvdGF0aW9uPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGVsdGFSb3RhdGlvbj0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJvbGxJbmZsdWVuY2U9MC4wMV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhTdXNwZW5zaW9uRm9yY2VdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzRnJvbnRXaGVlbD10cnVlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbj0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvbkZvcmNlPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2tpZEluZm89MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdXNwZW5zaW9uTGVuZ3RoPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4U3VzcGVuc2lvblRyYXZlbD0xXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkPWZhbHNlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQ9LTAuMV1cbiAqL1xuZnVuY3Rpb24gV2hlZWxJbmZvKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbDogbmV3IFZlYzMoKSxcbiAgICAgICAgY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkOiBuZXcgVmVjMygpLFxuICAgICAgICBkaXJlY3Rpb25Mb2NhbDogbmV3IFZlYzMoKSxcbiAgICAgICAgZGlyZWN0aW9uV29ybGQ6IG5ldyBWZWMzKCksXG4gICAgICAgIGF4bGVMb2NhbDogbmV3IFZlYzMoKSxcbiAgICAgICAgYXhsZVdvcmxkOiBuZXcgVmVjMygpLFxuICAgICAgICBzdXNwZW5zaW9uUmVzdExlbmd0aDogMSxcbiAgICAgICAgc3VzcGVuc2lvbk1heExlbmd0aDogMixcbiAgICAgICAgcmFkaXVzOiAxLFxuICAgICAgICBzdXNwZW5zaW9uU3RpZmZuZXNzOiAxMDAsXG4gICAgICAgIGRhbXBpbmdDb21wcmVzc2lvbjogMTAsXG4gICAgICAgIGRhbXBpbmdSZWxheGF0aW9uOiAxMCxcbiAgICAgICAgZnJpY3Rpb25TbGlwOiAxMDAwMCxcbiAgICAgICAgc3RlZXJpbmc6IDAsXG4gICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICBkZWx0YVJvdGF0aW9uOiAwLFxuICAgICAgICByb2xsSW5mbHVlbmNlOiAwLjAxLFxuICAgICAgICBtYXhTdXNwZW5zaW9uRm9yY2U6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIGlzRnJvbnRXaGVlbDogdHJ1ZSxcbiAgICAgICAgY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uOiAxLFxuICAgICAgICBzdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eTogMCxcbiAgICAgICAgc3VzcGVuc2lvbkZvcmNlOiAwLFxuICAgICAgICBza2lkSW5mbzogMCxcbiAgICAgICAgc3VzcGVuc2lvbkxlbmd0aDogMCxcbiAgICAgICAgbWF4U3VzcGVuc2lvblRyYXZlbDogMSxcbiAgICAgICAgdXNlQ3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZDogZmFsc2UsXG4gICAgICAgIGN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQ6IC0wLjFcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE1heCB0cmF2ZWwgZGlzdGFuY2Ugb2YgdGhlIHN1c3BlbnNpb24sIGluIG1ldGVycy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4U3VzcGVuc2lvblRyYXZlbFxuICAgICAqL1xuICAgIHRoaXMubWF4U3VzcGVuc2lvblRyYXZlbCA9IG9wdGlvbnMubWF4U3VzcGVuc2lvblRyYXZlbDtcblxuICAgIC8qKlxuICAgICAqIFNwZWVkIHRvIGFwcGx5IHRvIHRoZSB3aGVlbCByb3RhdGlvbiB3aGVuIHRoZSB3aGVlbCBpcyBzbGlkaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkXG4gICAgICovXG4gICAgdGhpcy5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkID0gb3B0aW9ucy5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQgc2hvdWxkIGJlIHVzZWQuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkXG4gICAgICovXG4gICAgdGhpcy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkID0gb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzbGlkaW5nXG4gICAgICovXG4gICAgdGhpcy5zbGlkaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0aW9uIHBvaW50LCBkZWZpbmVkIGxvY2FsbHkgaW4gdGhlIGNoYXNzaXMgYm9keSBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbFxuICAgICAqL1xuICAgIHRoaXMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsID0gb3B0aW9ucy5jaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWwuY2xvbmUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkXG4gICAgICovXG4gICAgdGhpcy5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQgPSBvcHRpb25zLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBkaXJlY3Rpb25Mb2NhbFxuICAgICAqL1xuICAgIHRoaXMuZGlyZWN0aW9uTG9jYWwgPSBvcHRpb25zLmRpcmVjdGlvbkxvY2FsLmNsb25lKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGRpcmVjdGlvbldvcmxkXG4gICAgICovXG4gICAgdGhpcy5kaXJlY3Rpb25Xb3JsZCA9IG9wdGlvbnMuZGlyZWN0aW9uV29ybGQuY2xvbmUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhsZUxvY2FsXG4gICAgICovXG4gICAgdGhpcy5heGxlTG9jYWwgPSBvcHRpb25zLmF4bGVMb2NhbC5jbG9uZSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBheGxlV29ybGRcbiAgICAgKi9cbiAgICB0aGlzLmF4bGVXb3JsZCA9IG9wdGlvbnMuYXhsZVdvcmxkLmNsb25lKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvblJlc3RMZW5ndGhcbiAgICAgKi9cbiAgICB0aGlzLnN1c3BlbnNpb25SZXN0TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uUmVzdExlbmd0aDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdXNwZW5zaW9uTWF4TGVuZ3RoXG4gICAgICovXG4gICAgdGhpcy5zdXNwZW5zaW9uTWF4TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGl1c1xuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvblN0aWZmbmVzc1xuICAgICAqL1xuICAgIHRoaXMuc3VzcGVuc2lvblN0aWZmbmVzcyA9IG9wdGlvbnMuc3VzcGVuc2lvblN0aWZmbmVzcztcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYW1waW5nQ29tcHJlc3Npb25cbiAgICAgKi9cbiAgICB0aGlzLmRhbXBpbmdDb21wcmVzc2lvbiA9IG9wdGlvbnMuZGFtcGluZ0NvbXByZXNzaW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhbXBpbmdSZWxheGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5kYW1waW5nUmVsYXhhdGlvbiA9IG9wdGlvbnMuZGFtcGluZ1JlbGF4YXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZnJpY3Rpb25TbGlwXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvblNsaXAgPSBvcHRpb25zLmZyaWN0aW9uU2xpcDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGVlcmluZ1xuICAgICAqL1xuICAgIHRoaXMuc3RlZXJpbmcgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUm90YXRpb24gdmFsdWUsIGluIHJhZGlhbnMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJvdGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGVsdGFSb3RhdGlvblxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFSb3RhdGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcm9sbEluZmx1ZW5jZVxuICAgICAqL1xuICAgIHRoaXMucm9sbEluZmx1ZW5jZSA9IG9wdGlvbnMucm9sbEluZmx1ZW5jZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhTdXNwZW5zaW9uRm9yY2VcbiAgICAgKi9cbiAgICB0aGlzLm1heFN1c3BlbnNpb25Gb3JjZSA9IG9wdGlvbnMubWF4U3VzcGVuc2lvbkZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZ2luZUZvcmNlXG4gICAgICovXG4gICAgdGhpcy5lbmdpbmVGb3JjZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYnJha2VcbiAgICAgKi9cbiAgICB0aGlzLmJyYWtlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpc0Zyb250V2hlZWxcbiAgICAgKi9cbiAgICB0aGlzLmlzRnJvbnRXaGVlbCA9IG9wdGlvbnMuaXNGcm9udFdoZWVsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvblxuICAgICAqL1xuICAgIHRoaXMuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eVxuICAgICAqL1xuICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN1c3BlbnNpb25Gb3JjZVxuICAgICAqL1xuICAgIHRoaXMuc3VzcGVuc2lvbkZvcmNlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBza2lkSW5mb1xuICAgICAqL1xuICAgIHRoaXMuc2tpZEluZm8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN1c3BlbnNpb25MZW5ndGhcbiAgICAgKi9cbiAgICB0aGlzLnN1c3BlbnNpb25MZW5ndGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZGVJbXB1bHNlXG4gICAgICovXG4gICAgdGhpcy5zaWRlSW1wdWxzZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZm9yd2FyZEltcHVsc2VcbiAgICAgKi9cbiAgICB0aGlzLmZvcndhcmRJbXB1bHNlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHQgZnJvbSByYXljYXN0aW5nXG4gICAgICogQHByb3BlcnR5IHtSYXljYXN0UmVzdWx0fSByYXljYXN0UmVzdWx0XG4gICAgICovXG4gICAgdGhpcy5yYXljYXN0UmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTtcblxuICAgIC8qKlxuICAgICAqIFdoZWVsIHdvcmxkIHRyYW5zZm9ybVxuICAgICAqIEBwcm9wZXJ0eSB7VHJhbnNmb3JtfSB3b3JsZFRyYW5zZm9ybVxuICAgICAqL1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzSW5Db250YWN0XG4gICAgICovXG4gICAgdGhpcy5pc0luQ29udGFjdCA9IGZhbHNlO1xufVxuXG52YXIgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQgPSBuZXcgVmVjMygpO1xudmFyIHJlbHBvcyA9IG5ldyBWZWMzKCk7XG52YXIgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQgPSBuZXcgVmVjMygpO1xuV2hlZWxJbmZvLnByb3RvdHlwZS51cGRhdGVXaGVlbCA9IGZ1bmN0aW9uKGNoYXNzaXMpe1xuICAgIHZhciByYXljYXN0UmVzdWx0ID0gdGhpcy5yYXljYXN0UmVzdWx0O1xuXG4gICAgaWYgKHRoaXMuaXNJbkNvbnRhY3Qpe1xuICAgICAgICB2YXIgcHJvamVjdD0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QocmF5Y2FzdFJlc3VsdC5kaXJlY3Rpb25Xb3JsZCk7XG4gICAgICAgIHJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXMucG9zaXRpb24sIHJlbHBvcyk7XG4gICAgICAgIGNoYXNzaXMuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocmVscG9zLCBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCk7XG4gICAgICAgIHZhciBwcm9qVmVsID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QoIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ICk7XG4gICAgICAgIGlmIChwcm9qZWN0ID49IC0wLjEpIHtcbiAgICAgICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMCAvIDAuMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnYgPSAtMSAvIHByb2plY3Q7XG4gICAgICAgICAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gcHJvalZlbCAqIGludjtcbiAgICAgICAgICAgIHRoaXMuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gaW52O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgaW4gY29udGFjdCA6IHBvc2l0aW9uIHdoZWVsIGluIGEgbmljZSAocmVzdCBsZW5ndGgpIHBvc2l0aW9uXG4gICAgICAgIHJheWNhc3RSZXN1bHQuc3VzcGVuc2lvbkxlbmd0aCA9IHRoaXMuc3VzcGVuc2lvblJlc3RMZW5ndGg7XG4gICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7XG4gICAgICAgIHJheWNhc3RSZXN1bHQuZGlyZWN0aW9uV29ybGQuc2NhbGUoLTEsIHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQpO1xuICAgICAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMDtcbiAgICB9XG59OyIsIm1vZHVsZS5leHBvcnRzID0gQm94O1xuXG52YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIENvbnZleFBvbHloZWRyb24gPSByZXF1aXJlKCcuL0NvbnZleFBvbHloZWRyb24nKTtcblxuLyoqXG4gKiBBIDNkIGJveCBzaGFwZS5cbiAqIEBjbGFzcyBCb3hcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtWZWMzfSBoYWxmRXh0ZW50c1xuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQGV4dGVuZHMgU2hhcGVcbiAqL1xuZnVuY3Rpb24gQm94KGhhbGZFeHRlbnRzKXtcbiAgICBTaGFwZS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy50eXBlID0gU2hhcGUudHlwZXMuQk9YO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGhhbGZFeHRlbnRzXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5oYWxmRXh0ZW50cyA9IGhhbGZFeHRlbnRzO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSB0aGUgY29udGFjdCBnZW5lcmF0b3IgdG8gbWFrZSBjb250YWN0cyB3aXRoIG90aGVyIGNvbnZleCBwb2x5aGVkcmEgZm9yIGV4YW1wbGVcbiAgICAgKiBAcHJvcGVydHkgY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uXG4gICAgICogQHR5cGUge0NvbnZleFBvbHloZWRyb259XG4gICAgICovXG4gICAgdGhpcy5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24gPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVDb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG59XG5Cb3gucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5Cb3gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGxvY2FsIGNvbnZleCBwb2x5aGVkcm9uIHJlcHJlc2VudGF0aW9uIHVzZWQgZm9yIHNvbWUgY29sbGlzaW9ucy5cbiAqIEBtZXRob2QgdXBkYXRlQ29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uXG4gKi9cbkJveC5wcm90b3R5cGUudXBkYXRlQ29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgc3ggPSB0aGlzLmhhbGZFeHRlbnRzLng7XG4gICAgdmFyIHN5ID0gdGhpcy5oYWxmRXh0ZW50cy55O1xuICAgIHZhciBzeiA9IHRoaXMuaGFsZkV4dGVudHMuejtcbiAgICB2YXIgViA9IFZlYzM7XG5cbiAgICB2YXIgdmVydGljZXMgPSBbXG4gICAgICAgIG5ldyBWKC1zeCwtc3ksLXN6KSxcbiAgICAgICAgbmV3IFYoIHN4LC1zeSwtc3opLFxuICAgICAgICBuZXcgViggc3gsIHN5LC1zeiksXG4gICAgICAgIG5ldyBWKC1zeCwgc3ksLXN6KSxcbiAgICAgICAgbmV3IFYoLXN4LC1zeSwgc3opLFxuICAgICAgICBuZXcgViggc3gsLXN5LCBzeiksXG4gICAgICAgIG5ldyBWKCBzeCwgc3ksIHN6KSxcbiAgICAgICAgbmV3IFYoLXN4LCBzeSwgc3opXG4gICAgXTtcblxuICAgIHZhciBpbmRpY2VzID0gW1xuICAgICAgICBbMywyLDEsMF0sIC8vIC16XG4gICAgICAgIFs0LDUsNiw3XSwgLy8gK3pcbiAgICAgICAgWzUsNCwwLDFdLCAvLyAteVxuICAgICAgICBbMiwzLDcsNl0sIC8vICt5XG4gICAgICAgIFswLDQsNywzXSwgLy8gLXhcbiAgICAgICAgWzEsMiw2LDVdLCAvLyAreFxuICAgIF07XG5cbiAgICB2YXIgYXhlcyA9IFtcbiAgICAgICAgbmV3IFYoMCwgMCwgMSksXG4gICAgICAgIG5ldyBWKDAsIDEsIDApLFxuICAgICAgICBuZXcgVigxLCAwLCAwKVxuICAgIF07XG5cbiAgICB2YXIgaCA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKHZlcnRpY2VzLCBpbmRpY2VzKTtcbiAgICB0aGlzLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiA9IGg7XG4gICAgaC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY2FsY3VsYXRlTG9jYWxJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuQm94LnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgQm94LmNhbGN1bGF0ZUluZXJ0aWEodGhpcy5oYWxmRXh0ZW50cywgbWFzcywgdGFyZ2V0KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuQm94LmNhbGN1bGF0ZUluZXJ0aWEgPSBmdW5jdGlvbihoYWxmRXh0ZW50cyxtYXNzLHRhcmdldCl7XG4gICAgdmFyIGUgPSBoYWxmRXh0ZW50cztcbiAgICB0YXJnZXQueCA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAgIDIqZS55KjIqZS55ICsgMiplLnoqMiplLnogKTtcbiAgICB0YXJnZXQueSA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAgIDIqZS54KjIqZS54ICsgMiplLnoqMiplLnogKTtcbiAgICB0YXJnZXQueiA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAgIDIqZS55KjIqZS55ICsgMiplLngqMiplLnggKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBib3ggNiBzaWRlIG5vcm1hbHNcbiAqIEBtZXRob2QgZ2V0U2lkZU5vcm1hbHNcbiAqIEBwYXJhbSB7YXJyYXl9ICAgICAgc2l4VGFyZ2V0VmVjdG9ycyBBbiBhcnJheSBvZiA2IHZlY3RvcnMsIHRvIHN0b3JlIHRoZSByZXN1bHRpbmcgc2lkZSBub3JtYWxzIGluLlxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0ICAgICAgICAgICAgIE9yaWVudGF0aW9uIHRvIGFwcGx5IHRvIHRoZSBub3JtYWwgdmVjdG9ycy4gSWYgbm90IHByb3ZpZGVkLCB0aGUgdmVjdG9ycyB3aWxsIGJlIGluIHJlc3BlY3QgdG8gdGhlIGxvY2FsIGZyYW1lLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbkJveC5wcm90b3R5cGUuZ2V0U2lkZU5vcm1hbHMgPSBmdW5jdGlvbihzaXhUYXJnZXRWZWN0b3JzLHF1YXQpe1xuICAgIHZhciBzaWRlcyA9IHNpeFRhcmdldFZlY3RvcnM7XG4gICAgdmFyIGV4ID0gdGhpcy5oYWxmRXh0ZW50cztcbiAgICBzaWRlc1swXS5zZXQoICBleC54LCAgICAgMCwgICAgIDApO1xuICAgIHNpZGVzWzFdLnNldCggICAgIDAsICBleC55LCAgICAgMCk7XG4gICAgc2lkZXNbMl0uc2V0KCAgICAgMCwgICAgIDAsICBleC56KTtcbiAgICBzaWRlc1szXS5zZXQoIC1leC54LCAgICAgMCwgICAgIDApO1xuICAgIHNpZGVzWzRdLnNldCggICAgIDAsIC1leC55LCAgICAgMCk7XG4gICAgc2lkZXNbNV0uc2V0KCAgICAgMCwgICAgIDAsIC1leC56KTtcblxuICAgIGlmKHF1YXQhPT11bmRlZmluZWQpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PXNpZGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHF1YXQudm11bHQoc2lkZXNbaV0sc2lkZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpZGVzO1xufTtcblxuQm94LnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiA4LjAgKiB0aGlzLmhhbGZFeHRlbnRzLnggKiB0aGlzLmhhbGZFeHRlbnRzLnkgKiB0aGlzLmhhbGZFeHRlbnRzLno7XG59O1xuXG5Cb3gucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gdGhpcy5oYWxmRXh0ZW50cy5ub3JtKCk7XG59O1xuXG52YXIgd29ybGRDb3JuZXJUZW1wUG9zID0gbmV3IFZlYzMoKTtcbnZhciB3b3JsZENvcm5lclRlbXBOZWcgPSBuZXcgVmVjMygpO1xuQm94LnByb3RvdHlwZS5mb3JFYWNoV29ybGRDb3JuZXIgPSBmdW5jdGlvbihwb3MscXVhdCxjYWxsYmFjayl7XG5cbiAgICB2YXIgZSA9IHRoaXMuaGFsZkV4dGVudHM7XG4gICAgdmFyIGNvcm5lcnMgPSBbWyAgZS54LCAgZS55LCAgZS56XSxcbiAgICAgICAgICAgICAgICAgICBbIC1lLngsICBlLnksICBlLnpdLFxuICAgICAgICAgICAgICAgICAgIFsgLWUueCwgLWUueSwgIGUuel0sXG4gICAgICAgICAgICAgICAgICAgWyAtZS54LCAtZS55LCAtZS56XSxcbiAgICAgICAgICAgICAgICAgICBbICBlLngsIC1lLnksIC1lLnpdLFxuICAgICAgICAgICAgICAgICAgIFsgIGUueCwgIGUueSwgLWUuel0sXG4gICAgICAgICAgICAgICAgICAgWyAtZS54LCAgZS55LCAtZS56XSxcbiAgICAgICAgICAgICAgICAgICBbICBlLngsIC1lLnksICBlLnpdXTtcbiAgICBmb3IodmFyIGk9MDsgaTxjb3JuZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgd29ybGRDb3JuZXJUZW1wUG9zLnNldChjb3JuZXJzW2ldWzBdLGNvcm5lcnNbaV1bMV0sY29ybmVyc1tpXVsyXSk7XG4gICAgICAgIHF1YXQudm11bHQod29ybGRDb3JuZXJUZW1wUG9zLHdvcmxkQ29ybmVyVGVtcFBvcyk7XG4gICAgICAgIHBvcy52YWRkKHdvcmxkQ29ybmVyVGVtcFBvcyx3b3JsZENvcm5lclRlbXBQb3MpO1xuICAgICAgICBjYWxsYmFjayh3b3JsZENvcm5lclRlbXBQb3MueCxcbiAgICAgICAgICAgICAgICAgd29ybGRDb3JuZXJUZW1wUG9zLnksXG4gICAgICAgICAgICAgICAgIHdvcmxkQ29ybmVyVGVtcFBvcy56KTtcbiAgICB9XG59O1xuXG52YXIgd29ybGRDb3JuZXJzVGVtcCA9IFtcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKClcbl07XG5Cb3gucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uKHBvcyxxdWF0LG1pbixtYXgpe1xuXG4gICAgdmFyIGUgPSB0aGlzLmhhbGZFeHRlbnRzO1xuICAgIHdvcmxkQ29ybmVyc1RlbXBbMF0uc2V0KGUueCwgZS55LCBlLnopO1xuICAgIHdvcmxkQ29ybmVyc1RlbXBbMV0uc2V0KC1lLngsICBlLnksIGUueik7XG4gICAgd29ybGRDb3JuZXJzVGVtcFsyXS5zZXQoLWUueCwgLWUueSwgZS56KTtcbiAgICB3b3JsZENvcm5lcnNUZW1wWzNdLnNldCgtZS54LCAtZS55LCAtZS56KTtcbiAgICB3b3JsZENvcm5lcnNUZW1wWzRdLnNldChlLngsIC1lLnksIC1lLnopO1xuICAgIHdvcmxkQ29ybmVyc1RlbXBbNV0uc2V0KGUueCwgIGUueSwgLWUueik7XG4gICAgd29ybGRDb3JuZXJzVGVtcFs2XS5zZXQoLWUueCwgIGUueSwgLWUueik7XG4gICAgd29ybGRDb3JuZXJzVGVtcFs3XS5zZXQoZS54LCAtZS55LCAgZS56KTtcblxuICAgIHZhciB3YyA9IHdvcmxkQ29ybmVyc1RlbXBbMF07XG4gICAgcXVhdC52bXVsdCh3Yywgd2MpO1xuICAgIHBvcy52YWRkKHdjLCB3Yyk7XG4gICAgbWF4LmNvcHkod2MpO1xuICAgIG1pbi5jb3B5KHdjKTtcbiAgICBmb3IodmFyIGk9MTsgaTw4OyBpKyspe1xuICAgICAgICB2YXIgd2MgPSB3b3JsZENvcm5lcnNUZW1wW2ldO1xuICAgICAgICBxdWF0LnZtdWx0KHdjLCB3Yyk7XG4gICAgICAgIHBvcy52YWRkKHdjLCB3Yyk7XG4gICAgICAgIHZhciB4ID0gd2MueDtcbiAgICAgICAgdmFyIHkgPSB3Yy55O1xuICAgICAgICB2YXIgeiA9IHdjLno7XG4gICAgICAgIGlmKHggPiBtYXgueCl7XG4gICAgICAgICAgICBtYXgueCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeSA+IG1heC55KXtcbiAgICAgICAgICAgIG1heC55ID0geTtcbiAgICAgICAgfVxuICAgICAgICBpZih6ID4gbWF4Lnope1xuICAgICAgICAgICAgbWF4LnogPSB6O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoeCA8IG1pbi54KXtcbiAgICAgICAgICAgIG1pbi54ID0geDtcbiAgICAgICAgfVxuICAgICAgICBpZih5IDwgbWluLnkpe1xuICAgICAgICAgICAgbWluLnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGlmKHogPCBtaW4ueil7XG4gICAgICAgICAgICBtaW4ueiA9IHo7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQgZWFjaCBheGlzIG1heFxuICAgIC8vIG1pbi5zZXQoSW5maW5pdHksSW5maW5pdHksSW5maW5pdHkpO1xuICAgIC8vIG1heC5zZXQoLUluZmluaXR5LC1JbmZpbml0eSwtSW5maW5pdHkpO1xuICAgIC8vIHRoaXMuZm9yRWFjaFdvcmxkQ29ybmVyKHBvcyxxdWF0LGZ1bmN0aW9uKHgseSx6KXtcbiAgICAvLyAgICAgaWYoeCA+IG1heC54KXtcbiAgICAvLyAgICAgICAgIG1heC54ID0geDtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBpZih5ID4gbWF4Lnkpe1xuICAgIC8vICAgICAgICAgbWF4LnkgPSB5O1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmKHogPiBtYXgueil7XG4gICAgLy8gICAgICAgICBtYXgueiA9IHo7XG4gICAgLy8gICAgIH1cblxuICAgIC8vICAgICBpZih4IDwgbWluLngpe1xuICAgIC8vICAgICAgICAgbWluLnggPSB4O1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmKHkgPCBtaW4ueSl7XG4gICAgLy8gICAgICAgICBtaW4ueSA9IHk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgaWYoeiA8IG1pbi56KXtcbiAgICAvLyAgICAgICAgIG1pbi56ID0gejtcbiAgICAvLyAgICAgfVxuICAgIC8vIH0pO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gQ29udmV4UG9seWhlZHJvbjtcblxudmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gcmVxdWlyZSgnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcblxuLyoqXG4gKiBBIHNldCBvZiBwb2x5Z29ucyBkZXNjcmliaW5nIGEgY29udmV4IHNoYXBlLlxuICogQGNsYXNzIENvbnZleFBvbHloZWRyb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBkZXNjcmlwdGlvbiBUaGUgc2hhcGUgTVVTVCBiZSBjb252ZXggZm9yIHRoZSBjb2RlIHRvIHdvcmsgcHJvcGVybHkuIE5vIHBvbHlnb25zIG1heSBiZSBjb3BsYW5hciAoY29udGFpbmVkXG4gKiBpbiB0aGUgc2FtZSAzRCBwbGFuZSksIGluc3RlYWQgdGhlc2Ugc2hvdWxkIGJlIG1lcmdlZCBpbnRvIG9uZSBwb2x5Z29uLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IHBvaW50cyBBbiBhcnJheSBvZiBWZWMzJ3NcbiAqIEBwYXJhbSB7YXJyYXl9IGZhY2VzIEFycmF5IG9mIGludGVnZXIgYXJyYXlzLCBkZXNjcmliaW5nIHdoaWNoIHZlcnRpY2VzIHRoYXQgaXMgaW5jbHVkZWQgaW4gZWFjaCBmYWNlLlxuICpcbiAqIEBhdXRob3IgcWlhbyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvIChvcmlnaW5hbCBhdXRob3IsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcWlhby90aHJlZS5qcy9jb21taXQvODUwMjZmMGM3NjllNDAwMDE0OGE2N2Q0NWE5ZTliOWM1MTA4ODM2ZilcbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGVcbiAqIEBzZWUgaHR0cDovL3d3dy5hbHRkZXZibG9nYWRheS5jb20vMjAxMS8wNS8xMy9jb250YWN0LWdlbmVyYXRpb24tYmV0d2Vlbi0zZC1jb252ZXgtbWVzaGVzL1xuICogQHNlZSBodHRwOi8vYnVsbGV0Lmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9zcmMvQnVsbGV0Q29sbGlzaW9uL05hcnJvd1BoYXNlQ29sbGlzaW9uL2J0UG9seWhlZHJhbENvbnRhY3RDbGlwcGluZy5jcHBcbiAqXG4gKiBAdG9kbyBNb3ZlIHRoZSBjbGlwcGluZyBmdW5jdGlvbnMgdG8gQ29udGFjdEdlbmVyYXRvcj9cbiAqIEB0b2RvIEF1dG9tYXRpY2FsbHkgbWVyZ2UgY29wbGFuYXIgcG9seWdvbnMgaW4gY29uc3RydWN0b3IuXG4gKi9cbmZ1bmN0aW9uIENvbnZleFBvbHloZWRyb24ocG9pbnRzLCBmYWNlcywgdW5pcXVlQXhlcykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMudHlwZSA9IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST047XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBWZWMzXG4gICAgICogQHByb3BlcnR5IHZlcnRpY2VzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudmVydGljZXMgPSBwb2ludHN8fFtdO1xuXG4gICAgdGhpcy53b3JsZFZlcnRpY2VzID0gW107IC8vIFdvcmxkIHRyYW5zZm9ybWVkIHZlcnNpb24gb2YgLnZlcnRpY2VzXG4gICAgdGhpcy53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgaW50ZWdlciBhcnJheXMsIGluZGljYXRpbmcgd2hpY2ggdmVydGljZXMgZWFjaCBmYWNlIGNvbnNpc3RzIG9mXG4gICAgICogQHByb3BlcnR5IGZhY2VzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZmFjZXMgPSBmYWNlc3x8W107XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBWZWMzXG4gICAgICogQHByb3BlcnR5IGZhY2VOb3JtYWxzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuZmFjZU5vcm1hbHMgPSBbXTtcbiAgICB0aGlzLmNvbXB1dGVOb3JtYWxzKCk7XG5cbiAgICB0aGlzLndvcmxkRmFjZU5vcm1hbHNOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzID0gW107IC8vIFdvcmxkIHRyYW5zZm9ybWVkIHZlcnNpb24gb2YgLmZhY2VOb3JtYWxzXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBWZWMzXG4gICAgICogQHByb3BlcnR5IHVuaXF1ZUVkZ2VzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudW5pcXVlRWRnZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIElmIGdpdmVuLCB0aGVzZSBsb2NhbGx5IGRlZmluZWQsIG5vcm1hbGl6ZWQgYXhlcyBhcmUgdGhlIG9ubHkgb25lcyBiZWluZyBjaGVja2VkIHdoZW4gZG9pbmcgc2VwYXJhdGluZyBheGlzIGNoZWNrLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHVuaXF1ZUF4ZXNcbiAgICAgKi9cbiAgICB0aGlzLnVuaXF1ZUF4ZXMgPSB1bmlxdWVBeGVzID8gdW5pcXVlQXhlcy5zbGljZSgpIDogbnVsbDtcblxuICAgIHRoaXMuY29tcHV0ZUVkZ2VzKCk7XG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xufVxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udmV4UG9seWhlZHJvbjtcblxudmFyIGNvbXB1dGVFZGdlc190bXBFZGdlID0gbmV3IFZlYzMoKTtcbi8qKlxuICogQ29tcHV0ZXMgdW5pcXVlRWRnZXNcbiAqIEBtZXRob2QgY29tcHV0ZUVkZ2VzXG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNvbXB1dGVFZGdlcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGZhY2VzID0gdGhpcy5mYWNlcztcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIHZhciBudiA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLnVuaXF1ZUVkZ2VzO1xuXG4gICAgZWRnZXMubGVuZ3RoID0gMDtcblxuICAgIHZhciBlZGdlID0gY29tcHV0ZUVkZ2VzX3RtcEVkZ2U7XG5cbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gZmFjZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZmFjZSA9IGZhY2VzW2ldO1xuICAgICAgICB2YXIgbnVtVmVydGljZXMgPSBmYWNlLmxlbmd0aDtcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiAhPT0gbnVtVmVydGljZXM7IGorKyl7XG4gICAgICAgICAgICB2YXIgayA9ICggaisxICkgJSBudW1WZXJ0aWNlcztcbiAgICAgICAgICAgIHZlcnRpY2VzW2ZhY2Vbal1dLnZzdWIodmVydGljZXNbZmFjZVtrXV0sIGVkZ2UpO1xuICAgICAgICAgICAgZWRnZS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yKHZhciBwPTA7IHAgIT09IGVkZ2VzLmxlbmd0aDsgcCsrKXtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZXNbcF0uYWxtb3N0RXF1YWxzKGVkZ2UpIHx8IGVkZ2VzW3BdLmFsbW9zdEVxdWFscyhlZGdlKSl7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWZvdW5kKXtcbiAgICAgICAgICAgICAgICBlZGdlcy5wdXNoKGVkZ2UuY2xvbmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIG5vcm1hbHMgb2YgdGhlIGZhY2VzLiBXaWxsIHJldXNlIGV4aXN0aW5nIFZlYzMgb2JqZWN0cyBpbiB0aGUgLmZhY2VOb3JtYWxzIGFycmF5IGlmIHRoZXkgZXhpc3QuXG4gKiBAbWV0aG9kIGNvbXB1dGVOb3JtYWxzXG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNvbXB1dGVOb3JtYWxzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmZhY2VOb3JtYWxzLmxlbmd0aCA9IHRoaXMuZmFjZXMubGVuZ3RoO1xuXG4gICAgLy8gR2VuZXJhdGUgbm9ybWFsc1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuZmFjZXMubGVuZ3RoOyBpKyspe1xuXG4gICAgICAgIC8vIENoZWNrIHNvIGFsbCB2ZXJ0aWNlcyBleGlzdHMgZm9yIHRoaXMgZmFjZVxuICAgICAgICBmb3IodmFyIGo9MDsgajx0aGlzLmZhY2VzW2ldLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIGlmKCF0aGlzLnZlcnRpY2VzW3RoaXMuZmFjZXNbaV1bal1dKXtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWZXJ0ZXggXCIrdGhpcy5mYWNlc1tpXVtqXStcIiBub3QgZm91bmQhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG4gPSB0aGlzLmZhY2VOb3JtYWxzW2ldIHx8IG5ldyBWZWMzKCk7XG4gICAgICAgIHRoaXMuZ2V0RmFjZU5vcm1hbChpLG4pO1xuICAgICAgICBuLm5lZ2F0ZShuKTtcbiAgICAgICAgdGhpcy5mYWNlTm9ybWFsc1tpXSA9IG47XG4gICAgICAgIHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzW3RoaXMuZmFjZXNbaV1bMF1dO1xuICAgICAgICBpZihuLmRvdCh2ZXJ0ZXgpIDwgMCl7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiLmZhY2VOb3JtYWxzW1wiICsgaSArIFwiXSA9IFZlYzMoXCIrbi50b1N0cmluZygpK1wiKSBsb29rcyBsaWtlIGl0IHBvaW50cyBpbnRvIHRoZSBzaGFwZT8gVGhlIHZlcnRpY2VzIGZvbGxvdy4gTWFrZSBzdXJlIHRoZXkgYXJlIG9yZGVyZWQgQ0NXIGFyb3VuZCB0aGUgbm9ybWFsLCB1c2luZyB0aGUgcmlnaHQgaGFuZCBydWxlLlwiKTtcbiAgICAgICAgICAgIGZvcih2YXIgaj0wOyBqPHRoaXMuZmFjZXNbaV0ubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIi52ZXJ0aWNlc1tcIit0aGlzLmZhY2VzW2ldW2pdK1wiXSA9IFZlYzMoXCIrdGhpcy52ZXJ0aWNlc1t0aGlzLmZhY2VzW2ldW2pdXS50b1N0cmluZygpK1wiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGZhY2Ugbm9ybWFsIGdpdmVuIDMgdmVydGljZXNcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgZ2V0RmFjZU5vcm1hbFxuICogQHBhcmFtIHtWZWMzfSB2YVxuICogQHBhcmFtIHtWZWMzfSB2YlxuICogQHBhcmFtIHtWZWMzfSB2Y1xuICogQHBhcmFtIHtWZWMzfSB0YXJnZXRcbiAqL1xudmFyIGNiID0gbmV3IFZlYzMoKTtcbnZhciBhYiA9IG5ldyBWZWMzKCk7XG5Db252ZXhQb2x5aGVkcm9uLmNvbXB1dGVOb3JtYWwgPSBmdW5jdGlvbiAoIHZhLCB2YiwgdmMsIHRhcmdldCApIHtcbiAgICB2Yi52c3ViKHZhLGFiKTtcbiAgICB2Yy52c3ViKHZiLGNiKTtcbiAgICBjYi5jcm9zcyhhYix0YXJnZXQpO1xuICAgIGlmICggIXRhcmdldC5pc1plcm8oKSApIHtcbiAgICAgICAgdGFyZ2V0Lm5vcm1hbGl6ZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbm9ybWFsIG9mIGEgZmFjZSBmcm9tIGl0cyB2ZXJ0aWNlc1xuICogQG1ldGhvZCBnZXRGYWNlTm9ybWFsXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5nZXRGYWNlTm9ybWFsID0gZnVuY3Rpb24oaSx0YXJnZXQpe1xuICAgIHZhciBmID0gdGhpcy5mYWNlc1tpXTtcbiAgICB2YXIgdmEgPSB0aGlzLnZlcnRpY2VzW2ZbMF1dO1xuICAgIHZhciB2YiA9IHRoaXMudmVydGljZXNbZlsxXV07XG4gICAgdmFyIHZjID0gdGhpcy52ZXJ0aWNlc1tmWzJdXTtcbiAgICByZXR1cm4gQ29udmV4UG9seWhlZHJvbi5jb21wdXRlTm9ybWFsKHZhLHZiLHZjLHRhcmdldCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY2xpcEFnYWluc3RIdWxsXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc0FcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEFcbiAqIEBwYXJhbSB7Q29udmV4UG9seWhlZHJvbn0gaHVsbEJcbiAqIEBwYXJhbSB7VmVjM30gcG9zQlxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QlxuICogQHBhcmFtIHtWZWMzfSBzZXBhcmF0aW5nTm9ybWFsXG4gKiBAcGFyYW0ge051bWJlcn0gbWluRGlzdCBDbGFtcCBkaXN0YW5jZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1heERpc3RcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBUaGUgYW4gYXJyYXkgb2YgY29udGFjdCBwb2ludCBvYmplY3RzLCBzZWUgY2xpcEZhY2VBZ2FpbnN0SHVsbFxuICogQHNlZSBodHRwOi8vYnVsbGV0Lmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9zcmMvQnVsbGV0Q29sbGlzaW9uL05hcnJvd1BoYXNlQ29sbGlzaW9uL2J0UG9seWhlZHJhbENvbnRhY3RDbGlwcGluZy5jcHBcbiAqL1xudmFyIGNhaF9Xb3JsZE5vcm1hbCA9IG5ldyBWZWMzKCk7XG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jbGlwQWdhaW5zdEh1bGwgPSBmdW5jdGlvbihwb3NBLHF1YXRBLGh1bGxCLHBvc0IscXVhdEIsc2VwYXJhdGluZ05vcm1hbCxtaW5EaXN0LG1heERpc3QscmVzdWx0KXtcbiAgICB2YXIgV29ybGROb3JtYWwgPSBjYWhfV29ybGROb3JtYWw7XG4gICAgdmFyIGh1bGxBID0gdGhpcztcbiAgICB2YXIgY3VyTWF4RGlzdCA9IG1heERpc3Q7XG4gICAgdmFyIGNsb3Nlc3RGYWNlQiA9IC0xO1xuICAgIHZhciBkbWF4ID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgZm9yKHZhciBmYWNlPTA7IGZhY2UgPCBodWxsQi5mYWNlcy5sZW5ndGg7IGZhY2UrKyl7XG4gICAgICAgIFdvcmxkTm9ybWFsLmNvcHkoaHVsbEIuZmFjZU5vcm1hbHNbZmFjZV0pO1xuICAgICAgICBxdWF0Qi52bXVsdChXb3JsZE5vcm1hbCxXb3JsZE5vcm1hbCk7XG4gICAgICAgIC8vcG9zQi52YWRkKFdvcmxkTm9ybWFsLFdvcmxkTm9ybWFsKTtcbiAgICAgICAgdmFyIGQgPSBXb3JsZE5vcm1hbC5kb3Qoc2VwYXJhdGluZ05vcm1hbCk7XG4gICAgICAgIGlmIChkID4gZG1heCl7XG4gICAgICAgICAgICBkbWF4ID0gZDtcbiAgICAgICAgICAgIGNsb3Nlc3RGYWNlQiA9IGZhY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHdvcmxkVmVydHNCMSA9IFtdO1xuICAgIHZhciBwb2x5QiA9IGh1bGxCLmZhY2VzW2Nsb3Nlc3RGYWNlQl07XG4gICAgdmFyIG51bVZlcnRpY2VzID0gcG9seUIubGVuZ3RoO1xuICAgIGZvcih2YXIgZTA9MDsgZTA8bnVtVmVydGljZXM7IGUwKyspe1xuICAgICAgICB2YXIgYiA9IGh1bGxCLnZlcnRpY2VzW3BvbHlCW2UwXV07XG4gICAgICAgIHZhciB3b3JsZGIgPSBuZXcgVmVjMygpO1xuICAgICAgICB3b3JsZGIuY29weShiKTtcbiAgICAgICAgcXVhdEIudm11bHQod29ybGRiLHdvcmxkYik7XG4gICAgICAgIHBvc0IudmFkZCh3b3JsZGIsd29ybGRiKTtcbiAgICAgICAgd29ybGRWZXJ0c0IxLnB1c2god29ybGRiKTtcbiAgICB9XG5cbiAgICBpZiAoY2xvc2VzdEZhY2VCPj0wKXtcbiAgICAgICAgdGhpcy5jbGlwRmFjZUFnYWluc3RIdWxsKHNlcGFyYXRpbmdOb3JtYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NBLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhdEEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JsZFZlcnRzQjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5EaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBzZXBhcmF0aW5nIGF4aXMgYmV0d2VlbiB0aGlzIGh1bGwgYW5kIGFub3RoZXJcbiAqIEBtZXRob2QgZmluZFNlcGFyYXRpbmdBeGlzXG4gKiBAcGFyYW0ge0NvbnZleFBvbHloZWRyb259IGh1bGxCXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc0FcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEFcbiAqIEBwYXJhbSB7VmVjM30gcG9zQlxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QlxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgVGhlIHRhcmdldCB2ZWN0b3IgdG8gc2F2ZSB0aGUgYXhpcyBpblxuICogQHJldHVybiB7Ym9vbH0gUmV0dXJucyBmYWxzZSBpZiBhIHNlcGFyYXRpb24gaXMgZm91bmQsIGVsc2UgdHJ1ZVxuICovXG52YXIgZnNhX2ZhY2VBTm9ybWFsV1MzID0gbmV3IFZlYzMoKSxcbiAgICBmc2FfV29ybGRub3JtYWwxID0gbmV3IFZlYzMoKSxcbiAgICBmc2FfZGVsdGFDID0gbmV3IFZlYzMoKSxcbiAgICBmc2Ffd29ybGRFZGdlMCA9IG5ldyBWZWMzKCksXG4gICAgZnNhX3dvcmxkRWRnZTEgPSBuZXcgVmVjMygpLFxuICAgIGZzYV9Dcm9zcyA9IG5ldyBWZWMzKCk7XG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5maW5kU2VwYXJhdGluZ0F4aXMgPSBmdW5jdGlvbihodWxsQixwb3NBLHF1YXRBLHBvc0IscXVhdEIsdGFyZ2V0LCBmYWNlTGlzdEEsIGZhY2VMaXN0Qil7XG4gICAgdmFyIGZhY2VBTm9ybWFsV1MzID0gZnNhX2ZhY2VBTm9ybWFsV1MzLFxuICAgICAgICBXb3JsZG5vcm1hbDEgPSBmc2FfV29ybGRub3JtYWwxLFxuICAgICAgICBkZWx0YUMgPSBmc2FfZGVsdGFDLFxuICAgICAgICB3b3JsZEVkZ2UwID0gZnNhX3dvcmxkRWRnZTAsXG4gICAgICAgIHdvcmxkRWRnZTEgPSBmc2Ffd29ybGRFZGdlMSxcbiAgICAgICAgQ3Jvc3MgPSBmc2FfQ3Jvc3M7XG5cbiAgICB2YXIgZG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgdmFyIGh1bGxBID0gdGhpcztcbiAgICB2YXIgY3VyUGxhbmVUZXN0cz0wO1xuXG4gICAgaWYoIWh1bGxBLnVuaXF1ZUF4ZXMpe1xuXG4gICAgICAgIHZhciBudW1GYWNlc0EgPSBmYWNlTGlzdEEgPyBmYWNlTGlzdEEubGVuZ3RoIDogaHVsbEEuZmFjZXMubGVuZ3RoO1xuXG4gICAgICAgIC8vIFRlc3QgZmFjZSBub3JtYWxzIGZyb20gaHVsbEFcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bnVtRmFjZXNBOyBpKyspe1xuICAgICAgICAgICAgdmFyIGZpID0gZmFjZUxpc3RBID8gZmFjZUxpc3RBW2ldIDogaTtcblxuICAgICAgICAgICAgLy8gR2V0IHdvcmxkIGZhY2Ugbm9ybWFsXG4gICAgICAgICAgICBmYWNlQU5vcm1hbFdTMy5jb3B5KGh1bGxBLmZhY2VOb3JtYWxzW2ZpXSk7XG4gICAgICAgICAgICBxdWF0QS52bXVsdChmYWNlQU5vcm1hbFdTMyxmYWNlQU5vcm1hbFdTMyk7XG5cbiAgICAgICAgICAgIHZhciBkID0gaHVsbEEudGVzdFNlcEF4aXMoZmFjZUFOb3JtYWxXUzMsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpO1xuICAgICAgICAgICAgaWYoZD09PWZhbHNlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGQ8ZG1pbil7XG4gICAgICAgICAgICAgICAgZG1pbiA9IGQ7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmNvcHkoZmFjZUFOb3JtYWxXUzMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFRlc3QgdW5pcXVlIGF4ZXNcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSAhPT0gaHVsbEEudW5pcXVlQXhlcy5sZW5ndGg7IGkrKyl7XG5cbiAgICAgICAgICAgIC8vIEdldCB3b3JsZCBheGlzXG4gICAgICAgICAgICBxdWF0QS52bXVsdChodWxsQS51bmlxdWVBeGVzW2ldLGZhY2VBTm9ybWFsV1MzKTtcblxuICAgICAgICAgICAgdmFyIGQgPSBodWxsQS50ZXN0U2VwQXhpcyhmYWNlQU5vcm1hbFdTMywgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7XG4gICAgICAgICAgICBpZihkPT09ZmFsc2Upe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZDxkbWluKXtcbiAgICAgICAgICAgICAgICBkbWluID0gZDtcbiAgICAgICAgICAgICAgICB0YXJnZXQuY29weShmYWNlQU5vcm1hbFdTMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZighaHVsbEIudW5pcXVlQXhlcyl7XG5cbiAgICAgICAgLy8gVGVzdCBmYWNlIG5vcm1hbHMgZnJvbSBodWxsQlxuICAgICAgICB2YXIgbnVtRmFjZXNCID0gZmFjZUxpc3RCID8gZmFjZUxpc3RCLmxlbmd0aCA6IGh1bGxCLmZhY2VzLmxlbmd0aDtcbiAgICAgICAgZm9yKHZhciBpPTA7aTxudW1GYWNlc0I7aSsrKXtcblxuICAgICAgICAgICAgdmFyIGZpID0gZmFjZUxpc3RCID8gZmFjZUxpc3RCW2ldIDogaTtcblxuICAgICAgICAgICAgV29ybGRub3JtYWwxLmNvcHkoaHVsbEIuZmFjZU5vcm1hbHNbZmldKTtcbiAgICAgICAgICAgIHF1YXRCLnZtdWx0KFdvcmxkbm9ybWFsMSxXb3JsZG5vcm1hbDEpO1xuICAgICAgICAgICAgY3VyUGxhbmVUZXN0cysrO1xuICAgICAgICAgICAgdmFyIGQgPSBodWxsQS50ZXN0U2VwQXhpcyhXb3JsZG5vcm1hbDEsIGh1bGxCLHBvc0EscXVhdEEscG9zQixxdWF0Qik7XG4gICAgICAgICAgICBpZihkPT09ZmFsc2Upe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZDxkbWluKXtcbiAgICAgICAgICAgICAgICBkbWluID0gZDtcbiAgICAgICAgICAgICAgICB0YXJnZXQuY29weShXb3JsZG5vcm1hbDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBUZXN0IHVuaXF1ZSBheGVzIGluIEJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSAhPT0gaHVsbEIudW5pcXVlQXhlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBxdWF0Qi52bXVsdChodWxsQi51bmlxdWVBeGVzW2ldLFdvcmxkbm9ybWFsMSk7XG5cbiAgICAgICAgICAgIGN1clBsYW5lVGVzdHMrKztcbiAgICAgICAgICAgIHZhciBkID0gaHVsbEEudGVzdFNlcEF4aXMoV29ybGRub3JtYWwxLCBodWxsQixwb3NBLHF1YXRBLHBvc0IscXVhdEIpO1xuICAgICAgICAgICAgaWYoZD09PWZhbHNlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKGQ8ZG1pbil7XG4gICAgICAgICAgICAgICAgZG1pbiA9IGQ7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmNvcHkoV29ybGRub3JtYWwxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRlc3QgZWRnZXNcbiAgICBmb3IodmFyIGUwPTA7IGUwICE9PSBodWxsQS51bmlxdWVFZGdlcy5sZW5ndGg7IGUwKyspe1xuXG4gICAgICAgIC8vIEdldCB3b3JsZCBlZGdlXG4gICAgICAgIHF1YXRBLnZtdWx0KGh1bGxBLnVuaXF1ZUVkZ2VzW2UwXSx3b3JsZEVkZ2UwKTtcblxuICAgICAgICBmb3IodmFyIGUxPTA7IGUxICE9PSBodWxsQi51bmlxdWVFZGdlcy5sZW5ndGg7IGUxKyspe1xuXG4gICAgICAgICAgICAvLyBHZXQgd29ybGQgZWRnZSAyXG4gICAgICAgICAgICBxdWF0Qi52bXVsdChodWxsQi51bmlxdWVFZGdlc1tlMV0sIHdvcmxkRWRnZTEpO1xuICAgICAgICAgICAgd29ybGRFZGdlMC5jcm9zcyh3b3JsZEVkZ2UxLENyb3NzKTtcblxuICAgICAgICAgICAgaWYoIUNyb3NzLmFsbW9zdFplcm8oKSl7XG4gICAgICAgICAgICAgICAgQ3Jvc3Mubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBodWxsQS50ZXN0U2VwQXhpcyhDcm9zcywgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7XG4gICAgICAgICAgICAgICAgaWYoZGlzdCA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGRpc3QgPCBkbWluKXtcbiAgICAgICAgICAgICAgICAgICAgZG1pbiA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5jb3B5KENyb3NzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwb3NCLnZzdWIocG9zQSxkZWx0YUMpO1xuICAgIGlmKChkZWx0YUMuZG90KHRhcmdldCkpPjAuMCl7XG4gICAgICAgIHRhcmdldC5uZWdhdGUodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBtYXhtaW5BPVtdLCBtYXhtaW5CPVtdO1xuXG4vKipcbiAqIFRlc3Qgc2VwYXJhdGluZyBheGlzIGFnYWluc3QgdHdvIGh1bGxzLiBCb3RoIGh1bGxzIGFyZSBwcm9qZWN0ZWQgb250byB0aGUgYXhpcyBhbmQgdGhlIG92ZXJsYXAgc2l6ZSBpcyByZXR1cm5lZCBpZiB0aGVyZSBpcyBvbmUuXG4gKiBAbWV0aG9kIHRlc3RTZXBBeGlzXG4gKiBAcGFyYW0ge1ZlYzN9IGF4aXNcbiAqIEBwYXJhbSB7Q29udmV4UG9seWhlZHJvbn0gaHVsbEJcbiAqIEBwYXJhbSB7VmVjM30gcG9zQVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QVxuICogQHBhcmFtIHtWZWMzfSBwb3NCXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRCXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBvdmVybGFwIGRlcHRoLCBvciBGQUxTRSBpZiBubyBwZW5ldHJhdGlvbi5cbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUudGVzdFNlcEF4aXMgPSBmdW5jdGlvbihheGlzLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKXtcbiAgICB2YXIgaHVsbEE9dGhpcztcbiAgICBDb252ZXhQb2x5aGVkcm9uLnByb2plY3QoaHVsbEEsIGF4aXMsIHBvc0EsIHF1YXRBLCBtYXhtaW5BKTtcbiAgICBDb252ZXhQb2x5aGVkcm9uLnByb2plY3QoaHVsbEIsIGF4aXMsIHBvc0IsIHF1YXRCLCBtYXhtaW5CKTtcbiAgICB2YXIgbWF4QSA9IG1heG1pbkFbMF07XG4gICAgdmFyIG1pbkEgPSBtYXhtaW5BWzFdO1xuICAgIHZhciBtYXhCID0gbWF4bWluQlswXTtcbiAgICB2YXIgbWluQiA9IG1heG1pbkJbMV07XG4gICAgaWYobWF4QTxtaW5CIHx8IG1heEI8bWluQSl7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gU2VwYXJhdGVkXG4gICAgfVxuICAgIHZhciBkMCA9IG1heEEgLSBtaW5CO1xuICAgIHZhciBkMSA9IG1heEIgLSBtaW5BO1xuICAgIHZhciBkZXB0aCA9IGQwPGQxID8gZDA6ZDE7XG4gICAgcmV0dXJuIGRlcHRoO1xufTtcblxudmFyIGNsaV9hYWJibWluID0gbmV3IFZlYzMoKSxcbiAgICBjbGlfYWFiYm1heCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3MsdGFyZ2V0KXtcbiAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGJveCBpbmVydGlhXG4gICAgLy8gRXhhY3QgaW5lcnRpYSBjYWxjdWxhdGlvbiBpcyBvdmVya2lsbCwgYnV0IHNlZSBodHRwOi8vZ2VvbWV0cmljdG9vbHMuY29tL0RvY3VtZW50YXRpb24vUG9seWhlZHJhbE1hc3NQcm9wZXJ0aWVzLnBkZiBmb3IgdGhlIGNvcnJlY3Qgd2F5IHRvIGRvIGl0XG4gICAgdGhpcy5jb21wdXRlTG9jYWxBQUJCKGNsaV9hYWJibWluLGNsaV9hYWJibWF4KTtcbiAgICB2YXIgeCA9IGNsaV9hYWJibWF4LnggLSBjbGlfYWFiYm1pbi54LFxuICAgICAgICB5ID0gY2xpX2FhYmJtYXgueSAtIGNsaV9hYWJibWluLnksXG4gICAgICAgIHogPSBjbGlfYWFiYm1heC56IC0gY2xpX2FhYmJtaW4uejtcbiAgICB0YXJnZXQueCA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAyKnkqMip5ICsgMip6KjIqeiApO1xuICAgIHRhcmdldC55ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoIDIqeCoyKnggKyAyKnoqMip6ICk7XG4gICAgdGFyZ2V0LnogPSAxLjAgLyAxMi4wICogbWFzcyAqICggMip5KjIqeSArIDIqeCoyKnggKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBnZXRQbGFuZUNvbnN0YW50T2ZGYWNlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGZhY2VfaSBJbmRleCBvZiB0aGUgZmFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5nZXRQbGFuZUNvbnN0YW50T2ZGYWNlID0gZnVuY3Rpb24oZmFjZV9pKXtcbiAgICB2YXIgZiA9IHRoaXMuZmFjZXNbZmFjZV9pXTtcbiAgICB2YXIgbiA9IHRoaXMuZmFjZU5vcm1hbHNbZmFjZV9pXTtcbiAgICB2YXIgdiA9IHRoaXMudmVydGljZXNbZlswXV07XG4gICAgdmFyIGMgPSAtbi5kb3Qodik7XG4gICAgcmV0dXJuIGM7XG59O1xuXG4vKipcbiAqIENsaXAgYSBmYWNlIGFnYWluc3QgYSBodWxsLlxuICogQG1ldGhvZCBjbGlwRmFjZUFnYWluc3RIdWxsXG4gKiBAcGFyYW0ge1ZlYzN9IHNlcGFyYXRpbmdOb3JtYWxcbiAqIEBwYXJhbSB7VmVjM30gcG9zQVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QVxuICogQHBhcmFtIHtBcnJheX0gd29ybGRWZXJ0c0IxIEFuIGFycmF5IG9mIFZlYzMgd2l0aCB2ZXJ0aWNlcyBpbiB0aGUgd29ybGQgZnJhbWUuXG4gKiBAcGFyYW0ge051bWJlcn0gbWluRGlzdCBEaXN0YW5jZSBjbGFtcGluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG1heERpc3RcbiAqIEBwYXJhbSBBcnJheSByZXN1bHQgQXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGNvbnRhY3QgcG9pbnRzIGluLiBXaWxsIGJlIG9iamVjdHMgd2l0aCBwcm9wZXJ0aWVzOiBwb2ludCwgZGVwdGgsIG5vcm1hbC4gVGhlc2UgYXJlIHJlcHJlc2VudGVkIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICovXG52YXIgY2ZhaF9mYWNlQU5vcm1hbFdTID0gbmV3IFZlYzMoKSxcbiAgICBjZmFoX2VkZ2UwID0gbmV3IFZlYzMoKSxcbiAgICBjZmFoX1dvcmxkRWRnZTAgPSBuZXcgVmVjMygpLFxuICAgIGNmYWhfd29ybGRQbGFuZUFub3JtYWwxID0gbmV3IFZlYzMoKSxcbiAgICBjZmFoX3BsYW5lTm9ybWFsV1MxID0gbmV3IFZlYzMoKSxcbiAgICBjZmFoX3dvcmxkQTEgPSBuZXcgVmVjMygpLFxuICAgIGNmYWhfbG9jYWxQbGFuZU5vcm1hbCA9IG5ldyBWZWMzKCksXG4gICAgY2ZhaF9wbGFuZU5vcm1hbFdTID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNsaXBGYWNlQWdhaW5zdEh1bGwgPSBmdW5jdGlvbihzZXBhcmF0aW5nTm9ybWFsLCBwb3NBLCBxdWF0QSwgd29ybGRWZXJ0c0IxLCBtaW5EaXN0LCBtYXhEaXN0LHJlc3VsdCl7XG4gICAgdmFyIGZhY2VBTm9ybWFsV1MgPSBjZmFoX2ZhY2VBTm9ybWFsV1MsXG4gICAgICAgIGVkZ2UwID0gY2ZhaF9lZGdlMCxcbiAgICAgICAgV29ybGRFZGdlMCA9IGNmYWhfV29ybGRFZGdlMCxcbiAgICAgICAgd29ybGRQbGFuZUFub3JtYWwxID0gY2ZhaF93b3JsZFBsYW5lQW5vcm1hbDEsXG4gICAgICAgIHBsYW5lTm9ybWFsV1MxID0gY2ZhaF9wbGFuZU5vcm1hbFdTMSxcbiAgICAgICAgd29ybGRBMSA9IGNmYWhfd29ybGRBMSxcbiAgICAgICAgbG9jYWxQbGFuZU5vcm1hbCA9IGNmYWhfbG9jYWxQbGFuZU5vcm1hbCxcbiAgICAgICAgcGxhbmVOb3JtYWxXUyA9IGNmYWhfcGxhbmVOb3JtYWxXUztcblxuICAgIHZhciBodWxsQSA9IHRoaXM7XG4gICAgdmFyIHdvcmxkVmVydHNCMiA9IFtdO1xuICAgIHZhciBwVnR4SW4gPSB3b3JsZFZlcnRzQjE7XG4gICAgdmFyIHBWdHhPdXQgPSB3b3JsZFZlcnRzQjI7XG4gICAgLy8gRmluZCB0aGUgZmFjZSB3aXRoIG5vcm1hbCBjbG9zZXN0IHRvIHRoZSBzZXBhcmF0aW5nIGF4aXNcbiAgICB2YXIgY2xvc2VzdEZhY2VBID0gLTE7XG4gICAgdmFyIGRtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGZvcih2YXIgZmFjZT0wOyBmYWNlPGh1bGxBLmZhY2VzLmxlbmd0aDsgZmFjZSsrKXtcbiAgICAgICAgZmFjZUFOb3JtYWxXUy5jb3B5KGh1bGxBLmZhY2VOb3JtYWxzW2ZhY2VdKTtcbiAgICAgICAgcXVhdEEudm11bHQoZmFjZUFOb3JtYWxXUyxmYWNlQU5vcm1hbFdTKTtcbiAgICAgICAgLy9wb3NBLnZhZGQoZmFjZUFOb3JtYWxXUyxmYWNlQU5vcm1hbFdTKTtcbiAgICAgICAgdmFyIGQgPSBmYWNlQU5vcm1hbFdTLmRvdChzZXBhcmF0aW5nTm9ybWFsKTtcbiAgICAgICAgaWYgKGQgPCBkbWluKXtcbiAgICAgICAgICAgIGRtaW4gPSBkO1xuICAgICAgICAgICAgY2xvc2VzdEZhY2VBID0gZmFjZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xvc2VzdEZhY2VBIDwgMCl7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiLS0tIGRpZCBub3QgZmluZCBhbnkgY2xvc2VzdCBmYWNlLi4uIC0tLVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKFwiY2xvc2VzdCBBOiBcIixjbG9zZXN0RmFjZUEpO1xuICAgIC8vIEdldCB0aGUgZmFjZSBhbmQgY29uc3RydWN0IGNvbm5lY3RlZCBmYWNlc1xuICAgIHZhciBwb2x5QSA9IGh1bGxBLmZhY2VzW2Nsb3Nlc3RGYWNlQV07XG4gICAgcG9seUEuY29ubmVjdGVkRmFjZXMgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTxodWxsQS5mYWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGZvcih2YXIgaj0wOyBqPGh1bGxBLmZhY2VzW2ldLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIGlmKHBvbHlBLmluZGV4T2YoaHVsbEEuZmFjZXNbaV1bal0pIT09LTEgLyogU2hhcmluZyBhIHZlcnRleCovICYmIGkhPT1jbG9zZXN0RmFjZUEgLyogTm90IHRoZSBvbmUgd2UgYXJlIGxvb2tpbmcgZm9yIGNvbm5lY3Rpb25zIGZyb20gKi8gJiYgcG9seUEuY29ubmVjdGVkRmFjZXMuaW5kZXhPZihpKT09PS0xIC8qIE5vdCBhbHJlYWR5IGFkZGVkICovICl7XG4gICAgICAgICAgICAgICAgcG9seUEuY29ubmVjdGVkRmFjZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDbGlwIHRoZSBwb2x5Z29uIHRvIHRoZSBiYWNrIG9mIHRoZSBwbGFuZXMgb2YgYWxsIGZhY2VzIG9mIGh1bGwgQSwgdGhhdCBhcmUgYWRqYWNlbnQgdG8gdGhlIHdpdG5lc3MgZmFjZVxuICAgIHZhciBudW1Db250YWN0cyA9IHBWdHhJbi5sZW5ndGg7XG4gICAgdmFyIG51bVZlcnRpY2VzQSA9IHBvbHlBLmxlbmd0aDtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yKHZhciBlMD0wOyBlMDxudW1WZXJ0aWNlc0E7IGUwKyspe1xuICAgICAgICB2YXIgYSA9IGh1bGxBLnZlcnRpY2VzW3BvbHlBW2UwXV07XG4gICAgICAgIHZhciBiID0gaHVsbEEudmVydGljZXNbcG9seUFbKGUwKzEpJW51bVZlcnRpY2VzQV1dO1xuICAgICAgICBhLnZzdWIoYixlZGdlMCk7XG4gICAgICAgIFdvcmxkRWRnZTAuY29weShlZGdlMCk7XG4gICAgICAgIHF1YXRBLnZtdWx0KFdvcmxkRWRnZTAsV29ybGRFZGdlMCk7XG4gICAgICAgIHBvc0EudmFkZChXb3JsZEVkZ2UwLFdvcmxkRWRnZTApO1xuICAgICAgICB3b3JsZFBsYW5lQW5vcm1hbDEuY29weSh0aGlzLmZhY2VOb3JtYWxzW2Nsb3Nlc3RGYWNlQV0pOy8vdHJhbnNBLmdldEJhc2lzKCkqIGJ0VmVjdG9yMyhwb2x5QS5tX3BsYW5lWzBdLHBvbHlBLm1fcGxhbmVbMV0scG9seUEubV9wbGFuZVsyXSk7XG4gICAgICAgIHF1YXRBLnZtdWx0KHdvcmxkUGxhbmVBbm9ybWFsMSx3b3JsZFBsYW5lQW5vcm1hbDEpO1xuICAgICAgICBwb3NBLnZhZGQod29ybGRQbGFuZUFub3JtYWwxLHdvcmxkUGxhbmVBbm9ybWFsMSk7XG4gICAgICAgIFdvcmxkRWRnZTAuY3Jvc3Mod29ybGRQbGFuZUFub3JtYWwxLHBsYW5lTm9ybWFsV1MxKTtcbiAgICAgICAgcGxhbmVOb3JtYWxXUzEubmVnYXRlKHBsYW5lTm9ybWFsV1MxKTtcbiAgICAgICAgd29ybGRBMS5jb3B5KGEpO1xuICAgICAgICBxdWF0QS52bXVsdCh3b3JsZEExLHdvcmxkQTEpO1xuICAgICAgICBwb3NBLnZhZGQod29ybGRBMSx3b3JsZEExKTtcbiAgICAgICAgdmFyIHBsYW5lRXFXUzEgPSAtd29ybGRBMS5kb3QocGxhbmVOb3JtYWxXUzEpO1xuICAgICAgICB2YXIgcGxhbmVFcVdTO1xuICAgICAgICBpZih0cnVlKXtcbiAgICAgICAgICAgIHZhciBvdGhlckZhY2UgPSBwb2x5QS5jb25uZWN0ZWRGYWNlc1tlMF07XG4gICAgICAgICAgICBsb2NhbFBsYW5lTm9ybWFsLmNvcHkodGhpcy5mYWNlTm9ybWFsc1tvdGhlckZhY2VdKTtcbiAgICAgICAgICAgIHZhciBsb2NhbFBsYW5lRXEgPSB0aGlzLmdldFBsYW5lQ29uc3RhbnRPZkZhY2Uob3RoZXJGYWNlKTtcblxuICAgICAgICAgICAgcGxhbmVOb3JtYWxXUy5jb3B5KGxvY2FsUGxhbmVOb3JtYWwpO1xuICAgICAgICAgICAgcXVhdEEudm11bHQocGxhbmVOb3JtYWxXUyxwbGFuZU5vcm1hbFdTKTtcbiAgICAgICAgICAgIC8vcG9zQS52YWRkKHBsYW5lTm9ybWFsV1MscGxhbmVOb3JtYWxXUyk7XG4gICAgICAgICAgICB2YXIgcGxhbmVFcVdTID0gbG9jYWxQbGFuZUVxIC0gcGxhbmVOb3JtYWxXUy5kb3QocG9zQSk7XG4gICAgICAgIH0gZWxzZSAge1xuICAgICAgICAgICAgcGxhbmVOb3JtYWxXUy5jb3B5KHBsYW5lTm9ybWFsV1MxKTtcbiAgICAgICAgICAgIHBsYW5lRXFXUyA9IHBsYW5lRXFXUzE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGlwIGZhY2UgYWdhaW5zdCBvdXIgY29uc3RydWN0ZWQgcGxhbmVcbiAgICAgICAgdGhpcy5jbGlwRmFjZUFnYWluc3RQbGFuZShwVnR4SW4sIHBWdHhPdXQsIHBsYW5lTm9ybWFsV1MsIHBsYW5lRXFXUyk7XG5cbiAgICAgICAgLy8gVGhyb3cgYXdheSBhbGwgY2xpcHBlZCBwb2ludHMsIGJ1dCBzYXZlIHRoZSByZWFtaW5pbmcgdW50aWwgbmV4dCBjbGlwXG4gICAgICAgIHdoaWxlKHBWdHhJbi5sZW5ndGgpe1xuICAgICAgICAgICAgcFZ0eEluLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUocFZ0eE91dC5sZW5ndGgpe1xuICAgICAgICAgICAgcFZ0eEluLnB1c2gocFZ0eE91dC5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vY29uc29sZS5sb2coXCJSZXN1bHRpbmcgcG9pbnRzIGFmdGVyIGNsaXA6XCIscFZ0eEluKTtcblxuICAgIC8vIG9ubHkga2VlcCBjb250YWN0IHBvaW50cyB0aGF0IGFyZSBiZWhpbmQgdGhlIHdpdG5lc3MgZmFjZVxuICAgIGxvY2FsUGxhbmVOb3JtYWwuY29weSh0aGlzLmZhY2VOb3JtYWxzW2Nsb3Nlc3RGYWNlQV0pO1xuXG4gICAgdmFyIGxvY2FsUGxhbmVFcSA9IHRoaXMuZ2V0UGxhbmVDb25zdGFudE9mRmFjZShjbG9zZXN0RmFjZUEpO1xuICAgIHBsYW5lTm9ybWFsV1MuY29weShsb2NhbFBsYW5lTm9ybWFsKTtcbiAgICBxdWF0QS52bXVsdChwbGFuZU5vcm1hbFdTLHBsYW5lTm9ybWFsV1MpO1xuXG4gICAgdmFyIHBsYW5lRXFXUyA9IGxvY2FsUGxhbmVFcSAtIHBsYW5lTm9ybWFsV1MuZG90KHBvc0EpO1xuICAgIGZvciAodmFyIGk9MDsgaTxwVnR4SW4ubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVwdGggPSBwbGFuZU5vcm1hbFdTLmRvdChwVnR4SW5baV0pICsgcGxhbmVFcVdTOyAvLz8/P1xuICAgICAgICAvKmNvbnNvbGUubG9nKFwiZGVwdGggY2FsYyBmcm9tIG5vcm1hbD1cIixwbGFuZU5vcm1hbFdTLnRvU3RyaW5nKCksXCIgYW5kIGNvbnN0YW50IFwiK3BsYW5lRXFXUytcIiBhbmQgdmVydGV4IFwiLHBWdHhJbltpXS50b1N0cmluZygpLFwiIGdpdmVzIFwiK2RlcHRoKTsqL1xuICAgICAgICBpZiAoZGVwdGggPD1taW5EaXN0KXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2xhbXBlZDogZGVwdGg9XCIrZGVwdGgrXCIgdG8gbWluRGlzdD1cIisobWluRGlzdCtcIlwiKSk7XG4gICAgICAgICAgICBkZXB0aCA9IG1pbkRpc3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVwdGggPD1tYXhEaXN0KXtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHBWdHhJbltpXTtcbiAgICAgICAgICAgIGlmKGRlcHRoPD0wKXtcbiAgICAgICAgICAgICAgICAvKmNvbnNvbGUubG9nKFwiR290IGNvbnRhY3QgcG9pbnQgXCIscG9pbnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgIFwiLCBkZXB0aD1cIixkZXB0aCxcbiAgICAgICAgICAgICAgICAgIFwiY29udGFjdCBub3JtYWw9XCIsc2VwYXJhdGluZ05vcm1hbC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgXCJwbGFuZVwiLHBsYW5lTm9ybWFsV1MudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgIFwicGxhbmVDb25zdGFudFwiLHBsYW5lRXFXUyk7Ki9cbiAgICAgICAgICAgICAgICB2YXIgcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6cG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbDpwbGFuZU5vcm1hbFdTLFxuICAgICAgICAgICAgICAgICAgICBkZXB0aDogZGVwdGgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQ2xpcCBhIGZhY2UgaW4gYSBodWxsIGFnYWluc3QgdGhlIGJhY2sgb2YgYSBwbGFuZS5cbiAqIEBtZXRob2QgY2xpcEZhY2VBZ2FpbnN0UGxhbmVcbiAqIEBwYXJhbSB7QXJyYXl9IGluVmVydGljZXNcbiAqIEBwYXJhbSB7QXJyYXl9IG91dFZlcnRpY2VzXG4gKiBAcGFyYW0ge1ZlYzN9IHBsYW5lTm9ybWFsXG4gKiBAcGFyYW0ge051bWJlcn0gcGxhbmVDb25zdGFudCBUaGUgY29uc3RhbnQgaW4gdGhlIG1hdGhlbWF0aWNhbCBwbGFuZSBlcXVhdGlvblxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jbGlwRmFjZUFnYWluc3RQbGFuZSA9IGZ1bmN0aW9uKGluVmVydGljZXMsb3V0VmVydGljZXMsIHBsYW5lTm9ybWFsLCBwbGFuZUNvbnN0YW50KXtcbiAgICB2YXIgbl9kb3RfZmlyc3QsIG5fZG90X2xhc3Q7XG4gICAgdmFyIG51bVZlcnRzID0gaW5WZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICBpZihudW1WZXJ0cyA8IDIpe1xuICAgICAgICByZXR1cm4gb3V0VmVydGljZXM7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0VmVydGV4ID0gaW5WZXJ0aWNlc1tpblZlcnRpY2VzLmxlbmd0aC0xXSxcbiAgICAgICAgbGFzdFZlcnRleCA9ICAgaW5WZXJ0aWNlc1swXTtcblxuICAgIG5fZG90X2ZpcnN0ID0gcGxhbmVOb3JtYWwuZG90KGZpcnN0VmVydGV4KSArIHBsYW5lQ29uc3RhbnQ7XG5cbiAgICBmb3IodmFyIHZpID0gMDsgdmkgPCBudW1WZXJ0czsgdmkrKyl7XG4gICAgICAgIGxhc3RWZXJ0ZXggPSBpblZlcnRpY2VzW3ZpXTtcbiAgICAgICAgbl9kb3RfbGFzdCA9IHBsYW5lTm9ybWFsLmRvdChsYXN0VmVydGV4KSArIHBsYW5lQ29uc3RhbnQ7XG4gICAgICAgIGlmKG5fZG90X2ZpcnN0IDwgMCl7XG4gICAgICAgICAgICBpZihuX2RvdF9sYXN0IDwgMCl7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgPCAwLCBlbmQgPCAwLCBzbyBvdXRwdXQgbGFzdFZlcnRleFxuICAgICAgICAgICAgICAgIHZhciBuZXd2ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICBuZXd2LmNvcHkobGFzdFZlcnRleCk7XG4gICAgICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgPCAwLCBlbmQgPj0gMCwgc28gb3V0cHV0IGludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgIHZhciBuZXd2ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICBmaXJzdFZlcnRleC5sZXJwKGxhc3RWZXJ0ZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuX2RvdF9maXJzdCAvIChuX2RvdF9maXJzdCAtIG5fZG90X2xhc3QpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3dik7XG4gICAgICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKG5fZG90X2xhc3Q8MCl7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgPj0gMCwgZW5kIDwgMCBzbyBvdXRwdXQgaW50ZXJzZWN0aW9uIGFuZCBlbmRcbiAgICAgICAgICAgICAgICB2YXIgbmV3diA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgZmlyc3RWZXJ0ZXgubGVycChsYXN0VmVydGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbl9kb3RfZmlyc3QgLyAobl9kb3RfZmlyc3QgLSBuX2RvdF9sYXN0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld3YpO1xuICAgICAgICAgICAgICAgIG91dFZlcnRpY2VzLnB1c2gobmV3dik7XG4gICAgICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChsYXN0VmVydGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaXJzdFZlcnRleCA9IGxhc3RWZXJ0ZXg7XG4gICAgICAgIG5fZG90X2ZpcnN0ID0gbl9kb3RfbGFzdDtcbiAgICB9XG4gICAgcmV0dXJuIG91dFZlcnRpY2VzO1xufTtcblxuLy8gVXBkYXRlcyAud29ybGRWZXJ0aWNlcyBhbmQgc2V0cyAud29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlIHRvIGZhbHNlLlxuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29tcHV0ZVdvcmxkVmVydGljZXMgPSBmdW5jdGlvbihwb3NpdGlvbixxdWF0KXtcbiAgICB2YXIgTiA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgIHdoaWxlKHRoaXMud29ybGRWZXJ0aWNlcy5sZW5ndGggPCBOKXtcbiAgICAgICAgdGhpcy53b3JsZFZlcnRpY2VzLnB1c2goIG5ldyBWZWMzKCkgKTtcbiAgICB9XG5cbiAgICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzLFxuICAgICAgICB3b3JsZFZlcnRzID0gdGhpcy53b3JsZFZlcnRpY2VzO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgcXVhdC52bXVsdCggdmVydHNbaV0gLCB3b3JsZFZlcnRzW2ldICk7XG4gICAgICAgIHBvc2l0aW9uLnZhZGQoIHdvcmxkVmVydHNbaV0gLCB3b3JsZFZlcnRzW2ldICk7XG4gICAgfVxuXG4gICAgdGhpcy53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cbnZhciBjb21wdXRlTG9jYWxBQUJCX3dvcmxkVmVydCA9IG5ldyBWZWMzKCk7XG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jb21wdXRlTG9jYWxBQUJCID0gZnVuY3Rpb24oYWFiYm1pbixhYWJibWF4KXtcbiAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxuICAgICAgICB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXMsXG4gICAgICAgIHdvcmxkVmVydCA9IGNvbXB1dGVMb2NhbEFBQkJfd29ybGRWZXJ0O1xuXG4gICAgYWFiYm1pbi5zZXQoTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgYWFiYm1heC5zZXQoLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSk7XG5cbiAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xuICAgICAgICB2YXIgdiA9IHZlcnRpY2VzW2ldO1xuICAgICAgICBpZiAgICAgKHYueCA8IGFhYmJtaW4ueCl7XG4gICAgICAgICAgICBhYWJibWluLnggPSB2Lng7XG4gICAgICAgIH0gZWxzZSBpZih2LnggPiBhYWJibWF4Lngpe1xuICAgICAgICAgICAgYWFiYm1heC54ID0gdi54O1xuICAgICAgICB9XG4gICAgICAgIGlmICAgICAodi55IDwgYWFiYm1pbi55KXtcbiAgICAgICAgICAgIGFhYmJtaW4ueSA9IHYueTtcbiAgICAgICAgfSBlbHNlIGlmKHYueSA+IGFhYmJtYXgueSl7XG4gICAgICAgICAgICBhYWJibWF4LnkgPSB2Lnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgICAgICh2LnogPCBhYWJibWluLnope1xuICAgICAgICAgICAgYWFiYm1pbi56ID0gdi56O1xuICAgICAgICB9IGVsc2UgaWYodi56ID4gYWFiYm1heC56KXtcbiAgICAgICAgICAgIGFhYmJtYXgueiA9IHYuejtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyAud29ybGRWZXJ0aWNlcyBhbmQgc2V0cyAud29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlIHRvIGZhbHNlLlxuICogQG1ldGhvZCBjb21wdXRlV29ybGRGYWNlTm9ybWFsc1xuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jb21wdXRlV29ybGRGYWNlTm9ybWFscyA9IGZ1bmN0aW9uKHF1YXQpe1xuICAgIHZhciBOID0gdGhpcy5mYWNlTm9ybWFscy5sZW5ndGg7XG4gICAgd2hpbGUodGhpcy53b3JsZEZhY2VOb3JtYWxzLmxlbmd0aCA8IE4pe1xuICAgICAgICB0aGlzLndvcmxkRmFjZU5vcm1hbHMucHVzaCggbmV3IFZlYzMoKSApO1xuICAgIH1cblxuICAgIHZhciBub3JtYWxzID0gdGhpcy5mYWNlTm9ybWFscyxcbiAgICAgICAgd29ybGROb3JtYWxzID0gdGhpcy53b3JsZEZhY2VOb3JtYWxzO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgcXVhdC52bXVsdCggbm9ybWFsc1tpXSAsIHdvcmxkTm9ybWFsc1tpXSApO1xuICAgIH1cblxuICAgIHRoaXMud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXNcbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIC8vIEFzc3VtZSBwb2ludHMgYXJlIGRpc3RyaWJ1dGVkIHdpdGggbG9jYWwgKDAsMCwwKSBhcyBjZW50ZXJcbiAgICB2YXIgbWF4MiA9IDA7XG4gICAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgICBmb3IodmFyIGk9MCwgTj12ZXJ0cy5sZW5ndGg7IGkhPT1OOyBpKyspIHtcbiAgICAgICAgdmFyIG5vcm0yID0gdmVydHNbaV0ubm9ybTIoKTtcbiAgICAgICAgaWYobm9ybTIgPiBtYXgyKXtcbiAgICAgICAgICAgIG1heDIgPSBub3JtMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gTWF0aC5zcXJ0KG1heDIpO1xufTtcblxudmFyIHRlbXBXb3JsZFZlcnRleCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjYWxjdWxhdGVXb3JsZEFBQkJcbiAqIEBwYXJhbSB7VmVjM30gICAgICAgIHBvc1xuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSAgcXVhdFxuICogQHBhcmFtIHtWZWMzfSAgICAgICAgbWluXG4gKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBtYXhcbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24ocG9zLHF1YXQsbWluLG1heCl7XG4gICAgdmFyIG4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCwgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIHZhciBtaW54LG1pbnksbWlueixtYXh4LG1heHksbWF4ejtcbiAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xuICAgICAgICB0ZW1wV29ybGRWZXJ0ZXguY29weSh2ZXJ0c1tpXSk7XG4gICAgICAgIHF1YXQudm11bHQodGVtcFdvcmxkVmVydGV4LHRlbXBXb3JsZFZlcnRleCk7XG4gICAgICAgIHBvcy52YWRkKHRlbXBXb3JsZFZlcnRleCx0ZW1wV29ybGRWZXJ0ZXgpO1xuICAgICAgICB2YXIgdiA9IHRlbXBXb3JsZFZlcnRleDtcbiAgICAgICAgaWYgICAgICh2LnggPCBtaW54IHx8IG1pbng9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgbWlueCA9IHYueDtcbiAgICAgICAgfSBlbHNlIGlmKHYueCA+IG1heHggfHwgbWF4eD09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtYXh4ID0gdi54O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgICAgICh2LnkgPCBtaW55IHx8IG1pbnk9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgbWlueSA9IHYueTtcbiAgICAgICAgfSBlbHNlIGlmKHYueSA+IG1heHkgfHwgbWF4eT09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtYXh5ID0gdi55O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgICAgICh2LnogPCBtaW56IHx8IG1pbno9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgbWlueiA9IHYuejtcbiAgICAgICAgfSBlbHNlIGlmKHYueiA+IG1heHogfHwgbWF4ej09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtYXh6ID0gdi56O1xuICAgICAgICB9XG4gICAgfVxuICAgIG1pbi5zZXQobWlueCxtaW55LG1pbnopO1xuICAgIG1heC5zZXQobWF4eCxtYXh5LG1heHopO1xufTtcblxuLyoqXG4gKiBHZXQgYXBwcm94aW1hdGUgY29udmV4IHZvbHVtZVxuICogQG1ldGhvZCB2b2x1bWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gNC4wICogTWF0aC5QSSAqIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgLyAzLjA7XG59O1xuXG4vKipcbiAqIEdldCBhbiBhdmVyYWdlIG9mIGFsbCB0aGUgdmVydGljZXMgcG9zaXRpb25zXG4gKiBAbWV0aG9kIGdldEF2ZXJhZ2VQb2ludExvY2FsXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmdldEF2ZXJhZ2VQb2ludExvY2FsID0gZnVuY3Rpb24odGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcbiAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxuICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG4gICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKXtcbiAgICAgICAgdGFyZ2V0LnZhZGQodmVydHNbaV0sdGFyZ2V0KTtcbiAgICB9XG4gICAgdGFyZ2V0Lm11bHQoMS9uLHRhcmdldCk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFsbCBsb2NhbCBwb2ludHMuIFdpbGwgY2hhbmdlIHRoZSAudmVydGljZXNcbiAqIEBtZXRob2QgdHJhbnNmb3JtQWxsUG9pbnRzXG4gKiBAcGFyYW0gIHtWZWMzfSBvZmZzZXRcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUudHJhbnNmb3JtQWxsUG9pbnRzID0gZnVuY3Rpb24ob2Zmc2V0LHF1YXQpe1xuICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcblxuICAgIC8vIEFwcGx5IHJvdGF0aW9uXG4gICAgaWYocXVhdCl7XG4gICAgICAgIC8vIFJvdGF0ZSB2ZXJ0aWNlc1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xuICAgICAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcbiAgICAgICAgICAgIHF1YXQudm11bHQodix2KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSb3RhdGUgZmFjZSBub3JtYWxzXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLmZhY2VOb3JtYWxzW2ldO1xuICAgICAgICAgICAgcXVhdC52bXVsdCh2LHYpO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgIC8vIFJvdGF0ZSBlZGdlc1xuICAgICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy51bmlxdWVFZGdlc1tpXTtcbiAgICAgICAgICAgIHF1YXQudm11bHQodix2KTtcbiAgICAgICAgfSovXG4gICAgfVxuXG4gICAgLy8gQXBwbHkgb2Zmc2V0XG4gICAgaWYob2Zmc2V0KXtcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8bjsgaSsrKXtcbiAgICAgICAgICAgIHZhciB2ID0gdmVydHNbaV07XG4gICAgICAgICAgICB2LnZhZGQob2Zmc2V0LHYpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBwIGlzIGluc2lkZSB0aGUgcG9seWhlZHJhLiBNdXN0IGJlIGluIGxvY2FsIGNvb3Jkcy4gVGhlIHBvaW50IGxpZXMgb3V0c2lkZSBvZiB0aGUgY29udmV4IGh1bGwgb2YgdGhlIG90aGVyIHBvaW50cyBpZiBhbmQgb25seSBpZiB0aGUgZGlyZWN0aW9uIG9mIGFsbCB0aGUgdmVjdG9ycyBmcm9tIGl0IHRvIHRob3NlIG90aGVyIHBvaW50cyBhcmUgb24gbGVzcyB0aGFuIG9uZSBoYWxmIG9mIGEgc3BoZXJlIGFyb3VuZCBpdC5cbiAqIEBtZXRob2QgcG9pbnRJc0luc2lkZVxuICogQHBhcmFtICB7VmVjM30gcCAgICAgIEEgcG9pbnQgZ2l2ZW4gaW4gbG9jYWwgY29vcmRpbmF0ZXNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBDb252ZXhQb2x5aGVkcm9uX3BvaW50SXNJbnNpZGUgPSBuZXcgVmVjMygpO1xudmFyIENvbnZleFBvbHloZWRyb25fdlRvUCA9IG5ldyBWZWMzKCk7XG52YXIgQ29udmV4UG9seWhlZHJvbl92VG9Qb2ludEluc2lkZSA9IG5ldyBWZWMzKCk7XG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5wb2ludElzSW5zaWRlID0gZnVuY3Rpb24ocCl7XG4gICAgdmFyIG4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgdmVydHMgPSB0aGlzLnZlcnRpY2VzLFxuICAgICAgICBmYWNlcyA9IHRoaXMuZmFjZXMsXG4gICAgICAgIG5vcm1hbHMgPSB0aGlzLmZhY2VOb3JtYWxzO1xuICAgIHZhciBwb3NpdGl2ZVJlc3VsdCA9IG51bGw7XG4gICAgdmFyIE4gPSB0aGlzLmZhY2VzLmxlbmd0aDtcbiAgICB2YXIgcG9pbnRJbnNpZGUgPSBDb252ZXhQb2x5aGVkcm9uX3BvaW50SXNJbnNpZGU7XG4gICAgdGhpcy5nZXRBdmVyYWdlUG9pbnRMb2NhbChwb2ludEluc2lkZSk7XG4gICAgZm9yKHZhciBpPTA7IGk8TjsgaSsrKXtcbiAgICAgICAgdmFyIG51bVZlcnRpY2VzID0gdGhpcy5mYWNlc1tpXS5sZW5ndGg7XG4gICAgICAgIHZhciBuID0gbm9ybWFsc1tpXTtcbiAgICAgICAgdmFyIHYgPSB2ZXJ0c1tmYWNlc1tpXVswXV07IC8vIFdlIG9ubHkgbmVlZCBvbmUgcG9pbnQgaW4gdGhlIGZhY2VcblxuICAgICAgICAvLyBUaGlzIGRvdCBwcm9kdWN0IGRldGVybWluZXMgd2hpY2ggc2lkZSBvZiB0aGUgZWRnZSB0aGUgcG9pbnQgaXNcbiAgICAgICAgdmFyIHZUb1AgPSBDb252ZXhQb2x5aGVkcm9uX3ZUb1A7XG4gICAgICAgIHAudnN1Yih2LHZUb1ApO1xuICAgICAgICB2YXIgcjEgPSBuLmRvdCh2VG9QKTtcblxuICAgICAgICB2YXIgdlRvUG9pbnRJbnNpZGUgPSBDb252ZXhQb2x5aGVkcm9uX3ZUb1BvaW50SW5zaWRlO1xuICAgICAgICBwb2ludEluc2lkZS52c3ViKHYsdlRvUG9pbnRJbnNpZGUpO1xuICAgICAgICB2YXIgcjIgPSBuLmRvdCh2VG9Qb2ludEluc2lkZSk7XG5cbiAgICAgICAgaWYoKHIxPDAgJiYgcjI+MCkgfHwgKHIxPjAgJiYgcjI8MCkpe1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBFbmNvdW50ZXJlZCBzb21lIG90aGVyIHNpZ24uIEV4aXQuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgYWxsIGRvdCBwcm9kdWN0cyB3ZXJlIG9mIHRoZSBzYW1lIHNpZ24uXG4gICAgcmV0dXJuIHBvc2l0aXZlUmVzdWx0ID8gMSA6IC0xO1xufTtcblxuLyoqXG4gKiBHZXQgbWF4IGFuZCBtaW4gZG90IHByb2R1Y3Qgb2YgYSBjb252ZXggaHVsbCBhdCBwb3NpdGlvbiAocG9zLHF1YXQpIHByb2plY3RlZCBvbnRvIGFuIGF4aXMuIFJlc3VsdHMgYXJlIHNhdmVkIGluIHRoZSBhcnJheSBtYXhtaW4uXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHByb2plY3RcbiAqIEBwYXJhbSB7Q29udmV4UG9seWhlZHJvbn0gaHVsbFxuICogQHBhcmFtIHtWZWMzfSBheGlzXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc1xuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgcmVzdWx0WzBdIGFuZCByZXN1bHRbMV0gd2lsbCBiZSBzZXQgdG8gbWF4aW11bSBhbmQgbWluaW11bSwgcmVzcGVjdGl2ZWx5LlxuICovXG52YXIgcHJvamVjdF93b3JsZFZlcnRleCA9IG5ldyBWZWMzKCk7XG52YXIgcHJvamVjdF9sb2NhbEF4aXMgPSBuZXcgVmVjMygpO1xudmFyIHByb2plY3RfbG9jYWxPcmlnaW4gPSBuZXcgVmVjMygpO1xuQ29udmV4UG9seWhlZHJvbi5wcm9qZWN0ID0gZnVuY3Rpb24oaHVsbCwgYXhpcywgcG9zLCBxdWF0LCByZXN1bHQpe1xuICAgIHZhciBuID0gaHVsbC52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIHdvcmxkVmVydGV4ID0gcHJvamVjdF93b3JsZFZlcnRleCxcbiAgICAgICAgbG9jYWxBeGlzID0gcHJvamVjdF9sb2NhbEF4aXMsXG4gICAgICAgIG1heCA9IDAsXG4gICAgICAgIG1pbiA9IDAsXG4gICAgICAgIGxvY2FsT3JpZ2luID0gcHJvamVjdF9sb2NhbE9yaWdpbixcbiAgICAgICAgdnMgPSBodWxsLnZlcnRpY2VzO1xuXG4gICAgbG9jYWxPcmlnaW4uc2V0WmVybygpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRoZSBheGlzIHRvIGxvY2FsXG4gICAgVHJhbnNmb3JtLnZlY3RvclRvTG9jYWxGcmFtZShwb3MsIHF1YXQsIGF4aXMsIGxvY2FsQXhpcyk7XG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvcywgcXVhdCwgbG9jYWxPcmlnaW4sIGxvY2FsT3JpZ2luKTtcbiAgICB2YXIgYWRkID0gbG9jYWxPcmlnaW4uZG90KGxvY2FsQXhpcyk7XG5cbiAgICBtaW4gPSBtYXggPSB2c1swXS5kb3QobG9jYWxBeGlzKTtcblxuICAgIGZvcih2YXIgaSA9IDE7IGkgPCBuOyBpKyspe1xuICAgICAgICB2YXIgdmFsID0gdnNbaV0uZG90KGxvY2FsQXhpcyk7XG5cbiAgICAgICAgaWYodmFsID4gbWF4KXtcbiAgICAgICAgICAgIG1heCA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHZhbCA8IG1pbil7XG4gICAgICAgICAgICBtaW4gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtaW4gLT0gYWRkO1xuICAgIG1heCAtPSBhZGQ7XG5cbiAgICBpZihtaW4gPiBtYXgpe1xuICAgICAgICAvLyBJbmNvbnNpc3RlbnQgLSBzd2FwXG4gICAgICAgIHZhciB0ZW1wID0gbWluO1xuICAgICAgICBtaW4gPSBtYXg7XG4gICAgICAgIG1heCA9IHRlbXA7XG4gICAgfVxuICAgIC8vIE91dHB1dFxuICAgIHJlc3VsdFswXSA9IG1heDtcbiAgICByZXN1bHRbMV0gPSBtaW47XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBDeWxpbmRlcjtcblxudmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gcmVxdWlyZSgnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG52YXIgQ29udmV4UG9seWhlZHJvbiA9IHJlcXVpcmUoJy4vQ29udmV4UG9seWhlZHJvbicpO1xuXG4vKipcbiAqIEBjbGFzcyBDeWxpbmRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDb252ZXhQb2x5aGVkcm9uXG4gKiBAYXV0aG9yIHNjaHRlcHBlIC8gaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzVG9wXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzQm90dG9tXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gKiBAcGFyYW0ge051bWJlcn0gbnVtU2VnbWVudHMgVGhlIG51bWJlciBvZiBzZWdtZW50cyB0byBidWlsZCB0aGUgY3lsaW5kZXIgb3V0IG9mXG4gKi9cbmZ1bmN0aW9uIEN5bGluZGVyKCByYWRpdXNUb3AsIHJhZGl1c0JvdHRvbSwgaGVpZ2h0ICwgbnVtU2VnbWVudHMgKSB7XG4gICAgdmFyIE4gPSBudW1TZWdtZW50cyxcbiAgICAgICAgdmVydHMgPSBbXSxcbiAgICAgICAgYXhlcyA9IFtdLFxuICAgICAgICBmYWNlcyA9IFtdLFxuICAgICAgICBib3R0b21mYWNlID0gW10sXG4gICAgICAgIHRvcGZhY2UgPSBbXSxcbiAgICAgICAgY29zID0gTWF0aC5jb3MsXG4gICAgICAgIHNpbiA9IE1hdGguc2luO1xuXG4gICAgLy8gRmlyc3QgYm90dG9tIHBvaW50XG4gICAgdmVydHMucHVzaChuZXcgVmVjMyhyYWRpdXNCb3R0b20qY29zKDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1c0JvdHRvbSpzaW4oMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLWhlaWdodCowLjUpKTtcbiAgICBib3R0b21mYWNlLnB1c2goMCk7XG5cbiAgICAvLyBGaXJzdCB0b3AgcG9pbnRcbiAgICB2ZXJ0cy5wdXNoKG5ldyBWZWMzKHJhZGl1c1RvcCpjb3MoMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzVG9wKnNpbigwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQqMC41KSk7XG4gICAgdG9wZmFjZS5wdXNoKDEpO1xuXG4gICAgZm9yKHZhciBpPTA7IGk8TjsgaSsrKXtcbiAgICAgICAgdmFyIHRoZXRhID0gMipNYXRoLlBJL04gKiAoaSsxKTtcbiAgICAgICAgdmFyIHRoZXRhTiA9IDIqTWF0aC5QSS9OICogKGkrMC41KTtcbiAgICAgICAgaWYoaTxOLTEpe1xuICAgICAgICAgICAgLy8gQm90dG9tXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKG5ldyBWZWMzKHJhZGl1c0JvdHRvbSpjb3ModGhldGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzQm90dG9tKnNpbih0aGV0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtaGVpZ2h0KjAuNSkpO1xuICAgICAgICAgICAgYm90dG9tZmFjZS5wdXNoKDIqaSsyKTtcbiAgICAgICAgICAgIC8vIFRvcFxuICAgICAgICAgICAgdmVydHMucHVzaChuZXcgVmVjMyhyYWRpdXNUb3AqY29zKHRoZXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1c1RvcCpzaW4odGhldGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0KjAuNSkpO1xuICAgICAgICAgICAgdG9wZmFjZS5wdXNoKDIqaSszKTtcblxuICAgICAgICAgICAgLy8gRmFjZVxuICAgICAgICAgICAgZmFjZXMucHVzaChbMippKzIsIDIqaSszLCAyKmkrMSwyKmldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZhY2VzLnB1c2goWzAsMSwgMippKzEsIDIqaV0pOyAvLyBDb25uZWN0XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBeGlzOiB3ZSBjYW4gY3V0IG9mZiBoYWxmIG9mIHRoZW0gaWYgd2UgaGF2ZSBldmVuIG51bWJlciBvZiBzZWdtZW50c1xuICAgICAgICBpZihOICUgMiA9PT0gMSB8fCBpIDwgTiAvIDIpe1xuICAgICAgICAgICAgYXhlcy5wdXNoKG5ldyBWZWMzKGNvcyh0aGV0YU4pLCBzaW4odGhldGFOKSwgMCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZhY2VzLnB1c2godG9wZmFjZSk7XG4gICAgYXhlcy5wdXNoKG5ldyBWZWMzKDAsMCwxKSk7XG5cbiAgICAvLyBSZW9yZGVyIGJvdHRvbSBmYWNlXG4gICAgdmFyIHRlbXAgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTxib3R0b21mYWNlLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGVtcC5wdXNoKGJvdHRvbWZhY2VbYm90dG9tZmFjZS5sZW5ndGggLSBpIC0gMV0pO1xuICAgIH1cbiAgICBmYWNlcy5wdXNoKHRlbXApO1xuXG4gICAgdGhpcy50eXBlID0gU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTjtcbiAgICBDb252ZXhQb2x5aGVkcm9uLmNhbGwoIHRoaXMsIHZlcnRzLCBmYWNlcywgYXhlcyApO1xufVxuXG5DeWxpbmRlci5wcm90b3R5cGUgPSBuZXcgQ29udmV4UG9seWhlZHJvbigpO1xuIiwidmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpO1xudmFyIENvbnZleFBvbHloZWRyb24gPSByZXF1aXJlKCcuL0NvbnZleFBvbHloZWRyb24nKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlaWdodGZpZWxkO1xuXG4vKipcbiAqIEhlaWdodGZpZWxkIHNoYXBlIGNsYXNzLiBIZWlnaHQgZGF0YSBpcyBnaXZlbiBhcyBhbiBhcnJheS4gVGhlc2UgZGF0YSBwb2ludHMgYXJlIHNwcmVhZCBvdXQgZXZlbmx5IHdpdGggYSBnaXZlbiBkaXN0YW5jZS5cbiAqIEBjbGFzcyBIZWlnaHRmaWVsZFxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBBbiBhcnJheSBvZiBZIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHRlcnJhaW4uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblZhbHVlXSBNaW5pbXVtIHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50cyBpbiB0aGUgZGF0YSBhcnJheS4gV2lsbCBiZSBjb21wdXRlZCBhdXRvbWF0aWNhbGx5IGlmIG5vdCBnaXZlbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhWYWx1ZV0gTWF4aW11bSB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lbGVtZW50U2l6ZT0wLjFdIFdvcmxkIHNwYWNpbmcgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb24uXG4gKiBAdG9kbyBTaG91bGQgYmUgcG9zc2libGUgdG8gdXNlIGFsb25nIGFsbCBheGVzLCBub3QganVzdCB5XG4gKiBAdG9kbyBzaG91bGQgYmUgcG9zc2libGUgdG8gc2NhbGUgYWxvbmcgYWxsIGF4ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIEdlbmVyYXRlIHNvbWUgaGVpZ2h0IGRhdGEgKHktdmFsdWVzKS5cbiAqICAgICB2YXIgZGF0YSA9IFtdO1xuICogICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxMDAwOyBpKyspe1xuICogICAgICAgICB2YXIgeSA9IDAuNSAqIE1hdGguY29zKDAuMiAqIGkpO1xuICogICAgICAgICBkYXRhLnB1c2goeSk7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBDcmVhdGUgdGhlIGhlaWdodGZpZWxkIHNoYXBlXG4gKiAgICAgdmFyIGhlaWdodGZpZWxkU2hhcGUgPSBuZXcgSGVpZ2h0ZmllbGQoZGF0YSwge1xuICogICAgICAgICBlbGVtZW50U2l6ZTogMSAvLyBEaXN0YW5jZSBiZXR3ZWVuIHRoZSBkYXRhIHBvaW50cyBpbiBYIGFuZCBZIGRpcmVjdGlvbnNcbiAqICAgICB9KTtcbiAqICAgICB2YXIgaGVpZ2h0ZmllbGRCb2R5ID0gbmV3IEJvZHkoKTtcbiAqICAgICBoZWlnaHRmaWVsZEJvZHkuYWRkU2hhcGUoaGVpZ2h0ZmllbGRTaGFwZSk7XG4gKiAgICAgd29ybGQuYWRkQm9keShoZWlnaHRmaWVsZEJvZHkpO1xuICovXG5mdW5jdGlvbiBIZWlnaHRmaWVsZChkYXRhLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBtYXhWYWx1ZSA6IG51bGwsXG4gICAgICAgIG1pblZhbHVlIDogbnVsbCxcbiAgICAgICAgZWxlbWVudFNpemUgOiAxXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBudW1iZXJzLCBvciBoZWlnaHQgdmFsdWVzLCB0aGF0IGFyZSBzcHJlYWQgb3V0IGFsb25nIHRoZSB4IGF4aXMuXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gZGF0YVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAvKipcbiAgICAgKiBNYXggdmFsdWUgb2YgdGhlIGRhdGFcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4VmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLm1heFZhbHVlID0gb3B0aW9ucy5tYXhWYWx1ZTtcblxuICAgIC8qKlxuICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgZGF0YVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5WYWx1ZVxuICAgICAqL1xuICAgIHRoaXMubWluVmFsdWUgPSBvcHRpb25zLm1pblZhbHVlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50U2l6ZVxuICAgICAqIEB0b2RvIGVsZW1lbnRTaXplWCBhbmQgWVxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudFNpemUgPSBvcHRpb25zLmVsZW1lbnRTaXplO1xuXG4gICAgaWYob3B0aW9ucy5taW5WYWx1ZSA9PT0gbnVsbCl7XG4gICAgICAgIHRoaXMudXBkYXRlTWluVmFsdWUoKTtcbiAgICB9XG4gICAgaWYob3B0aW9ucy5tYXhWYWx1ZSA9PT0gbnVsbCl7XG4gICAgICAgIHRoaXMudXBkYXRlTWF4VmFsdWUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNhY2hlRW5hYmxlZCA9IHRydWU7XG5cbiAgICBTaGFwZS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5waWxsYXJDb252ZXggPSBuZXcgQ29udmV4UG9seWhlZHJvbigpO1xuICAgIHRoaXMucGlsbGFyT2Zmc2V0ID0gbmV3IFZlYzMoKTtcblxuICAgIHRoaXMudHlwZSA9IFNoYXBlLnR5cGVzLkhFSUdIVEZJRUxEO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcblxuICAgIC8vIFwiaV9qX2lzVXBwZXJcIiA9PiB7IGNvbnZleDogLi4uLCBvZmZzZXQ6IC4uLiB9XG4gICAgLy8gZm9yIGV4YW1wbGU6XG4gICAgLy8gX2NhY2hlZFBpbGxhcnNbXCIwXzJfMVwiXVxuICAgIHRoaXMuX2NhY2hlZFBpbGxhcnMgPSB7fTtcbn1cbkhlaWdodGZpZWxkLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuXG4vKipcbiAqIENhbGwgd2hlbmV2ZXIgeW91IGNoYW5nZSB0aGUgZGF0YSBhcnJheS5cbiAqIEBtZXRob2QgdXBkYXRlXG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuX2NhY2hlZFBpbGxhcnMgPSB7fTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSAubWluVmFsdWUgcHJvcGVydHlcbiAqIEBtZXRob2QgdXBkYXRlTWluVmFsdWVcbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZU1pblZhbHVlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgbWluVmFsdWUgPSBkYXRhWzBdWzBdO1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSBkYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IGRhdGFbaV0ubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgdmFyIHYgPSBkYXRhW2ldW2pdO1xuICAgICAgICAgICAgaWYodiA8IG1pblZhbHVlKXtcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5taW5WYWx1ZSA9IG1pblZhbHVlO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIC5tYXhWYWx1ZSBwcm9wZXJ0eVxuICogQG1ldGhvZCB1cGRhdGVNYXhWYWx1ZVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlTWF4VmFsdWUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBtYXhWYWx1ZSA9IGRhdGFbMF1bMF07XG4gICAgZm9yKHZhciBpPTA7IGkgIT09IGRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICBmb3IodmFyIGo9MDsgaiAhPT0gZGF0YVtpXS5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICB2YXIgdiA9IGRhdGFbaV1bal07XG4gICAgICAgICAgICBpZih2ID4gbWF4VmFsdWUpe1xuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1heFZhbHVlID0gbWF4VmFsdWU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaGVpZ2h0IHZhbHVlIGF0IGFuIGluZGV4LiBEb24ndCBmb3JnZXQgdG8gdXBkYXRlIG1heFZhbHVlIGFuZCBtaW5WYWx1ZSBhZnRlciB5b3UncmUgZG9uZS5cbiAqIEBtZXRob2Qgc2V0SGVpZ2h0VmFsdWVBdEluZGV4XG4gKiBAcGFyYW0ge2ludGVnZXJ9IHhpXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHlpXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnNldEhlaWdodFZhbHVlQXRJbmRleCA9IGZ1bmN0aW9uKHhpLCB5aSwgdmFsdWUpe1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGRhdGFbeGldW3lpXSA9IHZhbHVlO1xuXG4gICAgLy8gSW52YWxpZGF0ZSBjYWNoZVxuICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWksIGZhbHNlKTtcbiAgICBpZih4aSA+IDApe1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSAtIDEsIHlpLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmKHlpID4gMCl7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWkgLSAxLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSAtIDEsIGZhbHNlKTtcbiAgICB9XG4gICAgaWYoeWkgPiAwICYmIHhpID4gMCl7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSAtIDEsIHlpIC0gMSwgdHJ1ZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgbWF4L21pbiBpbiBhIHJlY3RhbmdsZSBpbiB0aGUgbWF0cml4IGRhdGFcbiAqIEBtZXRob2QgZ2V0UmVjdE1pbk1heFxuICogQHBhcmFtICB7aW50ZWdlcn0gaU1pblhcbiAqIEBwYXJhbSAge2ludGVnZXJ9IGlNaW5ZXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBpTWF4WFxuICogQHBhcmFtICB7aW50ZWdlcn0gaU1heFlcbiAqIEBwYXJhbSAge2FycmF5fSBbcmVzdWx0XSBBbiBhcnJheSB0byBzdG9yZSB0aGUgcmVzdWx0cyBpbi5cbiAqIEByZXR1cm4ge2FycmF5fSBUaGUgcmVzdWx0IGFycmF5LCBpZiBpdCB3YXMgcGFzc2VkIGluLiBNaW5pbXVtIHdpbGwgYmUgYXQgcG9zaXRpb24gMCBhbmQgbWF4IGF0IDEuXG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRSZWN0TWluTWF4ID0gZnVuY3Rpb24gKGlNaW5YLCBpTWluWSwgaU1heFgsIGlNYXhZLCByZXN1bHQpIHtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgICAvLyBHZXQgbWF4IGFuZCBtaW4gb2YgdGhlIGRhdGFcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgbWF4ID0gdGhpcy5taW5WYWx1ZTsgLy8gU2V0IGZpcnN0IHZhbHVlXG4gICAgZm9yKHZhciBpID0gaU1pblg7IGkgPD0gaU1heFg7IGkrKyl7XG4gICAgICAgIGZvcih2YXIgaiA9IGlNaW5ZOyBqIDw9IGlNYXhZOyBqKyspe1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaV1bal07XG4gICAgICAgICAgICBpZihoZWlnaHQgPiBtYXgpe1xuICAgICAgICAgICAgICAgIG1heCA9IGhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdFswXSA9IHRoaXMubWluVmFsdWU7XG4gICAgcmVzdWx0WzFdID0gbWF4O1xufTtcblxuXG5cbi8qKlxuICogR2V0IHRoZSBpbmRleCBvZiBhIGxvY2FsIHBvc2l0aW9uIG9uIHRoZSBoZWlnaHRmaWVsZC4gVGhlIGluZGV4ZXMgaW5kaWNhdGUgdGhlIHJlY3RhbmdsZXMsIHNvIGlmIHlvdXIgdGVycmFpbiBpcyBtYWRlIG9mIE4geCBOIGhlaWdodCBkYXRhIHBvaW50cywgeW91IHdpbGwgaGF2ZSByZWN0YW5nbGUgaW5kZXhlcyByYW5naW5nIGZyb20gMCB0byBOLTEuXG4gKiBAbWV0aG9kIGdldEluZGV4T2ZQb3NpdGlvblxuICogQHBhcmFtICB7bnVtYmVyfSB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSAge2FycmF5fSByZXN1bHQgVHdvLWVsZW1lbnQgYXJyYXlcbiAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wIElmIHRoZSBwb3NpdGlvbiBzaG91bGQgYmUgY2xhbXBlZCB0byB0aGUgaGVpZ2h0ZmllbGQgZWRnZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRJbmRleE9mUG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgcmVzdWx0LCBjbGFtcCkge1xuXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIHcgPSB0aGlzLmVsZW1lbnRTaXplO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciB4aSA9IE1hdGguZmxvb3IoeCAvIHcpO1xuICAgIHZhciB5aSA9IE1hdGguZmxvb3IoeSAvIHcpO1xuXG4gICAgcmVzdWx0WzBdID0geGk7XG4gICAgcmVzdWx0WzFdID0geWk7XG5cbiAgICBpZihjbGFtcCl7XG4gICAgICAgIC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzXG4gICAgICAgIGlmKHhpIDwgMCl7IHhpID0gMDsgfVxuICAgICAgICBpZih5aSA8IDApeyB5aSA9IDA7IH1cbiAgICAgICAgaWYoeGkgPj0gZGF0YS5sZW5ndGggLSAxKXsgeGkgPSBkYXRhLmxlbmd0aCAtIDE7IH1cbiAgICAgICAgaWYoeWkgPj0gZGF0YVswXS5sZW5ndGggLSAxKXsgeWkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cbiAgICB9XG5cbiAgICAvLyBCYWlsIG91dCBpZiB3ZSBhcmUgb3V0IG9mIHRoZSB0ZXJyYWluXG4gICAgaWYoeGkgPCAwIHx8IHlpIDwgMCB8fCB4aSA+PSBkYXRhLmxlbmd0aC0xIHx8IHlpID49IGRhdGFbMF0ubGVuZ3RoLTEpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbnZhciBnZXRIZWlnaHRBdF9pZHggPSBbXTtcbnZhciBnZXRIZWlnaHRBdF93ZWlnaHRzID0gbmV3IFZlYzMoKTtcbnZhciBnZXRIZWlnaHRBdF9hID0gbmV3IFZlYzMoKTtcbnZhciBnZXRIZWlnaHRBdF9iID0gbmV3IFZlYzMoKTtcbnZhciBnZXRIZWlnaHRBdF9jID0gbmV3IFZlYzMoKTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldFRyaWFuZ2xlQXQgPSBmdW5jdGlvbih4LCB5LCBlZGdlQ2xhbXAsIGEsIGIsIGMpe1xuICAgIHZhciBpZHggPSBnZXRIZWlnaHRBdF9pZHg7XG4gICAgdGhpcy5nZXRJbmRleE9mUG9zaXRpb24oeCwgeSwgaWR4LCBlZGdlQ2xhbXApO1xuICAgIHZhciB4aSA9IGlkeFswXTtcbiAgICB2YXIgeWkgPSBpZHhbMV07XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBpZihlZGdlQ2xhbXApe1xuICAgICAgICB4aSA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gMiwgTWF0aC5tYXgoMCwgeGkpKTtcbiAgICAgICAgeWkgPSBNYXRoLm1pbihkYXRhWzBdLmxlbmd0aCAtIDIsIE1hdGgubWF4KDAsIHlpKSk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRTaXplID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICB2YXIgbG93ZXJEaXN0MiA9IE1hdGgucG93KHggLyBlbGVtZW50U2l6ZSAtIHhpLCAyKSArIE1hdGgucG93KHkgLyBlbGVtZW50U2l6ZSAtIHlpLCAyKTtcbiAgICB2YXIgdXBwZXJEaXN0MiA9IE1hdGgucG93KHggLyBlbGVtZW50U2l6ZSAtICh4aSArIDEpLCAyKSArIE1hdGgucG93KHkgLyBlbGVtZW50U2l6ZSAtICh5aSArIDEpLCAyKTtcbiAgICB2YXIgdXBwZXIgPSBsb3dlckRpc3QyID4gdXBwZXJEaXN0MjtcbiAgICB0aGlzLmdldFRyaWFuZ2xlKHhpLCB5aSwgdXBwZXIsIGEsIGIsIGMpO1xuICAgIHJldHVybiB1cHBlcjtcbn07XG5cbnZhciBnZXROb3JtYWxBdF9hID0gbmV3IFZlYzMoKTtcbnZhciBnZXROb3JtYWxBdF9iID0gbmV3IFZlYzMoKTtcbnZhciBnZXROb3JtYWxBdF9jID0gbmV3IFZlYzMoKTtcbnZhciBnZXROb3JtYWxBdF9lMCA9IG5ldyBWZWMzKCk7XG52YXIgZ2V0Tm9ybWFsQXRfZTEgPSBuZXcgVmVjMygpO1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldE5vcm1hbEF0ID0gZnVuY3Rpb24oeCwgeSwgZWRnZUNsYW1wLCByZXN1bHQpe1xuICAgIHZhciBhID0gZ2V0Tm9ybWFsQXRfYTtcbiAgICB2YXIgYiA9IGdldE5vcm1hbEF0X2I7XG4gICAgdmFyIGMgPSBnZXROb3JtYWxBdF9jO1xuICAgIHZhciBlMCA9IGdldE5vcm1hbEF0X2UwO1xuICAgIHZhciBlMSA9IGdldE5vcm1hbEF0X2UxO1xuICAgIHRoaXMuZ2V0VHJpYW5nbGVBdCh4LCB5LCBlZGdlQ2xhbXAsIGEsIGIsIGMpO1xuICAgIGIudnN1YihhLCBlMCk7XG4gICAgYy52c3ViKGEsIGUxKTtcbiAgICBlMC5jcm9zcyhlMSwgcmVzdWx0KTtcbiAgICByZXN1bHQubm9ybWFsaXplKCk7XG59O1xuXG5cbi8qKlxuICogR2V0IGFuIEFBQkIgb2YgYSBzcXVhcmUgaW4gdGhlIGhlaWdodGZpZWxkXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHhpXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHlpXG4gKiBAcGFyYW0gIHtBQUJCfSByZXN1bHRcbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldEFhYmJBdEluZGV4ID0gZnVuY3Rpb24oeGksIHlpLCByZXN1bHQpe1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBlbGVtZW50U2l6ZSA9IHRoaXMuZWxlbWVudFNpemU7XG5cbiAgICByZXN1bHQubG93ZXJCb3VuZC5zZXQoXG4gICAgICAgIHhpICogZWxlbWVudFNpemUsXG4gICAgICAgIHlpICogZWxlbWVudFNpemUsXG4gICAgICAgIGRhdGFbeGldW3lpXVxuICAgICk7XG4gICAgcmVzdWx0LnVwcGVyQm91bmQuc2V0KFxuICAgICAgICAoeGkgKyAxKSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAoeWkgKyAxKSAqIGVsZW1lbnRTaXplLFxuICAgICAgICBkYXRhW3hpICsgMV1beWkgKyAxXVxuICAgICk7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBoZWlnaHQgaW4gdGhlIGhlaWdodGZpZWxkIGF0IGEgZ2l2ZW4gcG9zaXRpb25cbiAqIEBwYXJhbSAge251bWJlcn0geFxuICogQHBhcmFtICB7bnVtYmVyfSB5XG4gKiBAcGFyYW0gIHtib29sZWFufSBlZGdlQ2xhbXBcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldEhlaWdodEF0ID0gZnVuY3Rpb24oeCwgeSwgZWRnZUNsYW1wKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgYSA9IGdldEhlaWdodEF0X2E7XG4gICAgdmFyIGIgPSBnZXRIZWlnaHRBdF9iO1xuICAgIHZhciBjID0gZ2V0SGVpZ2h0QXRfYztcbiAgICB2YXIgaWR4ID0gZ2V0SGVpZ2h0QXRfaWR4O1xuXG4gICAgdGhpcy5nZXRJbmRleE9mUG9zaXRpb24oeCwgeSwgaWR4LCBlZGdlQ2xhbXApO1xuICAgIHZhciB4aSA9IGlkeFswXTtcbiAgICB2YXIgeWkgPSBpZHhbMV07XG4gICAgaWYoZWRnZUNsYW1wKXtcbiAgICAgICAgeGkgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIDIsIE1hdGgubWF4KDAsIHhpKSk7XG4gICAgICAgIHlpID0gTWF0aC5taW4oZGF0YVswXS5sZW5ndGggLSAyLCBNYXRoLm1heCgwLCB5aSkpO1xuICAgIH1cbiAgICB2YXIgdXBwZXIgPSB0aGlzLmdldFRyaWFuZ2xlQXQoeCwgeSwgZWRnZUNsYW1wLCBhLCBiLCBjKTtcbiAgICBiYXJ5Y2VudHJpY1dlaWdodHMoeCwgeSwgYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgZ2V0SGVpZ2h0QXRfd2VpZ2h0cyk7XG5cbiAgICB2YXIgdyA9IGdldEhlaWdodEF0X3dlaWdodHM7XG5cbiAgICBpZih1cHBlcil7XG5cbiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgIHJldHVybiBkYXRhW3hpICsgMV1beWkgKyAxXSAqIHcueCArIGRhdGFbeGldW3lpICsgMV0gKiB3LnkgKyBkYXRhW3hpICsgMV1beWldICogdy56O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHNcbiAgICAgICAgcmV0dXJuIGRhdGFbeGldW3lpXSAqIHcueCArIGRhdGFbeGkgKyAxXVt5aV0gKiB3LnkgKyBkYXRhW3hpXVt5aSArIDFdICogdy56O1xuICAgIH1cbn07XG5cbi8vIGZyb20gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFyeWNlbnRyaWNfY29vcmRpbmF0ZV9zeXN0ZW1cbmZ1bmN0aW9uIGJhcnljZW50cmljV2VpZ2h0cyh4LCB5LCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCByZXN1bHQpe1xuICAgIHJlc3VsdC54ID0gKChieSAtIGN5KSAqICh4IC0gY3gpICsgKGN4IC0gYngpICogKHkgLSBjeSkpIC8gKChieSAtIGN5KSAqIChheCAtIGN4KSArIChjeCAtIGJ4KSAqIChheSAtIGN5KSk7XG4gICAgcmVzdWx0LnkgPSAoKGN5IC0gYXkpICogKHggLSBjeCkgKyAoYXggLSBjeCkgKiAoeSAtIGN5KSkgLyAoKGJ5IC0gY3kpICogKGF4IC0gY3gpICsgKGN4IC0gYngpICogKGF5IC0gY3kpKTtcbiAgICByZXN1bHQueiA9IDEgLSByZXN1bHQueCAtIHJlc3VsdC55O1xufVxuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0Q2FjaGVDb252ZXhUcmlhbmdsZVBpbGxhcktleSA9IGZ1bmN0aW9uKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSl7XG4gICAgcmV0dXJuIHhpICsgJ18nICsgeWkgKyAnXycgKyAoZ2V0VXBwZXJUcmlhbmdsZSA/IDEgOiAwKTtcbn07XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhciA9IGZ1bmN0aW9uKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSl7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnNldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyID0gZnVuY3Rpb24oeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlLCBjb252ZXgsIG9mZnNldCl7XG4gICAgdGhpcy5fY2FjaGVkUGlsbGFyc1t0aGlzLmdldENhY2hlQ29udmV4VHJpYW5nbGVQaWxsYXJLZXkoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKV0gPSB7XG4gICAgICAgIGNvbnZleDogY29udmV4LFxuICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgIH07XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhciA9IGZ1bmN0aW9uKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSl7XG4gICAgZGVsZXRlIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldO1xufTtcblxuLyoqXG4gKiBHZXQgYSB0cmlhbmdsZSBmcm9tIHRoZSBoZWlnaHRmaWVsZFxuICogQHBhcmFtICB7bnVtYmVyfSB4aVxuICogQHBhcmFtICB7bnVtYmVyfSB5aVxuICogQHBhcmFtICB7Ym9vbGVhbn0gdXBwZXJcbiAqIEBwYXJhbSAge1ZlYzN9IGFcbiAqIEBwYXJhbSAge1ZlYzN9IGJcbiAqIEBwYXJhbSAge1ZlYzN9IGNcbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldFRyaWFuZ2xlID0gZnVuY3Rpb24oeGksIHlpLCB1cHBlciwgYSwgYiwgYyl7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGVsZW1lbnRTaXplID0gdGhpcy5lbGVtZW50U2l6ZTtcblxuICAgIGlmKHVwcGVyKXtcblxuICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHNcbiAgICAgICAgYS5zZXQoXG4gICAgICAgICAgICAoeGkgKyAxKSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgKHlpICsgMSkgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIGRhdGFbeGkgKyAxXVt5aSArIDFdXG4gICAgICAgICk7XG4gICAgICAgIGIuc2V0KFxuICAgICAgICAgICAgeGkgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICh5aSArIDEpICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICBkYXRhW3hpXVt5aSArIDFdXG4gICAgICAgICk7XG4gICAgICAgIGMuc2V0KFxuICAgICAgICAgICAgKHhpICsgMSkgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIHlpICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICBkYXRhW3hpICsgMV1beWldXG4gICAgICAgICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFRvcCB0cmlhbmdsZSB2ZXJ0c1xuICAgICAgICBhLnNldChcbiAgICAgICAgICAgIHhpICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICB5aSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aV1beWldXG4gICAgICAgICk7XG4gICAgICAgIGIuc2V0KFxuICAgICAgICAgICAgKHhpICsgMSkgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIHlpICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICBkYXRhW3hpICsgMV1beWldXG4gICAgICAgICk7XG4gICAgICAgIGMuc2V0KFxuICAgICAgICAgICAgeGkgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICh5aSArIDEpICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICBkYXRhW3hpXVt5aSArIDFdXG4gICAgICAgICk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSB0cmlhbmdsZSBpbiB0aGUgdGVycmFpbiBpbiB0aGUgZm9ybSBvZiBhIHRyaWFuZ3VsYXIgY29udmV4IHNoYXBlLlxuICogQG1ldGhvZCBnZXRDb252ZXhUcmlhbmdsZVBpbGxhclxuICogQHBhcmFtICB7aW50ZWdlcn0gaVxuICogQHBhcmFtICB7aW50ZWdlcn0galxuICogQHBhcmFtICB7Ym9vbGVhbn0gZ2V0VXBwZXJUcmlhbmdsZVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIgPSBmdW5jdGlvbih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpe1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnBpbGxhckNvbnZleDtcbiAgICB2YXIgb2Zmc2V0UmVzdWx0ID0gdGhpcy5waWxsYXJPZmZzZXQ7XG5cbiAgICBpZih0aGlzLmNhY2hlRW5hYmxlZCl7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpO1xuICAgICAgICBpZihkYXRhKXtcbiAgICAgICAgICAgIHRoaXMucGlsbGFyQ29udmV4ID0gZGF0YS5jb252ZXg7XG4gICAgICAgICAgICB0aGlzLnBpbGxhck9mZnNldCA9IGRhdGEub2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gbmV3IENvbnZleFBvbHloZWRyb24oKTtcbiAgICAgICAgb2Zmc2V0UmVzdWx0ID0gbmV3IFZlYzMoKTtcblxuICAgICAgICB0aGlzLnBpbGxhckNvbnZleCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5waWxsYXJPZmZzZXQgPSBvZmZzZXRSZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGVsZW1lbnRTaXplID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICB2YXIgZmFjZXMgPSByZXN1bHQuZmFjZXM7XG5cbiAgICAvLyBSZXVzZSB2ZXJ0cyBpZiBwb3NzaWJsZVxuICAgIHJlc3VsdC52ZXJ0aWNlcy5sZW5ndGggPSA2O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgIGlmKCFyZXN1bHQudmVydGljZXNbaV0pe1xuICAgICAgICAgICAgcmVzdWx0LnZlcnRpY2VzW2ldID0gbmV3IFZlYzMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldXNlIGZhY2VzIGlmIHBvc3NpYmxlXG4gICAgZmFjZXMubGVuZ3RoID0gNTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBpZighZmFjZXNbaV0pe1xuICAgICAgICAgICAgZmFjZXNbaV0gPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2ZXJ0cyA9IHJlc3VsdC52ZXJ0aWNlcztcblxuICAgIHZhciBoID0gKE1hdGgubWluKFxuICAgICAgICBkYXRhW3hpXVt5aV0sXG4gICAgICAgIGRhdGFbeGkrMV1beWldLFxuICAgICAgICBkYXRhW3hpXVt5aSsxXSxcbiAgICAgICAgZGF0YVt4aSsxXVt5aSsxXVxuICAgICkgLSB0aGlzLm1pblZhbHVlICkgLyAyICsgdGhpcy5taW5WYWx1ZTtcblxuICAgIGlmICghZ2V0VXBwZXJUcmlhbmdsZSkge1xuXG4gICAgICAgIC8vIENlbnRlciBvZiB0aGUgdHJpYW5nbGUgcGlsbGFyIC0gYWxsIHBvbHlnb25zIGFyZSBnaXZlbiByZWxhdGl2ZSB0byB0aGlzIG9uZVxuICAgICAgICBvZmZzZXRSZXN1bHQuc2V0KFxuICAgICAgICAgICAgKHhpICsgMC4yNSkgKiBlbGVtZW50U2l6ZSwgLy8gc29ydCBvZiBjZW50ZXIgb2YgYSB0cmlhbmdsZVxuICAgICAgICAgICAgKHlpICsgMC4yNSkgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIGggLy8gdmVydGljYWwgY2VudGVyXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgIHZlcnRzWzBdLnNldChcbiAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aV1beWldIC0gaFxuICAgICAgICApO1xuICAgICAgICB2ZXJ0c1sxXS5zZXQoXG4gICAgICAgICAgICAwLjc1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpXSAtIGhcbiAgICAgICAgKTtcbiAgICAgICAgdmVydHNbMl0uc2V0KFxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIDAuNzUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIGRhdGFbeGldW3lpICsgMV0gLSBoXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYm90dG9tIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgIHZlcnRzWzNdLnNldChcbiAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLWgtMVxuICAgICAgICApO1xuICAgICAgICB2ZXJ0c1s0XS5zZXQoXG4gICAgICAgICAgICAwLjc1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLWgtMVxuICAgICAgICApO1xuICAgICAgICB2ZXJ0c1s1XS5zZXQoXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgMC43NSAgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIC1oLTFcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB0b3AgdHJpYW5nbGVcbiAgICAgICAgZmFjZXNbMF1bMF0gPSAwO1xuICAgICAgICBmYWNlc1swXVsxXSA9IDE7XG4gICAgICAgIGZhY2VzWzBdWzJdID0gMjtcblxuICAgICAgICAvLyBib3R0b20gdHJpYW5nbGVcbiAgICAgICAgZmFjZXNbMV1bMF0gPSA1O1xuICAgICAgICBmYWNlc1sxXVsxXSA9IDQ7XG4gICAgICAgIGZhY2VzWzFdWzJdID0gMztcblxuICAgICAgICAvLyAteCBmYWNpbmcgcXVhZFxuICAgICAgICBmYWNlc1syXVswXSA9IDA7XG4gICAgICAgIGZhY2VzWzJdWzFdID0gMjtcbiAgICAgICAgZmFjZXNbMl1bMl0gPSA1O1xuICAgICAgICBmYWNlc1syXVszXSA9IDM7XG5cbiAgICAgICAgLy8gLXkgZmFjaW5nIHF1YWRcbiAgICAgICAgZmFjZXNbM11bMF0gPSAxO1xuICAgICAgICBmYWNlc1szXVsxXSA9IDA7XG4gICAgICAgIGZhY2VzWzNdWzJdID0gMztcbiAgICAgICAgZmFjZXNbM11bM10gPSA0O1xuXG4gICAgICAgIC8vICt4eSBmYWNpbmcgcXVhZFxuICAgICAgICBmYWNlc1s0XVswXSA9IDQ7XG4gICAgICAgIGZhY2VzWzRdWzFdID0gNTtcbiAgICAgICAgZmFjZXNbNF1bMl0gPSAyO1xuICAgICAgICBmYWNlc1s0XVszXSA9IDE7XG5cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gQ2VudGVyIG9mIHRoZSB0cmlhbmdsZSBwaWxsYXIgLSBhbGwgcG9seWdvbnMgYXJlIGdpdmVuIHJlbGF0aXZlIHRvIHRoaXMgb25lXG4gICAgICAgIG9mZnNldFJlc3VsdC5zZXQoXG4gICAgICAgICAgICAoeGkgKyAwLjc1KSAqIGVsZW1lbnRTaXplLCAvLyBzb3J0IG9mIGNlbnRlciBvZiBhIHRyaWFuZ2xlXG4gICAgICAgICAgICAoeWkgKyAwLjc1KSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgaCAvLyB2ZXJ0aWNhbCBjZW50ZXJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHNcbiAgICAgICAgdmVydHNbMF0uc2V0KFxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpICsgMV0gLSBoXG4gICAgICAgICk7XG4gICAgICAgIHZlcnRzWzFdLnNldChcbiAgICAgICAgICAgIC0wLjc1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAwLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICBkYXRhW3hpXVt5aSArIDFdIC0gaFxuICAgICAgICApO1xuICAgICAgICB2ZXJ0c1syXS5zZXQoXG4gICAgICAgICAgICAwLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC43NSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpXSAtIGhcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBib3R0b20gdHJpYW5nbGUgdmVydHNcbiAgICAgICAgdmVydHNbM10uc2V0KFxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLSBoLTFcbiAgICAgICAgKTtcbiAgICAgICAgdmVydHNbNF0uc2V0KFxuICAgICAgICAgICAgLTAuNzUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIC0gaC0xXG4gICAgICAgICk7XG4gICAgICAgIHZlcnRzWzVdLnNldChcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIC0wLjc1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtIGgtMVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFRvcCB0cmlhbmdsZVxuICAgICAgICBmYWNlc1swXVswXSA9IDA7XG4gICAgICAgIGZhY2VzWzBdWzFdID0gMTtcbiAgICAgICAgZmFjZXNbMF1bMl0gPSAyO1xuXG4gICAgICAgIC8vIGJvdHRvbSB0cmlhbmdsZVxuICAgICAgICBmYWNlc1sxXVswXSA9IDU7XG4gICAgICAgIGZhY2VzWzFdWzFdID0gNDtcbiAgICAgICAgZmFjZXNbMV1bMl0gPSAzO1xuXG4gICAgICAgIC8vICt4IGZhY2luZyBxdWFkXG4gICAgICAgIGZhY2VzWzJdWzBdID0gMjtcbiAgICAgICAgZmFjZXNbMl1bMV0gPSA1O1xuICAgICAgICBmYWNlc1syXVsyXSA9IDM7XG4gICAgICAgIGZhY2VzWzJdWzNdID0gMDtcblxuICAgICAgICAvLyAreSBmYWNpbmcgcXVhZFxuICAgICAgICBmYWNlc1szXVswXSA9IDM7XG4gICAgICAgIGZhY2VzWzNdWzFdID0gNDtcbiAgICAgICAgZmFjZXNbM11bMl0gPSAxO1xuICAgICAgICBmYWNlc1szXVszXSA9IDA7XG5cbiAgICAgICAgLy8gLXh5IGZhY2luZyBxdWFkXG4gICAgICAgIGZhY2VzWzRdWzBdID0gMTtcbiAgICAgICAgZmFjZXNbNF1bMV0gPSA0O1xuICAgICAgICBmYWNlc1s0XVsyXSA9IDU7XG4gICAgICAgIGZhY2VzWzRdWzNdID0gMjtcbiAgICB9XG5cbiAgICByZXN1bHQuY29tcHV0ZU5vcm1hbHMoKTtcbiAgICByZXN1bHQuY29tcHV0ZUVkZ2VzKCk7XG4gICAgcmVzdWx0LnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG5cbiAgICB0aGlzLnNldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSwgcmVzdWx0LCBvZmZzZXRSZXN1bHQpO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3MsIHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGFyZ2V0LnNldCgwLCAwLCAwKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7IC8vIFRoZSB0ZXJyYWluIGlzIGluZmluaXRlXG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24ocG9zLCBxdWF0LCBtaW4sIG1heCl7XG4gICAgLy8gVE9ETzogZG8gaXQgcHJvcGVybHlcbiAgICBtaW4uc2V0KC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUpO1xuICAgIG1heC5zZXQoTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIC8vIFVzZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBtaW4vbWF4IHZhbHVlc1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICBzID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gbmV3IFZlYzMoZGF0YS5sZW5ndGggKiBzLCBkYXRhWzBdLmxlbmd0aCAqIHMsIE1hdGgubWF4KE1hdGguYWJzKHRoaXMubWF4VmFsdWUpLCBNYXRoLmFicyh0aGlzLm1pblZhbHVlKSkpLm5vcm0oKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgaGVpZ2h0IHZhbHVlcyBmcm9tIGFuIGltYWdlLiBDdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3Nlci5cbiAqIEBtZXRob2Qgc2V0SGVpZ2h0c0Zyb21JbWFnZVxuICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAqIEBwYXJhbSB7VmVjM30gc2NhbGVcbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnNldEhlaWdodHNGcm9tSW1hZ2UgPSBmdW5jdGlvbihpbWFnZSwgc2NhbGUpe1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgIHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcblxuICAgIHZhciBtYXRyaXggPSB0aGlzLmRhdGE7XG4gICAgbWF0cml4Lmxlbmd0aCA9IDA7XG4gICAgdGhpcy5lbGVtZW50U2l6ZSA9IE1hdGguYWJzKHNjYWxlLngpIC8gaW1hZ2VEYXRhLndpZHRoO1xuICAgIGZvcih2YXIgaT0wOyBpPGltYWdlRGF0YS5oZWlnaHQ7IGkrKyl7XG4gICAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8aW1hZ2VEYXRhLndpZHRoOyBqKyspe1xuICAgICAgICAgICAgdmFyIGEgPSBpbWFnZURhdGEuZGF0YVsoaSppbWFnZURhdGEuaGVpZ2h0ICsgaikgKiA0XTtcbiAgICAgICAgICAgIHZhciBiID0gaW1hZ2VEYXRhLmRhdGFbKGkqaW1hZ2VEYXRhLmhlaWdodCArIGopICogNCArIDFdO1xuICAgICAgICAgICAgdmFyIGMgPSBpbWFnZURhdGEuZGF0YVsoaSppbWFnZURhdGEuaGVpZ2h0ICsgaikgKiA0ICsgMl07XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gKGEgKyBiICsgYykgLyA0IC8gMjU1ICogc2NhbGUuejtcbiAgICAgICAgICAgIGlmKHNjYWxlLnggPCAwKXtcbiAgICAgICAgICAgICAgICByb3cucHVzaChoZWlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3cudW5zaGlmdChoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKHNjYWxlLnkgPCAwKXtcbiAgICAgICAgICAgIG1hdHJpeC51bnNoaWZ0KHJvdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRyaXgucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTWF4VmFsdWUoKTtcbiAgICB0aGlzLnVwZGF0ZU1pblZhbHVlKCk7XG4gICAgdGhpcy51cGRhdGUoKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBQYXJ0aWNsZTtcblxudmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcblxuLyoqXG4gKiBQYXJ0aWNsZSBzaGFwZS5cbiAqIEBjbGFzcyBQYXJ0aWNsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICovXG5mdW5jdGlvbiBQYXJ0aWNsZSgpe1xuICAgIFNoYXBlLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnR5cGUgPSBTaGFwZS50eXBlcy5QQVJUSUNMRTtcbn1cblBhcnRpY2xlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuUGFydGljbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFydGljbGU7XG5cbi8qKlxuICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5QYXJ0aWNsZS5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcyx0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHRhcmdldC5zZXQoMCwgMCwgMCk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cblBhcnRpY2xlLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAwO1xufTtcblxuUGFydGljbGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gMDtcbn07XG5cblBhcnRpY2xlLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MscXVhdCxtaW4sbWF4KXtcbiAgICAvLyBHZXQgZWFjaCBheGlzIG1heFxuICAgIG1pbi5jb3B5KHBvcyk7XG4gICAgbWF4LmNvcHkocG9zKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFBsYW5lO1xuXG52YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xuXG4vKipcbiAqIEEgcGxhbmUsIGZhY2luZyBpbiB0aGUgWiBkaXJlY3Rpb24uIFRoZSBwbGFuZSBoYXMgaXRzIHN1cmZhY2UgYXQgej0wIGFuZCBldmVyeXRoaW5nIGJlbG93IHo9MCBpcyBhc3N1bWVkIHRvIGJlIHNvbGlkIHBsYW5lLiBUbyBtYWtlIHRoZSBwbGFuZSBmYWNlIGluIHNvbWUgb3RoZXIgZGlyZWN0aW9uIHRoYW4geiwgeW91IG11c3QgcHV0IGl0IGluc2lkZSBhIFJpZ2lkQm9keSBhbmQgcm90YXRlIHRoYXQgYm9keS4gU2VlIHRoZSBkZW1vcy5cbiAqIEBjbGFzcyBQbGFuZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQGF1dGhvciBzY2h0ZXBwZVxuICovXG5mdW5jdGlvbiBQbGFuZSgpe1xuICAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgdGhpcy50eXBlID0gU2hhcGUudHlwZXMuUExBTkU7XG5cbiAgICAvLyBXb3JsZCBvcmllbnRlZCBub3JtYWxcbiAgICB0aGlzLndvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLndvcmxkTm9ybWFsTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7XG59XG5QbGFuZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblBsYW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lO1xuXG5QbGFuZS5wcm90b3R5cGUuY29tcHV0ZVdvcmxkTm9ybWFsID0gZnVuY3Rpb24ocXVhdCl7XG4gICAgdmFyIG4gPSB0aGlzLndvcmxkTm9ybWFsO1xuICAgIG4uc2V0KDAsMCwxKTtcbiAgICBxdWF0LnZtdWx0KG4sbik7XG4gICAgdGhpcy53b3JsZE5vcm1hbE5lZWRzVXBkYXRlID0gZmFsc2U7XG59O1xuXG5QbGFuZS5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcyx0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5QbGFuZS5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTsgLy8gVGhlIHBsYW5lIGlzIGluZmluaXRlLi4uXG59O1xuXG52YXIgdGVtcE5vcm1hbCA9IG5ldyBWZWMzKCk7XG5QbGFuZS5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24ocG9zLCBxdWF0LCBtaW4sIG1heCl7XG4gICAgLy8gVGhlIHBsYW5lIEFBQkIgaXMgaW5maW5pdGUsIGV4Y2VwdCBpZiB0aGUgbm9ybWFsIGlzIHBvaW50aW5nIGFsb25nIGFueSBheGlzXG4gICAgdGVtcE5vcm1hbC5zZXQoMCwwLDEpOyAvLyBEZWZhdWx0IHBsYW5lIG5vcm1hbCBpcyB6XG4gICAgcXVhdC52bXVsdCh0ZW1wTm9ybWFsLHRlbXBOb3JtYWwpO1xuICAgIHZhciBtYXhWYWwgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIG1pbi5zZXQoLW1heFZhbCwgLW1heFZhbCwgLW1heFZhbCk7XG4gICAgbWF4LnNldChtYXhWYWwsIG1heFZhbCwgbWF4VmFsKTtcblxuICAgIGlmKHRlbXBOb3JtYWwueCA9PT0gMSl7IG1heC54ID0gcG9zLng7IH1cbiAgICBpZih0ZW1wTm9ybWFsLnkgPT09IDEpeyBtYXgueSA9IHBvcy55OyB9XG4gICAgaWYodGVtcE5vcm1hbC56ID09PSAxKXsgbWF4LnogPSBwb3MuejsgfVxuXG4gICAgaWYodGVtcE5vcm1hbC54ID09PSAtMSl7IG1pbi54ID0gcG9zLng7IH1cbiAgICBpZih0ZW1wTm9ybWFsLnkgPT09IC0xKXsgbWluLnkgPSBwb3MueTsgfVxuICAgIGlmKHRlbXBOb3JtYWwueiA9PT0gLTEpeyBtaW4ueiA9IHBvcy56OyB9XG59O1xuXG5QbGFuZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBOdW1iZXIuTUFYX1ZBTFVFO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IFNoYXBlO1xuXG52YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBNYXRlcmlhbCA9IHJlcXVpcmUoJy4uL21hdGVyaWFsL01hdGVyaWFsJyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3Igc2hhcGVzXG4gKiBAY2xhc3MgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHRvZG8gU2hvdWxkIGhhdmUgYSBtZWNoYW5pc20gZm9yIGNhY2hpbmcgYm91bmRpbmcgc3BoZXJlIHJhZGl1cyBpbnN0ZWFkIG9mIGNhbGN1bGF0aW5nIGl0IGVhY2ggdGltZVxuICovXG5mdW5jdGlvbiBTaGFwZSgpe1xuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZnllciBvZiB0aGUgU2hhcGUuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGlkXG4gICAgICovXG4gICAgdGhpcy5pZCA9IFNoYXBlLmlkQ291bnRlcisrO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhpcyBzaGFwZS4gTXVzdCBiZSBzZXQgdG8gYW4gaW50ID4gMCBieSBzdWJjbGFzc2VzLlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAc2VlIFNoYXBlLnR5cGVzXG4gICAgICovXG4gICAgdGhpcy50eXBlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbCBib3VuZGluZyBzcGhlcmUgcmFkaXVzIG9mIHRoaXMgc2hhcGUuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGJvdW5kaW5nU3BoZXJlUmFkaXVzXG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHByb2R1Y2UgY29udGFjdCBmb3JjZXMgd2hlbiBpbiBjb250YWN0IHdpdGggb3RoZXIgYm9kaWVzLiBOb3RlIHRoYXQgY29udGFjdHMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBjb2xsaXNpb25SZXNwb25zZVxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtNYXRlcmlhbH0gbWF0ZXJpYWxcbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcbn1cblNoYXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoYXBlO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBib3VuZGluZyBzcGhlcmUgcmFkaXVzLiBUaGUgcmVzdWx0IGlzIHN0b3JlZCBpbiB0aGUgcHJvcGVydHkgLmJvdW5kaW5nU3BoZXJlUmFkaXVzXG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzXG4gKi9cblNoYXBlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhyb3cgXCJjb21wdXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKSBub3QgaW1wbGVtZW50ZWQgZm9yIHNoYXBlIHR5cGUgXCIrdGhpcy50eXBlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHZvbHVtZSBvZiB0aGlzIHNoYXBlXG4gKiBAbWV0aG9kIHZvbHVtZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5TaGFwZS5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyBcInZvbHVtZSgpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSBcIit0aGlzLnR5cGU7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGluZXJ0aWEgaW4gdGhlIGxvY2FsIGZyYW1lIGZvciB0aGlzIHNoYXBlLlxuICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXNzXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxuICogQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfbW9tZW50c19vZl9pbmVydGlhXG4gKi9cblNoYXBlLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XG4gICAgdGhyb3cgXCJjYWxjdWxhdGVMb2NhbEluZXJ0aWEoKSBub3QgaW1wbGVtZW50ZWQgZm9yIHNoYXBlIHR5cGUgXCIrdGhpcy50eXBlO1xufTtcblxuU2hhcGUuaWRDb3VudGVyID0gMDtcblxuLyoqXG4gKiBUaGUgYXZhaWxhYmxlIHNoYXBlIHR5cGVzLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHR5cGVzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5TaGFwZS50eXBlcyA9IHtcbiAgICBTUEhFUkU6MSxcbiAgICBQTEFORToyLFxuICAgIEJPWDo0LFxuICAgIENPTVBPVU5EOjgsXG4gICAgQ09OVkVYUE9MWUhFRFJPTjoxNixcbiAgICBIRUlHSFRGSUVMRDozMixcbiAgICBQQVJUSUNMRTo2NCxcbiAgICBDWUxJTkRFUjoxMjgsXG4gICAgVFJJTUVTSDoyNTZcbn07XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gU3BoZXJlO1xuXG52YXIgU2hhcGUgPSByZXF1aXJlKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xuXG4vKipcbiAqIFNwaGVyaWNhbCBzaGFwZVxuICogQGNsYXNzIFNwaGVyZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cyBUaGUgcmFkaXVzIG9mIHRoZSBzcGhlcmUsIGEgbm9uLW5lZ2F0aXZlIG51bWJlci5cbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxuICovXG5mdW5jdGlvbiBTcGhlcmUocmFkaXVzKXtcbiAgICBTaGFwZS5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzIT09dW5kZWZpbmVkID8gTnVtYmVyKHJhZGl1cykgOiAxLjA7XG4gICAgdGhpcy50eXBlID0gU2hhcGUudHlwZXMuU1BIRVJFO1xuXG4gICAgaWYodGhpcy5yYWRpdXMgPCAwKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3BoZXJlIHJhZGl1cyBjYW5ub3QgYmUgbmVnYXRpdmUuJyk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xufVxuU3BoZXJlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuU3BoZXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwaGVyZTtcblxuU3BoZXJlLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgdmFyIEkgPSAyLjAqbWFzcyp0aGlzLnJhZGl1cyp0aGlzLnJhZGl1cy81LjA7XG4gICAgdGFyZ2V0LnggPSBJO1xuICAgIHRhcmdldC55ID0gSTtcbiAgICB0YXJnZXQueiA9IEk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cblNwaGVyZS5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gNC4wICogTWF0aC5QSSAqIHRoaXMucmFkaXVzIC8gMy4wO1xufTtcblxuU3BoZXJlLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IHRoaXMucmFkaXVzO1xufTtcblxuU3BoZXJlLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MscXVhdCxtaW4sbWF4KXtcbiAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xuICAgIHZhciBheGVzID0gWyd4JywneScsJ3onXTtcbiAgICBmb3IodmFyIGk9MDsgaTxheGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGF4ID0gYXhlc1tpXTtcbiAgICAgICAgbWluW2F4XSA9IHBvc1theF0gLSByO1xuICAgICAgICBtYXhbYXhdID0gcG9zW2F4XSArIHI7XG4gICAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gVHJpbWVzaDtcblxudmFyIFNoYXBlID0gcmVxdWlyZSgnLi9TaGFwZScpO1xudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gcmVxdWlyZSgnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcbnZhciBBQUJCID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL0FBQkInKTtcbnZhciBPY3RyZWUgPSByZXF1aXJlKCcuLi91dGlscy9PY3RyZWUnKTtcblxuLyoqXG4gKiBAY2xhc3MgVHJpbWVzaFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2FycmF5fSB2ZXJ0aWNlc1xuICogQHBhcmFtIHthcnJheX0gaW5kaWNlc1xuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gSG93IHRvIG1ha2UgYSBtZXNoIHdpdGggYSBzaW5nbGUgdHJpYW5nbGVcbiAqICAgICB2YXIgdmVydGljZXMgPSBbXG4gKiAgICAgICAgIDAsIDAsIDAsIC8vIHZlcnRleCAwXG4gKiAgICAgICAgIDEsIDAsIDAsIC8vIHZlcnRleCAxXG4gKiAgICAgICAgIDAsIDEsIDAgIC8vIHZlcnRleCAyXG4gKiAgICAgXTtcbiAqICAgICB2YXIgaW5kaWNlcyA9IFtcbiAqICAgICAgICAgMCwgMSwgMiAgLy8gdHJpYW5nbGUgMFxuICogICAgIF07XG4gKiAgICAgdmFyIHRyaW1lc2hTaGFwZSA9IG5ldyBUcmltZXNoKHZlcnRpY2VzLCBpbmRpY2VzKTtcbiAqL1xuZnVuY3Rpb24gVHJpbWVzaCh2ZXJ0aWNlcywgaW5kaWNlcykge1xuICAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgdGhpcy50eXBlID0gU2hhcGUudHlwZXMuVFJJTUVTSDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB2ZXJ0aWNlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcyk7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBpbnRlZ2VycywgaW5kaWNhdGluZyB3aGljaCB2ZXJ0aWNlcyBlYWNoIHRyaWFuZ2xlIGNvbnNpc3RzIG9mLiBUaGUgbGVuZ3RoIG9mIHRoaXMgYXJyYXkgaXMgdGh1cyAzIHRpbWVzIHRoZSBudW1iZXIgb2YgdHJpYW5nbGVzLlxuICAgICAqIEBwcm9wZXJ0eSBpbmRpY2VzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuaW5kaWNlcyA9IG5ldyBJbnQxNkFycmF5KGluZGljZXMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5vcm1hbHMgZGF0YS5cbiAgICAgKiBAcHJvcGVydHkgbm9ybWFsc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLm5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KGluZGljZXMubGVuZ3RoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBsb2NhbCBBQUJCIG9mIHRoZSBtZXNoLlxuICAgICAqIEBwcm9wZXJ0eSBhYWJiXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYWFiYiA9IG5ldyBBQUJCKCk7XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2VzIHRvIHZlcnRleCBwYWlycywgbWFraW5nIHVwIGFsbCB1bmlxdWUgZWRnZXMgaW4gdGhlIHRyaW1lc2guXG4gICAgICogQHByb3BlcnR5IHthcnJheX0gZWRnZXNcbiAgICAgKi9cbiAgICB0aGlzLmVkZ2VzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIExvY2FsIHNjYWxpbmcgb2YgdGhlIG1lc2guIFVzZSAuc2V0U2NhbGUoKSB0byBzZXQgaXQuXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBzY2FsZVxuICAgICAqL1xuICAgIHRoaXMuc2NhbGUgPSBuZXcgVmVjMygxLCAxLCAxKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleGVkIHRyaWFuZ2xlcy4gVXNlIC51cGRhdGVUcmVlKCkgdG8gdXBkYXRlIGl0LlxuICAgICAqIEBwcm9wZXJ0eSB7T2N0cmVlfSB0cmVlXG4gICAgICovXG4gICAgdGhpcy50cmVlID0gbmV3IE9jdHJlZSgpO1xuXG4gICAgdGhpcy51cGRhdGVFZGdlcygpO1xuICAgIHRoaXMudXBkYXRlTm9ybWFscygpO1xuICAgIHRoaXMudXBkYXRlQUFCQigpO1xuICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcbiAgICB0aGlzLnVwZGF0ZVRyZWUoKTtcbn1cblRyaW1lc2gucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5UcmltZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyaW1lc2g7XG5cbnZhciBjb21wdXRlTm9ybWFsc19uID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHVwZGF0ZVRyZWVcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUudXBkYXRlVHJlZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG5cbiAgICB0cmVlLnJlc2V0KCk7XG4gICAgdHJlZS5hYWJiLmNvcHkodGhpcy5hYWJiKTtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlOyAvLyBUaGUgbG9jYWwgbWVzaCBBQUJCIGlzIHNjYWxlZCwgYnV0IHRoZSBvY3RyZWUgQUFCQiBzaG91bGQgYmUgdW5zY2FsZWRcbiAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC54ICo9IDEgLyBzY2FsZS54O1xuICAgIHRyZWUuYWFiYi5sb3dlckJvdW5kLnkgKj0gMSAvIHNjYWxlLnk7XG4gICAgdHJlZS5hYWJiLmxvd2VyQm91bmQueiAqPSAxIC8gc2NhbGUuejtcbiAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC54ICo9IDEgLyBzY2FsZS54O1xuICAgIHRyZWUuYWFiYi51cHBlckJvdW5kLnkgKj0gMSAvIHNjYWxlLnk7XG4gICAgdHJlZS5hYWJiLnVwcGVyQm91bmQueiAqPSAxIC8gc2NhbGUuejtcblxuICAgIC8vIEluc2VydCBhbGwgdHJpYW5nbGVzXG4gICAgdmFyIHRyaWFuZ2xlQUFCQiA9IG5ldyBBQUJCKCk7XG4gICAgdmFyIGEgPSBuZXcgVmVjMygpO1xuICAgIHZhciBiID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgYyA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIHBvaW50cyA9IFthLCBiLCBjXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5kaWNlcy5sZW5ndGggLyAzOyBpKyspIHtcbiAgICAgICAgLy90aGlzLmdldFRyaWFuZ2xlVmVydGljZXMoaSwgYSwgYiwgYyk7XG5cbiAgICAgICAgLy8gR2V0IHVuc2NhbGVkIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgIHZhciBpMyA9IGkgKiAzO1xuICAgICAgICB0aGlzLl9nZXRVbnNjYWxlZFZlcnRleCh0aGlzLmluZGljZXNbaTNdLCBhKTtcbiAgICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMV0sIGIpO1xuICAgICAgICB0aGlzLl9nZXRVbnNjYWxlZFZlcnRleCh0aGlzLmluZGljZXNbaTMgKyAyXSwgYyk7XG5cbiAgICAgICAgdHJpYW5nbGVBQUJCLnNldEZyb21Qb2ludHMocG9pbnRzKTtcbiAgICAgICAgdHJlZS5pbnNlcnQodHJpYW5nbGVBQUJCLCBpKTtcbiAgICB9XG4gICAgdHJlZS5yZW1vdmVFbXB0eU5vZGVzKCk7XG59O1xuXG52YXIgdW5zY2FsZWRBQUJCID0gbmV3IEFBQkIoKTtcblxuLyoqXG4gKiBHZXQgdHJpYW5nbGVzIGluIGEgbG9jYWwgQUFCQiBmcm9tIHRoZSB0cmltZXNoLlxuICogQG1ldGhvZCBnZXRUcmlhbmdsZXNJbkFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqIEBwYXJhbSAge2FycmF5fSByZXN1bHQgQW4gYXJyYXkgb2YgaW50ZWdlcnMsIHJlZmVyZW5jaW5nIHRoZSBxdWVyaWVkIHRyaWFuZ2xlcy5cbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuZ2V0VHJpYW5nbGVzSW5BQUJCID0gZnVuY3Rpb24oYWFiYiwgcmVzdWx0KXtcbiAgICB1bnNjYWxlZEFBQkIuY29weShhYWJiKTtcblxuICAgIC8vIFNjYWxlIGl0IHRvIGxvY2FsXG4gICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICB2YXIgaXN4ID0gc2NhbGUueDtcbiAgICB2YXIgaXN5ID0gc2NhbGUueTtcbiAgICB2YXIgaXN6ID0gc2NhbGUuejtcbiAgICB2YXIgbCA9IHVuc2NhbGVkQUFCQi5sb3dlckJvdW5kO1xuICAgIHZhciB1ID0gdW5zY2FsZWRBQUJCLnVwcGVyQm91bmQ7XG4gICAgbC54IC89IGlzeDtcbiAgICBsLnkgLz0gaXN5O1xuICAgIGwueiAvPSBpc3o7XG4gICAgdS54IC89IGlzeDtcbiAgICB1LnkgLz0gaXN5O1xuICAgIHUueiAvPSBpc3o7XG5cbiAgICByZXR1cm4gdGhpcy50cmVlLmFhYmJRdWVyeSh1bnNjYWxlZEFBQkIsIHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0U2NhbGVcbiAqIEBwYXJhbSB7VmVjM30gc2NhbGVcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuc2V0U2NhbGUgPSBmdW5jdGlvbihzY2FsZSl7XG4gICAgdmFyIHdhc1VuaWZvcm0gPSB0aGlzLnNjYWxlLnggPT09IHRoaXMuc2NhbGUueSA9PT0gdGhpcy5zY2FsZS56O1xuICAgIHZhciBpc1VuaWZvcm0gPSBzY2FsZS54ID09PSBzY2FsZS55ID09PSBzY2FsZS56O1xuXG4gICAgaWYoISh3YXNVbmlmb3JtICYmIGlzVW5pZm9ybSkpe1xuICAgICAgICAvLyBOb24tdW5pZm9ybSBzY2FsaW5nLiBOZWVkIHRvIHVwZGF0ZSBub3JtYWxzLlxuICAgICAgICB0aGlzLnVwZGF0ZU5vcm1hbHMoKTtcbiAgICB9XG4gICAgdGhpcy5zY2FsZS5jb3B5KHNjYWxlKTtcbiAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIG5vcm1hbHMgb2YgdGhlIGZhY2VzLiBXaWxsIHNhdmUgaW4gdGhlIC5ub3JtYWxzIGFycmF5LlxuICogQG1ldGhvZCB1cGRhdGVOb3JtYWxzXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZU5vcm1hbHMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBuID0gY29tcHV0ZU5vcm1hbHNfbjtcblxuICAgIC8vIEdlbmVyYXRlIG5vcm1hbHNcbiAgICB2YXIgbm9ybWFscyA9IHRoaXMubm9ybWFscztcbiAgICBmb3IodmFyIGk9MDsgaSA8IHRoaXMuaW5kaWNlcy5sZW5ndGggLyAzOyBpKyspe1xuICAgICAgICB2YXIgaTMgPSBpICogMztcblxuICAgICAgICB2YXIgYSA9IHRoaXMuaW5kaWNlc1tpM10sXG4gICAgICAgICAgICBiID0gdGhpcy5pbmRpY2VzW2kzICsgMV0sXG4gICAgICAgICAgICBjID0gdGhpcy5pbmRpY2VzW2kzICsgMl07XG5cbiAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoYSwgdmEpO1xuICAgICAgICB0aGlzLmdldFZlcnRleChiLCB2Yik7XG4gICAgICAgIHRoaXMuZ2V0VmVydGV4KGMsIHZjKTtcblxuICAgICAgICBUcmltZXNoLmNvbXB1dGVOb3JtYWwodmIsIHZhLCB2Yywgbik7XG5cbiAgICAgICAgbm9ybWFsc1tpM10gPSBuLng7XG4gICAgICAgIG5vcm1hbHNbaTMgKyAxXSA9IG4ueTtcbiAgICAgICAgbm9ybWFsc1tpMyArIDJdID0gbi56O1xuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSAuZWRnZXMgcHJvcGVydHlcbiAqIEBtZXRob2QgdXBkYXRlRWRnZXNcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUudXBkYXRlRWRnZXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlZGdlcyA9IHt9O1xuICAgIHZhciBhZGQgPSBmdW5jdGlvbihpbmRleEEsIGluZGV4Qil7XG4gICAgICAgIHZhciBrZXkgPSBhIDwgYiA/IGEgKyAnXycgKyBiIDogYiArICdfJyArIGE7XG4gICAgICAgIGVkZ2VzW2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgZm9yKHZhciBpPTA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKXtcbiAgICAgICAgdmFyIGkzID0gaSAqIDM7XG4gICAgICAgIHZhciBhID0gdGhpcy5pbmRpY2VzW2kzXSxcbiAgICAgICAgICAgIGIgPSB0aGlzLmluZGljZXNbaTMgKyAxXSxcbiAgICAgICAgICAgIGMgPSB0aGlzLmluZGljZXNbaTMgKyAyXTtcbiAgICAgICAgYWRkKGEsYik7XG4gICAgICAgIGFkZChiLGMpO1xuICAgICAgICBhZGQoYyxhKTtcbiAgICB9XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhlZGdlcyk7XG4gICAgdGhpcy5lZGdlcyA9IG5ldyBJbnQxNkFycmF5KGtleXMubGVuZ3RoICogMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbmRpY2VzID0ga2V5c1tpXS5zcGxpdCgnXycpO1xuICAgICAgICB0aGlzLmVkZ2VzWzIgKiBpXSA9IHBhcnNlSW50KGluZGljZXNbMF0sIDEwKTtcbiAgICAgICAgdGhpcy5lZGdlc1syICogaSArIDFdID0gcGFyc2VJbnQoaW5kaWNlc1sxXSwgMTApO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IGFuIGVkZ2UgdmVydGV4XG4gKiBAbWV0aG9kIGdldEVkZ2VWZXJ0ZXhcbiAqIEBwYXJhbSAge251bWJlcn0gZWRnZUluZGV4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGZpcnN0T3JTZWNvbmQgMCBvciAxLCBkZXBlbmRpbmcgb24gd2hpY2ggb25lIG9mIHRoZSB2ZXJ0aWNlcyB5b3UgbmVlZC5cbiAqIEBwYXJhbSAge1ZlYzN9IHZlcnRleFN0b3JlIFdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuZ2V0RWRnZVZlcnRleCA9IGZ1bmN0aW9uKGVkZ2VJbmRleCwgZmlyc3RPclNlY29uZCwgdmVydGV4U3RvcmUpe1xuICAgIHZhciB2ZXJ0ZXhJbmRleCA9IHRoaXMuZWRnZXNbZWRnZUluZGV4ICogMiArIChmaXJzdE9yU2Vjb25kID8gMSA6IDApXTtcbiAgICB0aGlzLmdldFZlcnRleCh2ZXJ0ZXhJbmRleCwgdmVydGV4U3RvcmUpO1xufTtcblxudmFyIGdldEVkZ2VWZWN0b3JfdmEgPSBuZXcgVmVjMygpO1xudmFyIGdldEVkZ2VWZWN0b3JfdmIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEdldCBhIHZlY3RvciBhbG9uZyBhbiBlZGdlLlxuICogQG1ldGhvZCBnZXRFZGdlVmVjdG9yXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGVkZ2VJbmRleFxuICogQHBhcmFtICB7VmVjM30gdmVjdG9yU3RvcmVcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuZ2V0RWRnZVZlY3RvciA9IGZ1bmN0aW9uKGVkZ2VJbmRleCwgdmVjdG9yU3RvcmUpe1xuICAgIHZhciB2YSA9IGdldEVkZ2VWZWN0b3JfdmE7XG4gICAgdmFyIHZiID0gZ2V0RWRnZVZlY3Rvcl92YjtcbiAgICB0aGlzLmdldEVkZ2VWZXJ0ZXgoZWRnZUluZGV4LCAwLCB2YSk7XG4gICAgdGhpcy5nZXRFZGdlVmVydGV4KGVkZ2VJbmRleCwgMSwgdmIpO1xuICAgIHZiLnZzdWIodmEsIHZlY3RvclN0b3JlKTtcbn07XG5cbi8qKlxuICogR2V0IGZhY2Ugbm9ybWFsIGdpdmVuIDMgdmVydGljZXNcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgY29tcHV0ZU5vcm1hbFxuICogQHBhcmFtIHtWZWMzfSB2YVxuICogQHBhcmFtIHtWZWMzfSB2YlxuICogQHBhcmFtIHtWZWMzfSB2Y1xuICogQHBhcmFtIHtWZWMzfSB0YXJnZXRcbiAqL1xudmFyIGNiID0gbmV3IFZlYzMoKTtcbnZhciBhYiA9IG5ldyBWZWMzKCk7XG5UcmltZXNoLmNvbXB1dGVOb3JtYWwgPSBmdW5jdGlvbiAoIHZhLCB2YiwgdmMsIHRhcmdldCApIHtcbiAgICB2Yi52c3ViKHZhLGFiKTtcbiAgICB2Yy52c3ViKHZiLGNiKTtcbiAgICBjYi5jcm9zcyhhYix0YXJnZXQpO1xuICAgIGlmICggIXRhcmdldC5pc1plcm8oKSApIHtcbiAgICAgICAgdGFyZ2V0Lm5vcm1hbGl6ZSgpO1xuICAgIH1cbn07XG5cbnZhciB2YSA9IG5ldyBWZWMzKCk7XG52YXIgdmIgPSBuZXcgVmVjMygpO1xudmFyIHZjID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBHZXQgdmVydGV4IGkuXG4gKiBAbWV0aG9kIGdldFZlcnRleFxuICogQHBhcmFtICB7bnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtWZWMzfSBvdXRcbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcIm91dFwiIHZlY3RvciBvYmplY3RcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuZ2V0VmVydGV4ID0gZnVuY3Rpb24oaSwgb3V0KXtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KGksIG91dCk7XG4gICAgb3V0LnggKj0gc2NhbGUueDtcbiAgICBvdXQueSAqPSBzY2FsZS55O1xuICAgIG91dC56ICo9IHNjYWxlLno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2V0IHJhdyB2ZXJ0ZXggaVxuICogQHByaXZhdGVcbiAqIEBtZXRob2QgX2dldFVuc2NhbGVkVmVydGV4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGlcbiAqIEBwYXJhbSAge1ZlYzN9IG91dFxuICogQHJldHVybiB7VmVjM30gVGhlIFwib3V0XCIgdmVjdG9yIG9iamVjdFxuICovXG5UcmltZXNoLnByb3RvdHlwZS5fZ2V0VW5zY2FsZWRWZXJ0ZXggPSBmdW5jdGlvbihpLCBvdXQpe1xuICAgIHZhciBpMyA9IGkgKiAzO1xuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgcmV0dXJuIG91dC5zZXQoXG4gICAgICAgIHZlcnRpY2VzW2kzXSxcbiAgICAgICAgdmVydGljZXNbaTMgKyAxXSxcbiAgICAgICAgdmVydGljZXNbaTMgKyAyXVxuICAgICk7XG59O1xuXG4vKipcbiAqIEdldCBhIHZlcnRleCBmcm9tIHRoZSB0cmltZXNoLHRyYW5zZm9ybWVkIGJ5IHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgcXVhdGVybmlvbi5cbiAqIEBtZXRob2QgZ2V0V29ybGRWZXJ0ZXhcbiAqIEBwYXJhbSAge251bWJlcn0gaVxuICogQHBhcmFtICB7VmVjM30gcG9zXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0gIHtWZWMzfSBvdXRcbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcIm91dFwiIHZlY3RvciBvYmplY3RcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuZ2V0V29ybGRWZXJ0ZXggPSBmdW5jdGlvbihpLCBwb3MsIHF1YXQsIG91dCl7XG4gICAgdGhpcy5nZXRWZXJ0ZXgoaSwgb3V0KTtcbiAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zLCBxdWF0LCBvdXQsIG91dCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB0aHJlZSB2ZXJ0aWNlcyBmb3IgdHJpYW5nbGUgaS5cbiAqIEBtZXRob2QgZ2V0VHJpYW5nbGVWZXJ0aWNlc1xuICogQHBhcmFtICB7bnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtWZWMzfSBhXG4gKiBAcGFyYW0gIHtWZWMzfSBiXG4gKiBAcGFyYW0gIHtWZWMzfSBjXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldFRyaWFuZ2xlVmVydGljZXMgPSBmdW5jdGlvbihpLCBhLCBiLCBjKXtcbiAgICB2YXIgaTMgPSBpICogMztcbiAgICB0aGlzLmdldFZlcnRleCh0aGlzLmluZGljZXNbaTNdLCBhKTtcbiAgICB0aGlzLmdldFZlcnRleCh0aGlzLmluZGljZXNbaTMgKyAxXSwgYik7XG4gICAgdGhpcy5nZXRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMl0sIGMpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBub3JtYWwgb2YgdHJpYW5nbGUgaS5cbiAqIEBtZXRob2QgZ2V0Tm9ybWFsXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxuICogQHJldHVybiB7VmVjM30gVGhlIFwidGFyZ2V0XCIgdmVjdG9yIG9iamVjdFxuICovXG5UcmltZXNoLnByb3RvdHlwZS5nZXROb3JtYWwgPSBmdW5jdGlvbihpLCB0YXJnZXQpe1xuICAgIHZhciBpMyA9IGkgKiAzO1xuICAgIHJldHVybiB0YXJnZXQuc2V0KFxuICAgICAgICB0aGlzLm5vcm1hbHNbaTNdLFxuICAgICAgICB0aGlzLm5vcm1hbHNbaTMgKyAxXSxcbiAgICAgICAgdGhpcy5ub3JtYWxzW2kzICsgMl1cbiAgICApO1xufTtcblxudmFyIGNsaV9hYWJiID0gbmV3IEFBQkIoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcInRhcmdldFwiIHZlY3RvciBvYmplY3RcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcyx0YXJnZXQpe1xuICAgIC8vIEFwcHJveGltYXRlIHdpdGggYm94IGluZXJ0aWFcbiAgICAvLyBFeGFjdCBpbmVydGlhIGNhbGN1bGF0aW9uIGlzIG92ZXJraWxsLCBidXQgc2VlIGh0dHA6Ly9nZW9tZXRyaWN0b29scy5jb20vRG9jdW1lbnRhdGlvbi9Qb2x5aGVkcmFsTWFzc1Byb3BlcnRpZXMucGRmIGZvciB0aGUgY29ycmVjdCB3YXkgdG8gZG8gaXRcbiAgICB0aGlzLmNvbXB1dGVMb2NhbEFBQkIoY2xpX2FhYmIpO1xuICAgIHZhciB4ID0gY2xpX2FhYmIudXBwZXJCb3VuZC54IC0gY2xpX2FhYmIubG93ZXJCb3VuZC54LFxuICAgICAgICB5ID0gY2xpX2FhYmIudXBwZXJCb3VuZC55IC0gY2xpX2FhYmIubG93ZXJCb3VuZC55LFxuICAgICAgICB6ID0gY2xpX2FhYmIudXBwZXJCb3VuZC56IC0gY2xpX2FhYmIubG93ZXJCb3VuZC56O1xuICAgIHJldHVybiB0YXJnZXQuc2V0KFxuICAgICAgICAxLjAgLyAxMi4wICogbWFzcyAqICggMip5KjIqeSArIDIqeioyKnogKSxcbiAgICAgICAgMS4wIC8gMTIuMCAqIG1hc3MgKiAoIDIqeCoyKnggKyAyKnoqMip6ICksXG4gICAgICAgIDEuMCAvIDEyLjAgKiBtYXNzICogKCAyKnkqMip5ICsgMip4KjIqeCApXG4gICAgKTtcbn07XG5cbnZhciBjb21wdXRlTG9jYWxBQUJCX3dvcmxkVmVydCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbG9jYWwgQUFCQiBmb3IgdGhlIHRyaW1lc2hcbiAqIEBtZXRob2QgY29tcHV0ZUxvY2FsQUFCQlxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICovXG5UcmltZXNoLnByb3RvdHlwZS5jb21wdXRlTG9jYWxBQUJCID0gZnVuY3Rpb24oYWFiYil7XG4gICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmQsXG4gICAgICAgIHUgPSBhYWJiLnVwcGVyQm91bmQsXG4gICAgICAgIG4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzLFxuICAgICAgICB2ID0gY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQ7XG5cbiAgICB0aGlzLmdldFZlcnRleCgwLCB2KTtcbiAgICBsLmNvcHkodik7XG4gICAgdS5jb3B5KHYpO1xuXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IG47IGkrKyl7XG4gICAgICAgIHRoaXMuZ2V0VmVydGV4KGksIHYpO1xuXG4gICAgICAgIGlmKHYueCA8IGwueCl7XG4gICAgICAgICAgICBsLnggPSB2Lng7XG4gICAgICAgIH0gZWxzZSBpZih2LnggPiB1Lngpe1xuICAgICAgICAgICAgdS54ID0gdi54O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodi55IDwgbC55KXtcbiAgICAgICAgICAgIGwueSA9IHYueTtcbiAgICAgICAgfSBlbHNlIGlmKHYueSA+IHUueSl7XG4gICAgICAgICAgICB1LnkgPSB2Lnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih2LnogPCBsLnope1xuICAgICAgICAgICAgbC56ID0gdi56O1xuICAgICAgICB9IGVsc2UgaWYodi56ID4gdS56KXtcbiAgICAgICAgICAgIHUueiA9IHYuejtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyoqXG4gKiBVcGRhdGUgdGhlIC5hYWJiIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZUFBQkJcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUudXBkYXRlQUFCQiA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5jb21wdXRlTG9jYWxBQUJCKHRoaXMuYWFiYik7XG59O1xuXG4vKipcbiAqIFdpbGwgdXBkYXRlIHRoZSAuYm91bmRpbmdTcGhlcmVSYWRpdXMgcHJvcGVydHlcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXNcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIC8vIEFzc3VtZSBwb2ludHMgYXJlIGRpc3RyaWJ1dGVkIHdpdGggbG9jYWwgKDAsMCwwKSBhcyBjZW50ZXJcbiAgICB2YXIgbWF4MiA9IDA7XG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcbiAgICB2YXIgdiA9IG5ldyBWZWMzKCk7XG4gICAgZm9yKHZhciBpPTAsIE49dmVydGljZXMubGVuZ3RoIC8gMzsgaSAhPT0gTjsgaSsrKSB7XG4gICAgICAgIHRoaXMuZ2V0VmVydGV4KGksIHYpO1xuICAgICAgICB2YXIgbm9ybTIgPSB2Lm5vcm0yKCk7XG4gICAgICAgIGlmKG5vcm0yID4gbWF4Mil7XG4gICAgICAgICAgICBtYXgyID0gbm9ybTI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE1hdGguc3FydChtYXgyKTtcbn07XG5cbnZhciB0ZW1wV29ybGRWZXJ0ZXggPSBuZXcgVmVjMygpO1xudmFyIGNhbGN1bGF0ZVdvcmxkQUFCQl9mcmFtZSA9IG5ldyBUcmFuc2Zvcm0oKTtcbnZhciBjYWxjdWxhdGVXb3JsZEFBQkJfYWFiYiA9IG5ldyBBQUJCKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjYWxjdWxhdGVXb3JsZEFBQkJcbiAqIEBwYXJhbSB7VmVjM30gICAgICAgIHBvc1xuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSAgcXVhdFxuICogQHBhcmFtIHtWZWMzfSAgICAgICAgbWluXG4gKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBtYXhcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24ocG9zLHF1YXQsbWluLG1heCl7XG4gICAgLypcbiAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC8gMyxcbiAgICAgICAgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIHZhciBtaW54LG1pbnksbWlueixtYXh4LG1heHksbWF4ejtcblxuICAgIHZhciB2ID0gdGVtcFdvcmxkVmVydGV4O1xuICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKyl7XG4gICAgICAgIHRoaXMuZ2V0VmVydGV4KGksIHYpO1xuICAgICAgICBxdWF0LnZtdWx0KHYsIHYpO1xuICAgICAgICBwb3MudmFkZCh2LCB2KTtcbiAgICAgICAgaWYgKHYueCA8IG1pbnggfHwgbWlueD09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtaW54ID0gdi54O1xuICAgICAgICB9IGVsc2UgaWYodi54ID4gbWF4eCB8fCBtYXh4PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1heHggPSB2Lng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodi55IDwgbWlueSB8fCBtaW55PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1pbnkgPSB2Lnk7XG4gICAgICAgIH0gZWxzZSBpZih2LnkgPiBtYXh5IHx8IG1heHk9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgbWF4eSA9IHYueTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2LnogPCBtaW56IHx8IG1pbno9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgbWlueiA9IHYuejtcbiAgICAgICAgfSBlbHNlIGlmKHYueiA+IG1heHogfHwgbWF4ej09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtYXh6ID0gdi56O1xuICAgICAgICB9XG4gICAgfVxuICAgIG1pbi5zZXQobWlueCxtaW55LG1pbnopO1xuICAgIG1heC5zZXQobWF4eCxtYXh5LG1heHopO1xuICAgICovXG5cbiAgICAvLyBGYXN0ZXIgYXBwcm94aW1hdGlvbiB1c2luZyBsb2NhbCBBQUJCXG4gICAgdmFyIGZyYW1lID0gY2FsY3VsYXRlV29ybGRBQUJCX2ZyYW1lO1xuICAgIHZhciByZXN1bHQgPSBjYWxjdWxhdGVXb3JsZEFBQkJfYWFiYjtcbiAgICBmcmFtZS5wb3NpdGlvbiA9IHBvcztcbiAgICBmcmFtZS5xdWF0ZXJuaW9uID0gcXVhdDtcbiAgICB0aGlzLmFhYmIudG9Xb3JsZEZyYW1lKGZyYW1lLCByZXN1bHQpO1xuICAgIG1pbi5jb3B5KHJlc3VsdC5sb3dlckJvdW5kKTtcbiAgICBtYXguY29weShyZXN1bHQudXBwZXJCb3VuZCk7XG59O1xuXG4vKipcbiAqIEdldCBhcHByb3hpbWF0ZSB2b2x1bWVcbiAqIEBtZXRob2Qgdm9sdW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIDQuMCAqIE1hdGguUEkgKiB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzIC8gMy4wO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBUcmltZXNoIGluc3RhbmNlLCBzaGFwZWQgYXMgYSB0b3J1cy5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgY3JlYXRlVG9ydXNcbiAqIEBwYXJhbSAge251bWJlcn0gW3JhZGl1cz0xXVxuICogQHBhcmFtICB7bnVtYmVyfSBbdHViZT0wLjVdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtyYWRpYWxTZWdtZW50cz04XVxuICogQHBhcmFtICB7bnVtYmVyfSBbdHVidWxhclNlZ21lbnRzPTZdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFthcmM9Ni4yODMxODUzMDcxNzk1ODZdXG4gKiBAcmV0dXJuIHtUcmltZXNofSBBIHRvcnVzXG4gKi9cblRyaW1lc2guY3JlYXRlVG9ydXMgPSBmdW5jdGlvbiAocmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMpIHtcbiAgICByYWRpdXMgPSByYWRpdXMgfHwgMTtcbiAgICB0dWJlID0gdHViZSB8fCAwLjU7XG4gICAgcmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xuICAgIHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA2O1xuICAgIGFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgIHZhciBpbmRpY2VzID0gW107XG5cbiAgICBmb3IgKCB2YXIgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG4gICAgICAgICAgICB2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XG4gICAgICAgICAgICB2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXG4gICAgICAgICAgICB2YXIgeCA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguY29zKCB1ICk7XG4gICAgICAgICAgICB2YXIgeSA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguc2luKCB1ICk7XG4gICAgICAgICAgICB2YXIgeiA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xuXG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKCB4LCB5LCB6ICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaiA9IDE7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG4gICAgICAgIGZvciAoIHZhciBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG4gICAgICAgICAgICB2YXIgYSA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGkgLSAxO1xuICAgICAgICAgICAgdmFyIGIgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGkgLSAxO1xuICAgICAgICAgICAgdmFyIGMgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XG4gICAgICAgICAgICB2YXIgZCA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGk7XG5cbiAgICAgICAgICAgIGluZGljZXMucHVzaChhLCBiLCBkKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaChiLCBjLCBkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgVHJpbWVzaCh2ZXJ0aWNlcywgaW5kaWNlcyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBHU1NvbHZlcjtcblxudmFyIFZlYzMgPSByZXF1aXJlKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gcmVxdWlyZSgnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG52YXIgU29sdmVyID0gcmVxdWlyZSgnLi9Tb2x2ZXInKTtcblxuLyoqXG4gKiBDb25zdHJhaW50IGVxdWF0aW9uIEdhdXNzLVNlaWRlbCBzb2x2ZXIuXG4gKiBAY2xhc3MgR1NTb2x2ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRvZG8gVGhlIHNwb29rIHBhcmFtZXRlcnMgc2hvdWxkIGJlIHNwZWNpZmllZCBmb3IgZWFjaCBjb25zdHJhaW50LCBub3QgZ2xvYmFsbHkuXG4gKiBAYXV0aG9yIHNjaHRlcHBlIC8gaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlXG4gKiBAc2VlIGh0dHBzOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyLzVEVjA1OC9WVDA5L2xlY3R1cmVzL3Nwb29rbm90ZXMucGRmXG4gKiBAZXh0ZW5kcyBTb2x2ZXJcbiAqL1xuZnVuY3Rpb24gR1NTb2x2ZXIoKXtcbiAgICBTb2x2ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2Ygc29sdmVyIGl0ZXJhdGlvbnMgZGV0ZXJtaW5lcyBxdWFsaXR5IG9mIHRoZSBjb25zdHJhaW50cyBpbiB0aGUgd29ybGQuIFRoZSBtb3JlIGl0ZXJhdGlvbnMsIHRoZSBtb3JlIGNvcnJlY3Qgc2ltdWxhdGlvbi4gTW9yZSBpdGVyYXRpb25zIG5lZWQgbW9yZSBjb21wdXRhdGlvbnMgdGhvdWdoLiBJZiB5b3UgaGF2ZSBhIGxhcmdlIGdyYXZpdHkgZm9yY2UgaW4geW91ciB3b3JsZCwgeW91IHdpbGwgbmVlZCBtb3JlIGl0ZXJhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IGl0ZXJhdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEB0b2RvIHdyaXRlIG1vcmUgYWJvdXQgc29sdmVyIGFuZCBpdGVyYXRpb25zIGluIHRoZSB3aWtpXG4gICAgICovXG4gICAgdGhpcy5pdGVyYXRpb25zID0gMTA7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRvbGVyYW5jZSBpcyByZWFjaGVkLCB0aGUgc3lzdGVtIGlzIGFzc3VtZWQgdG8gYmUgY29udmVyZ2VkLlxuICAgICAqIEBwcm9wZXJ0eSB0b2xlcmFuY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG9sZXJhbmNlID0gMWUtNztcbn1cbkdTU29sdmVyLnByb3RvdHlwZSA9IG5ldyBTb2x2ZXIoKTtcblxudmFyIEdTU29sdmVyX3NvbHZlX2xhbWJkYSA9IFtdOyAvLyBKdXN0IHRlbXBvcmFyeSBudW1iZXIgaG9sZGVycyB0aGF0IHdlIHdhbnQgdG8gcmV1c2UgZWFjaCBzb2x2ZS5cbnZhciBHU1NvbHZlcl9zb2x2ZV9pbnZDcyA9IFtdO1xudmFyIEdTU29sdmVyX3NvbHZlX0JzID0gW107XG5HU1NvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihkdCx3b3JsZCl7XG4gICAgdmFyIGl0ZXIgPSAwLFxuICAgICAgICBtYXhJdGVyID0gdGhpcy5pdGVyYXRpb25zLFxuICAgICAgICB0b2xTcXVhcmVkID0gdGhpcy50b2xlcmFuY2UqdGhpcy50b2xlcmFuY2UsXG4gICAgICAgIGVxdWF0aW9ucyA9IHRoaXMuZXF1YXRpb25zLFxuICAgICAgICBOZXEgPSBlcXVhdGlvbnMubGVuZ3RoLFxuICAgICAgICBib2RpZXMgPSB3b3JsZC5ib2RpZXMsXG4gICAgICAgIE5ib2RpZXMgPSBib2RpZXMubGVuZ3RoLFxuICAgICAgICBoID0gZHQsXG4gICAgICAgIHEsIEIsIGludkMsIGRlbHRhbGFtYmRhLCBkZWx0YWxhbWJkYVRvdCwgR1dsYW1iZGEsIGxhbWJkYWo7XG5cbiAgICAvLyBVcGRhdGUgc29sdmUgbWFzc1xuICAgIGlmKE5lcSAhPT0gMCl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIGJvZGllc1tpXS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGluZ3MgdGhhdCBkb2VzIG5vdCBjaGFuZ2UgZHVyaW5nIGl0ZXJhdGlvbiBjYW4gYmUgY29tcHV0ZWQgb25jZVxuICAgIHZhciBpbnZDcyA9IEdTU29sdmVyX3NvbHZlX2ludkNzLFxuICAgICAgICBCcyA9IEdTU29sdmVyX3NvbHZlX0JzLFxuICAgICAgICBsYW1iZGEgPSBHU1NvbHZlcl9zb2x2ZV9sYW1iZGE7XG4gICAgaW52Q3MubGVuZ3RoID0gTmVxO1xuICAgIEJzLmxlbmd0aCA9IE5lcTtcbiAgICBsYW1iZGEubGVuZ3RoID0gTmVxO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmVxOyBpKyspe1xuICAgICAgICB2YXIgYyA9IGVxdWF0aW9uc1tpXTtcbiAgICAgICAgbGFtYmRhW2ldID0gMC4wO1xuICAgICAgICBCc1tpXSA9IGMuY29tcHV0ZUIoaCk7XG4gICAgICAgIGludkNzW2ldID0gMS4wIC8gYy5jb21wdXRlQygpO1xuICAgIH1cblxuICAgIGlmKE5lcSAhPT0gMCl7XG5cbiAgICAgICAgLy8gUmVzZXQgdmxhbWJkYVxuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYj1ib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgdmxhbWJkYT1iLnZsYW1iZGEsXG4gICAgICAgICAgICAgICAgd2xhbWJkYT1iLndsYW1iZGE7XG4gICAgICAgICAgICB2bGFtYmRhLnNldCgwLDAsMCk7XG4gICAgICAgICAgICB3bGFtYmRhLnNldCgwLDAsMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgZXF1YXRpb25zXG4gICAgICAgIGZvcihpdGVyPTA7IGl0ZXIhPT1tYXhJdGVyOyBpdGVyKyspe1xuXG4gICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uXG4gICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCA9IDAuMDtcblxuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGohPT1OZXE7IGorKyl7XG5cbiAgICAgICAgICAgICAgICB2YXIgYyA9IGVxdWF0aW9uc1tqXTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgQiA9IEJzW2pdO1xuICAgICAgICAgICAgICAgIGludkMgPSBpbnZDc1tqXTtcbiAgICAgICAgICAgICAgICBsYW1iZGFqID0gbGFtYmRhW2pdO1xuICAgICAgICAgICAgICAgIEdXbGFtYmRhID0gYy5jb21wdXRlR1dsYW1iZGEoKTtcbiAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYSA9IGludkMgKiAoIEIgLSBHV2xhbWJkYSAtIGMuZXBzICogbGFtYmRhaiApO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xhbXAgaWYgd2UgYXJlIG5vdCB3aXRoaW4gdGhlIG1pbi9tYXggaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICBpZihsYW1iZGFqICsgZGVsdGFsYW1iZGEgPCBjLm1pbkZvcmNlKXtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFsYW1iZGEgPSBjLm1pbkZvcmNlIC0gbGFtYmRhajtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYobGFtYmRhaiArIGRlbHRhbGFtYmRhID4gYy5tYXhGb3JjZSl7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhID0gYy5tYXhGb3JjZSAtIGxhbWJkYWo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbWJkYVtqXSArPSBkZWx0YWxhbWJkYTtcblxuICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ICs9IGRlbHRhbGFtYmRhID4gMC4wID8gZGVsdGFsYW1iZGEgOiAtZGVsdGFsYW1iZGE7IC8vIGFicyhkZWx0YWxhbWJkYSlcblxuICAgICAgICAgICAgICAgIGMuYWRkVG9XbGFtYmRhKGRlbHRhbGFtYmRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZVxuICAgICAgICAgICAgaWYoZGVsdGFsYW1iZGFUb3QqZGVsdGFsYW1iZGFUb3QgPCB0b2xTcXVhcmVkKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCByZXN1bHQgdG8gdmVsb2NpdHlcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgdmFyIGI9Ym9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIHY9Yi52ZWxvY2l0eSxcbiAgICAgICAgICAgICAgICB3PWIuYW5ndWxhclZlbG9jaXR5O1xuXG4gICAgICAgICAgICBiLnZsYW1iZGEudm11bChiLmxpbmVhckZhY3RvciwgYi52bGFtYmRhKTtcbiAgICAgICAgICAgIHYudmFkZChiLnZsYW1iZGEsIHYpO1xuXG4gICAgICAgICAgICBiLndsYW1iZGEudm11bChiLmFuZ3VsYXJGYWN0b3IsIGIud2xhbWJkYSk7XG4gICAgICAgICAgICB3LnZhZGQoYi53bGFtYmRhLCB3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgLm11bHRpcGxpZXIgcHJvcGVydHkgb2YgZWFjaCBlcXVhdGlvblxuICAgICAgICB2YXIgbCA9IGVxdWF0aW9ucy5sZW5ndGg7XG4gICAgICAgIHZhciBpbnZEdCA9IDEgLyBoO1xuICAgICAgICB3aGlsZShsLS0pe1xuICAgICAgICAgICAgZXF1YXRpb25zW2xdLm11bHRpcGxpZXIgPSBsYW1iZGFbbF0gKiBpbnZEdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVyO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gU29sdmVyO1xuXG4vKipcbiAqIENvbnN0cmFpbnQgZXF1YXRpb24gc29sdmVyIGJhc2UgY2xhc3MuXG4gKiBAY2xhc3MgU29sdmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gU29sdmVyKCl7XG4gICAgLyoqXG4gICAgICogQWxsIGVxdWF0aW9ucyB0byBiZSBzb2x2ZWRcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBlcXVhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzIVxuICogQG1ldGhvZCBzb2x2ZVxuICogQHBhcmFtICB7TnVtYmVyfSBkdFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKi9cblNvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihkdCx3b3JsZCl7XG4gICAgLy8gU2hvdWxkIHJldHVybiB0aGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZG9uZSFcbiAgICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogQWRkIGFuIGVxdWF0aW9uXG4gKiBAbWV0aG9kIGFkZEVxdWF0aW9uXG4gKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxuICovXG5Tb2x2ZXIucHJvdG90eXBlLmFkZEVxdWF0aW9uID0gZnVuY3Rpb24oZXEpe1xuICAgIGlmIChlcS5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGVxdWF0aW9uXG4gKiBAbWV0aG9kIHJlbW92ZUVxdWF0aW9uXG4gKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxuICovXG5Tb2x2ZXIucHJvdG90eXBlLnJlbW92ZUVxdWF0aW9uID0gZnVuY3Rpb24oZXEpe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICB2YXIgaSA9IGVxcy5pbmRleE9mKGVxKTtcbiAgICBpZihpICE9PSAtMSl7XG4gICAgICAgIGVxcy5zcGxpY2UoaSwxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhbGwgZXF1YXRpb25zXG4gKiBAbWV0aG9kIHJlbW92ZUFsbEVxdWF0aW9uc1xuICovXG5Tb2x2ZXIucHJvdG90eXBlLnJlbW92ZUFsbEVxdWF0aW9ucyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5lcXVhdGlvbnMubGVuZ3RoID0gMDtcbn07XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gU3BsaXRTb2x2ZXI7XG5cbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFNvbHZlciA9IHJlcXVpcmUoJy4vU29sdmVyJyk7XG52YXIgQm9keSA9IHJlcXVpcmUoJy4uL29iamVjdHMvQm9keScpO1xuXG4vKipcbiAqIFNwbGl0cyB0aGUgZXF1YXRpb25zIGludG8gaXNsYW5kcyBhbmQgc29sdmVzIHRoZW0gaW5kZXBlbmRlbnRseS4gQ2FuIGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gKiBAY2xhc3MgU3BsaXRTb2x2ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU29sdmVyXG4gKiBAcGFyYW0ge1NvbHZlcn0gc3Vic29sdmVyXG4gKi9cbmZ1bmN0aW9uIFNwbGl0U29sdmVyKHN1YnNvbHZlcil7XG4gICAgU29sdmVyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5pdGVyYXRpb25zID0gMTA7XG4gICAgdGhpcy50b2xlcmFuY2UgPSAxZS03O1xuICAgIHRoaXMuc3Vic29sdmVyID0gc3Vic29sdmVyO1xuICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB0aGlzLm5vZGVQb29sID0gW107XG5cbiAgICAvLyBDcmVhdGUgbmVlZGVkIG5vZGVzLCByZXVzZSBpZiBwb3NzaWJsZVxuICAgIHdoaWxlKHRoaXMubm9kZVBvb2wubGVuZ3RoIDwgMTI4KXtcbiAgICAgICAgdGhpcy5ub2RlUG9vbC5wdXNoKHRoaXMuY3JlYXRlTm9kZSgpKTtcbiAgICB9XG59XG5TcGxpdFNvbHZlci5wcm90b3R5cGUgPSBuZXcgU29sdmVyKCk7XG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiBzdWJzeXN0ZW1zXG52YXIgU3BsaXRTb2x2ZXJfc29sdmVfbm9kZXMgPSBbXTsgLy8gQWxsIGFsbG9jYXRlZCBub2RlIG9iamVjdHNcbnZhciBTcGxpdFNvbHZlcl9zb2x2ZV9ub2RlUG9vbCA9IFtdOyAvLyBBbGwgYWxsb2NhdGVkIG5vZGUgb2JqZWN0c1xudmFyIFNwbGl0U29sdmVyX3NvbHZlX2VxcyA9IFtdOyAgIC8vIFRlbXAgYXJyYXlcbnZhciBTcGxpdFNvbHZlcl9zb2x2ZV9iZHMgPSBbXTsgICAvLyBUZW1wIGFycmF5XG52YXIgU3BsaXRTb2x2ZXJfc29sdmVfZHVtbXlXb3JsZCA9IHtib2RpZXM6W119OyAvLyBUZW1wIG9iamVjdFxuXG52YXIgU1RBVElDID0gQm9keS5TVEFUSUM7XG5mdW5jdGlvbiBnZXRVbnZpc2l0ZWROb2RlKG5vZGVzKXtcbiAgICB2YXIgTm5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpIT09Tm5vZGVzOyBpKyspe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZighbm9kZS52aXNpdGVkICYmICEobm9kZS5ib2R5LnR5cGUgJiBTVEFUSUMpKXtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxudmFyIHF1ZXVlID0gW107XG5mdW5jdGlvbiBiZnMocm9vdCx2aXNpdEZ1bmMsYmRzLGVxcyl7XG4gICAgcXVldWUucHVzaChyb290KTtcbiAgICByb290LnZpc2l0ZWQgPSB0cnVlO1xuICAgIHZpc2l0RnVuYyhyb290LGJkcyxlcXMpO1xuICAgIHdoaWxlKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgbm9kZSA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICAvLyBMb29wIG92ZXIgdW52aXNpdGVkIGNoaWxkIG5vZGVzXG4gICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgd2hpbGUoKGNoaWxkID0gZ2V0VW52aXNpdGVkTm9kZShub2RlLmNoaWxkcmVuKSkpIHtcbiAgICAgICAgICAgIGNoaWxkLnZpc2l0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmlzaXRGdW5jKGNoaWxkLGJkcyxlcXMpO1xuICAgICAgICAgICAgcXVldWUucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZpc2l0RnVuYyhub2RlLGJkcyxlcXMpe1xuICAgIGJkcy5wdXNoKG5vZGUuYm9keSk7XG4gICAgdmFyIE5lcXMgPSBub2RlLmVxcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1OZXFzOyBpKyspe1xuICAgICAgICB2YXIgZXEgPSBub2RlLmVxc1tpXTtcbiAgICAgICAgaWYoZXFzLmluZGV4T2YoZXEpID09PSAtMSl7XG4gICAgICAgICAgICBlcXMucHVzaChlcSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblNwbGl0U29sdmVyLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4geyBib2R5Om51bGwsIGNoaWxkcmVuOltdLCBlcXM6W10sIHZpc2l0ZWQ6ZmFsc2UgfTtcbn07XG5cbi8qKlxuICogU29sdmUgdGhlIHN1YnN5c3RlbXNcbiAqIEBtZXRob2Qgc29sdmVcbiAqIEBwYXJhbSAge051bWJlcn0gZHRcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICovXG5TcGxpdFNvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihkdCx3b3JsZCl7XG4gICAgdmFyIG5vZGVzPVNwbGl0U29sdmVyX3NvbHZlX25vZGVzLFxuICAgICAgICBub2RlUG9vbD10aGlzLm5vZGVQb29sLFxuICAgICAgICBib2RpZXM9d29ybGQuYm9kaWVzLFxuICAgICAgICBlcXVhdGlvbnM9dGhpcy5lcXVhdGlvbnMsXG4gICAgICAgIE5lcT1lcXVhdGlvbnMubGVuZ3RoLFxuICAgICAgICBOYm9kaWVzPWJvZGllcy5sZW5ndGgsXG4gICAgICAgIHN1YnNvbHZlcj10aGlzLnN1YnNvbHZlcjtcblxuICAgIC8vIENyZWF0ZSBuZWVkZWQgbm9kZXMsIHJldXNlIGlmIHBvc3NpYmxlXG4gICAgd2hpbGUobm9kZVBvb2wubGVuZ3RoIDwgTmJvZGllcyl7XG4gICAgICAgIG5vZGVQb29sLnB1c2godGhpcy5jcmVhdGVOb2RlKCkpO1xuICAgIH1cbiAgICBub2Rlcy5sZW5ndGggPSBOYm9kaWVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTmJvZGllczsgaSsrKSB7XG4gICAgICAgIG5vZGVzW2ldID0gbm9kZVBvb2xbaV07XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgbm9kZSB2YWx1ZXNcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIG5vZGUuYm9keSA9IGJvZGllc1tpXTtcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgICAgICBub2RlLmVxcy5sZW5ndGggPSAwO1xuICAgICAgICBub2RlLnZpc2l0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZm9yKHZhciBrPTA7IGshPT1OZXE7IGsrKyl7XG4gICAgICAgIHZhciBlcT1lcXVhdGlvbnNba10sXG4gICAgICAgICAgICBpPWJvZGllcy5pbmRleE9mKGVxLmJpKSxcbiAgICAgICAgICAgIGo9Ym9kaWVzLmluZGV4T2YoZXEuYmopLFxuICAgICAgICAgICAgbmk9bm9kZXNbaV0sXG4gICAgICAgICAgICBuaj1ub2Rlc1tqXTtcbiAgICAgICAgbmkuY2hpbGRyZW4ucHVzaChuaik7XG4gICAgICAgIG5pLmVxcy5wdXNoKGVxKTtcbiAgICAgICAgbmouY2hpbGRyZW4ucHVzaChuaSk7XG4gICAgICAgIG5qLmVxcy5wdXNoKGVxKTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGQsIG49MCwgZXFzPVNwbGl0U29sdmVyX3NvbHZlX2VxcztcblxuICAgIHN1YnNvbHZlci50b2xlcmFuY2UgPSB0aGlzLnRvbGVyYW5jZTtcbiAgICBzdWJzb2x2ZXIuaXRlcmF0aW9ucyA9IHRoaXMuaXRlcmF0aW9ucztcblxuICAgIHZhciBkdW1teVdvcmxkID0gU3BsaXRTb2x2ZXJfc29sdmVfZHVtbXlXb3JsZDtcbiAgICB3aGlsZSgoY2hpbGQgPSBnZXRVbnZpc2l0ZWROb2RlKG5vZGVzKSkpe1xuICAgICAgICBlcXMubGVuZ3RoID0gMDtcbiAgICAgICAgZHVtbXlXb3JsZC5ib2RpZXMubGVuZ3RoID0gMDtcbiAgICAgICAgYmZzKGNoaWxkLCB2aXNpdEZ1bmMsIGR1bW15V29ybGQuYm9kaWVzLCBlcXMpO1xuXG4gICAgICAgIHZhciBOZXFzID0gZXFzLmxlbmd0aDtcblxuICAgICAgICBlcXMgPSBlcXMuc29ydChzb3J0QnlJZCk7XG5cbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1OZXFzOyBpKyspe1xuICAgICAgICAgICAgc3Vic29sdmVyLmFkZEVxdWF0aW9uKGVxc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlciA9IHN1YnNvbHZlci5zb2x2ZShkdCxkdW1teVdvcmxkKTtcbiAgICAgICAgc3Vic29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuICAgICAgICBuKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIG47XG59O1xuXG5mdW5jdGlvbiBzb3J0QnlJZChhLCBiKXtcbiAgICByZXR1cm4gYi5pZCAtIGEuaWQ7XG59IiwiLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBvYmplY3RzIHRoYXQgZGlzcGF0Y2hlcyBldmVudHMuXG4gKiBAY2xhc3MgRXZlbnRUYXJnZXRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRXZlbnRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXQ7XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogRXZlbnRUYXJnZXQsXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtFdmVudFRhcmdldH0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXsgdGhpcy5fbGlzdGVuZXJzID0ge307IH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFuIGV2ZW50IGxpc3RlbmVyIGlzIGFkZGVkXG4gICAgICogQG1ldGhvZCBoYXNFdmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtFdmVudFRhcmdldH0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAqL1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbdHlwZV0gPT09IHVuZGVmaW5lZCApeyByZXR1cm4gdGhpczsgfVxuICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApO1xuICAgICAgICBpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5zcGxpY2UoIGluZGV4LCAxICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVtaXQgYW4gZXZlbnQuXG4gICAgICogQG1ldGhvZCBkaXNwYXRjaEV2ZW50XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBldmVudFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZXZlbnQudHlwZVxuICAgICAqIEByZXR1cm4ge0V2ZW50VGFyZ2V0fSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXG4gICAgICovXG4gICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCBldmVudCApIHtcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApeyByZXR1cm4gdGhpczsgfVxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgICB2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xuICAgICAgICBpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJBcnJheVsgaSBdLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcbiIsInZhciBBQUJCID0gcmVxdWlyZSgnLi4vY29sbGlzaW9uL0FBQkInKTtcbnZhciBWZWMzID0gcmVxdWlyZSgnLi4vbWF0aC9WZWMzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2N0cmVlO1xuXG4vKipcbiAqIEBjbGFzcyBPY3RyZWVOb2RlXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09jdHJlZX0gW29wdGlvbnMucm9vdF1cbiAqIEBwYXJhbSB7QUFCQn0gW29wdGlvbnMuYWFiYl1cbiAqL1xuZnVuY3Rpb24gT2N0cmVlTm9kZShvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb290IG5vZGVcbiAgICAgKiBAcHJvcGVydHkge09jdHJlZU5vZGV9IHJvb3RcbiAgICAgKi9cbiAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEJvdW5kYXJ5IG9mIHRoaXMgbm9kZVxuICAgICAqIEBwcm9wZXJ0eSB7QUFCQn0gYWFiYlxuICAgICAqL1xuICAgIHRoaXMuYWFiYiA9IG9wdGlvbnMuYWFiYiA/IG9wdGlvbnMuYWFiYi5jbG9uZSgpIDogbmV3IEFBQkIoKTtcblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5lZCBkYXRhIGF0IHRoZSBjdXJyZW50IG5vZGUgbGV2ZWwuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZGF0YVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQ2hpbGRyZW4gdG8gdGhpcyBub2RlXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gY2hpbGRyZW5cbiAgICAgKi9cbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG59XG5cbi8qKlxuICogQGNsYXNzIE9jdHJlZVxuICogQHBhcmFtIHtBQUJCfSBhYWJiIFRoZSB0b3RhbCBBQUJCIG9mIHRoZSB0cmVlXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4RGVwdGg9OF1cbiAqIEBleHRlbmRzIE9jdHJlZU5vZGVcbiAqL1xuZnVuY3Rpb24gT2N0cmVlKGFhYmIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucm9vdCA9IG51bGw7XG4gICAgb3B0aW9ucy5hYWJiID0gYWFiYjtcbiAgICBPY3RyZWVOb2RlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIHN1YmRpdmlzaW9uIGRlcHRoXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heERlcHRoXG4gICAgICovXG4gICAgdGhpcy5tYXhEZXB0aCA9IHR5cGVvZihvcHRpb25zLm1heERlcHRoKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heERlcHRoIDogODtcbn1cbk9jdHJlZS5wcm90b3R5cGUgPSBuZXcgT2N0cmVlTm9kZSgpO1xuXG5PY3RyZWVOb2RlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKGFhYmIsIG9wdGlvbnMpe1xuICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIEluc2VydCBkYXRhIGludG8gdGhpcyBub2RlXG4gKiBAbWV0aG9kIGluc2VydFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtICB7b2JqZWN0fSBlbGVtZW50RGF0YVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBzdWNjZXNzZnVsLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuT2N0cmVlTm9kZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oYWFiYiwgZWxlbWVudERhdGEsIGxldmVsKXtcbiAgICB2YXIgbm9kZURhdGEgPSB0aGlzLmRhdGE7XG4gICAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xuXG4gICAgLy8gSWdub3JlIG9iamVjdHMgdGhhdCBkbyBub3QgYmVsb25nIGluIHRoaXMgbm9kZVxuICAgIGlmICghdGhpcy5hYWJiLmNvbnRhaW5zKGFhYmIpKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvYmplY3QgY2Fubm90IGJlIGFkZGVkXG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuICAgIGlmKGxldmVsIDwgKHRoaXMubWF4RGVwdGggfHwgdGhpcy5yb290Lm1heERlcHRoKSl7XG4gICAgICAgIC8vIFN1YmRpdmlkZSBpZiB0aGVyZSBhcmUgbm8gY2hpbGRyZW4geWV0XG4gICAgICAgIHZhciBzdWJkaXZpZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKXtcbiAgICAgICAgICAgIHRoaXMuc3ViZGl2aWRlKCk7XG4gICAgICAgICAgICBzdWJkaXZpZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0byB3aGljaGV2ZXIgbm9kZSB3aWxsIGFjY2VwdCBpdFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gODsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0uaW5zZXJ0KGFhYmIsIGVsZW1lbnREYXRhLCBsZXZlbCArIDEpKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHN1YmRpdmlkZWQpe1xuICAgICAgICAgICAgLy8gTm8gY2hpbGRyZW4gYWNjZXB0ZWQhIE1pZ2h0IGFzIHdlbGwganVzdCByZW1vdmUgZW0gc2luY2UgdGhleSBjb250YWluIG5vbmVcbiAgICAgICAgICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUb28gZGVlcCwgb3IgY2hpbGRyZW4gZGlkbnQgd2FudCBpdC4gYWRkIGl0IGluIGN1cnJlbnQgbm9kZVxuICAgIG5vZGVEYXRhLnB1c2goZWxlbWVudERhdGEpO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgaGFsZkRpYWdvbmFsID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBDcmVhdGUgOCBlcXVhbGx5IHNpemVkIGNoaWxkcmVuIG5vZGVzIGFuZCBwdXQgdGhlbSBpbiB0aGUgLmNoaWxkcmVuIGFycmF5LlxuICogQG1ldGhvZCBzdWJkaXZpZGVcbiAqL1xuT2N0cmVlTm9kZS5wcm90b3R5cGUuc3ViZGl2aWRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFhYmIgPSB0aGlzLmFhYmI7XG4gICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmQ7XG4gICAgdmFyIHUgPSBhYWJiLnVwcGVyQm91bmQ7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG4gICAgY2hpbGRyZW4ucHVzaChcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsMCwwKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMCwwKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMSwwKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMSwxKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsMSwxKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsMCwxKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMCwxKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsMSwwKSB9KSB9KVxuICAgICk7XG5cbiAgICB1LnZzdWIobCwgaGFsZkRpYWdvbmFsKTtcbiAgICBoYWxmRGlhZ29uYWwuc2NhbGUoMC41LCBoYWxmRGlhZ29uYWwpO1xuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3QgfHwgdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSA4OyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgLy8gU2V0IGN1cnJlbnQgbm9kZSBhcyByb290XG4gICAgICAgIGNoaWxkLnJvb3QgPSByb290O1xuXG4gICAgICAgIC8vIENvbXB1dGUgYm91bmRzXG4gICAgICAgIHZhciBsb3dlckJvdW5kID0gY2hpbGQuYWFiYi5sb3dlckJvdW5kO1xuICAgICAgICBsb3dlckJvdW5kLnggKj0gaGFsZkRpYWdvbmFsLng7XG4gICAgICAgIGxvd2VyQm91bmQueSAqPSBoYWxmRGlhZ29uYWwueTtcbiAgICAgICAgbG93ZXJCb3VuZC56ICo9IGhhbGZEaWFnb25hbC56O1xuXG4gICAgICAgIGxvd2VyQm91bmQudmFkZChsLCBsb3dlckJvdW5kKTtcblxuICAgICAgICAvLyBVcHBlciBib3VuZCBpcyBhbHdheXMgbG93ZXIgYm91bmQgKyBoYWxmRGlhZ29uYWxcbiAgICAgICAgbG93ZXJCb3VuZC52YWRkKGhhbGZEaWFnb25hbCwgY2hpbGQuYWFiYi51cHBlckJvdW5kKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBhbGwgZGF0YSwgcG90ZW50aWFsbHkgd2l0aGluIGFuIEFBQkJcbiAqIEBtZXRob2QgYWFiYlF1ZXJ5XG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0XG4gKiBAcmV0dXJuIHthcnJheX0gVGhlIFwicmVzdWx0XCIgb2JqZWN0XG4gKi9cbk9jdHJlZU5vZGUucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKGFhYmIsIHJlc3VsdCkge1xuXG4gICAgdmFyIG5vZGVEYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgLy8gYWJvcnQgaWYgdGhlIHJhbmdlIGRvZXMgbm90IGludGVyc2VjdCB0aGlzIG5vZGVcbiAgICAvLyBpZiAoIXRoaXMuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgLy8gICAgIHJldHVybiByZXN1bHQ7XG4gICAgLy8gfVxuXG4gICAgLy8gQWRkIG9iamVjdHMgYXQgdGhpcyBsZXZlbFxuICAgIC8vIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZURhdGEpO1xuXG4gICAgLy8gQWRkIGNoaWxkIGRhdGFcbiAgICAvLyBAdG9kbyB1bndyYXAgcmVjdXJzaW9uIGludG8gYSBxdWV1ZSAvIGxvb3AsIHRoYXQncyBmYXN0ZXIgaW4gSlNcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cbiAgICAvLyBmb3IgKHZhciBpID0gMCwgTiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICE9PSBOOyBpKyspIHtcbiAgICAvLyAgICAgY2hpbGRyZW5baV0uYWFiYlF1ZXJ5KGFhYmIsIHJlc3VsdCk7XG4gICAgLy8gfVxuXG4gICAgdmFyIHF1ZXVlID0gW3RoaXNdO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgaWYgKG5vZGUuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQsIG5vZGUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocXVldWUsIG5vZGUuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgdG1wQUFCQiA9IG5ldyBBQUJCKCk7XG5cbi8qKlxuICogR2V0IGFsbCBkYXRhLCBwb3RlbnRpYWxseSBpbnRlcnNlY3RlZCBieSBhIHJheS5cbiAqIEBtZXRob2QgcmF5UXVlcnlcbiAqIEBwYXJhbSAge1JheX0gcmF5XG4gKiBAcGFyYW0gIHtUcmFuc2Zvcm19IHRyZWVUcmFuc2Zvcm1cbiAqIEBwYXJhbSAge2FycmF5fSByZXN1bHRcbiAqIEByZXR1cm4ge2FycmF5fSBUaGUgXCJyZXN1bHRcIiBvYmplY3RcbiAqL1xuT2N0cmVlTm9kZS5wcm90b3R5cGUucmF5UXVlcnkgPSBmdW5jdGlvbihyYXksIHRyZWVUcmFuc2Zvcm0sIHJlc3VsdCkge1xuXG4gICAgLy8gVXNlIGFhYmIgcXVlcnkgZm9yIG5vdy5cbiAgICAvLyBAdG9kbyBpbXBsZW1lbnQgcmVhbCByYXkgcXVlcnkgd2hpY2ggbmVlZHMgbGVzcyBsb29rdXBzXG4gICAgcmF5LmdldEFBQkIodG1wQUFCQik7XG4gICAgdG1wQUFCQi50b0xvY2FsRnJhbWUodHJlZVRyYW5zZm9ybSwgdG1wQUFCQik7XG4gICAgdGhpcy5hYWJiUXVlcnkodG1wQUFCQiwgcmVzdWx0KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcmVtb3ZlRW1wdHlOb2Rlc1xuICovXG5PY3RyZWVOb2RlLnByb3RvdHlwZS5yZW1vdmVFbXB0eU5vZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHF1ZXVlID0gW3RoaXNdO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmKCFub2RlLmNoaWxkcmVuW2ldLmRhdGEubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShxdWV1ZSwgbm9kZS5jaGlsZHJlbik7XG4gICAgfVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gUG9vbDtcblxuLyoqXG4gKiBGb3IgcG9vbGluZyBvYmplY3RzIHRoYXQgY2FuIGJlIHJldXNlZC5cbiAqIEBjbGFzcyBQb29sXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUG9vbCgpe1xuICAgIC8qKlxuICAgICAqIFRoZSBwb29sZWQgb2JqZWN0c1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG9iamVjdHNcbiAgICAgKi9cbiAgICB0aGlzLm9iamVjdHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIG9mIHRoZSBvYmplY3RzXG4gICAgICogQHByb3BlcnR5IHttaXhlZH0gdHlwZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IE9iamVjdDtcbn1cblxuLyoqXG4gKiBSZWxlYXNlIGFuIG9iamVjdCBhZnRlciB1c2VcbiAqIEBtZXRob2QgcmVsZWFzZVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5Qb29sLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgTmFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmFyZ3M7IGkrKyl7XG4gICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0XG4gKiBAbWV0aG9kIGdldFxuICogQHJldHVybiB7bWl4ZWR9XG4gKi9cblBvb2wucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5vYmplY3RzLmxlbmd0aD09PTApe1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RPYmplY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RzLnBvcCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29uc3RydWN0IGFuIG9iamVjdC4gU2hvdWxkIGJlIGltcGxtZW50ZWQgaW4gZWFjaCBzdWJjbGFzcy5cbiAqIEBtZXRob2QgY29uc3RydWN0T2JqZWN0XG4gKiBAcmV0dXJuIHttaXhlZH1cbiAqL1xuUG9vbC5wcm90b3R5cGUuY29uc3RydWN0T2JqZWN0ID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25zdHJ1Y3RPYmplY3QoKSBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBQb29sIHN1YmNsYXNzIHlldCFcIik7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcmVzaXplXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxuICogQHJldHVybiB7UG9vbH0gU2VsZiwgZm9yIGNoYWluaW5nXG4gKi9cblBvb2wucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgdmFyIG9iamVjdHMgPSB0aGlzLm9iamVjdHM7XG5cbiAgICB3aGlsZSAob2JqZWN0cy5sZW5ndGggPiBzaXplKSB7XG4gICAgICAgIG9iamVjdHMucG9wKCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9iamVjdHMubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICBvYmplY3RzLnB1c2godGhpcy5jb25zdHJ1Y3RPYmplY3QoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFR1cGxlRGljdGlvbmFyeTtcblxuLyoqXG4gKiBAY2xhc3MgVHVwbGVEaWN0aW9uYXJ5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVHVwbGVEaWN0aW9uYXJ5KCkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgc3RvcmFnZVxuICAgICAqIEBwcm9wZXJ0eSBkYXRhXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSB7IGtleXM6W10gfTtcbn1cblxuLyoqXG4gKiBAbWV0aG9kIGdldFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpLCBqKSB7XG4gICAgaWYgKGkgPiBqKSB7XG4gICAgICAgIC8vIHN3YXBcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgaSA9IHRlbXA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRhdGFbaSsnLScral07XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaSwgaiwgdmFsdWUpIHtcbiAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgaSA9IHRlbXA7XG4gICAgfVxuICAgIHZhciBrZXkgPSBpKyctJytqO1xuXG4gICAgLy8gQ2hlY2sgaWYga2V5IGFscmVhZHkgZXhpc3RzXG4gICAgaWYoIXRoaXMuZ2V0KGksaikpe1xuICAgICAgICB0aGlzLmRhdGEua2V5cy5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCByZXNldFxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgIGtleXMgPSBkYXRhLmtleXM7XG4gICAgd2hpbGUoa2V5cy5sZW5ndGggPiAwKXtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGRlbGV0ZSBkYXRhW2tleV07XG4gICAgfVxufTtcbiIsImZ1bmN0aW9uIFV0aWxzKCl7fVxuXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWxzO1xuXG4vKipcbiAqIEV4dGVuZCBhbiBvcHRpb25zIG9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBkZWZhdWx0c1xuICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIG9iamVjdC4gTWF5IGJlIGZhbHN5OiBpbiB0aGlzIGNhc2UsIGEgbmV3IG9iamVjdCBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqIEBwYXJhbSAge29iamVjdH0gZGVmYXVsdHMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGVmYXVsdCB2YWx1ZXMuXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBtb2RpZmllZCBvcHRpb25zIG9iamVjdC5cbiAqL1xuVXRpbHMuZGVmYXVsdHMgPSBmdW5jdGlvbihvcHRpb25zLCBkZWZhdWx0cyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBmb3IodmFyIGtleSBpbiBkZWZhdWx0cyl7XG4gICAgICAgIGlmKCEoa2V5IGluIG9wdGlvbnMpKXtcbiAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFZlYzNQb29sO1xuXG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIFBvb2wgPSByZXF1aXJlKCcuL1Bvb2wnKTtcblxuLyoqXG4gKiBAY2xhc3MgVmVjM1Bvb2xcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUG9vbFxuICovXG5mdW5jdGlvbiBWZWMzUG9vbCgpe1xuICAgIFBvb2wuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnR5cGUgPSBWZWMzO1xufVxuVmVjM1Bvb2wucHJvdG90eXBlID0gbmV3IFBvb2woKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSB2ZWN0b3JcbiAqIEBtZXRob2QgY29uc3RydWN0T2JqZWN0XG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5WZWMzUG9vbC5wcm90b3R5cGUuY29uc3RydWN0T2JqZWN0ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IFZlYzMoKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IE5hcnJvd3BoYXNlO1xuXG52YXIgQUFCQiA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9BQUJCJyk7XG52YXIgU2hhcGUgPSByZXF1aXJlKCcuLi9zaGFwZXMvU2hhcGUnKTtcbnZhciBSYXkgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUmF5Jyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4uL21hdGgvVHJhbnNmb3JtJyk7XG52YXIgQ29udmV4UG9seWhlZHJvbiA9IHJlcXVpcmUoJy4uL3NoYXBlcy9Db252ZXhQb2x5aGVkcm9uJyk7XG52YXIgUXVhdGVybmlvbiA9IHJlcXVpcmUoJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFNvbHZlciA9IHJlcXVpcmUoJy4uL3NvbHZlci9Tb2x2ZXInKTtcbnZhciBWZWMzUG9vbCA9IHJlcXVpcmUoJy4uL3V0aWxzL1ZlYzNQb29sJyk7XG52YXIgQ29udGFjdEVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xudmFyIEZyaWN0aW9uRXF1YXRpb24gPSByZXF1aXJlKCcuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpO1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyBmb3IgdGhlIFdvcmxkLiBHZW5lcmF0ZXMgQ29udGFjdEVxdWF0aW9ucy5cbiAqIEBjbGFzcyBOYXJyb3dwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAdG9kbyBTcGhlcmUtQ29udmV4UG9seWhlZHJvbiBjb250YWN0c1xuICogQHRvZG8gQ29udGFjdCByZWR1Y3Rpb25cbiAqIEB0b2RvICBzaG91bGQgbW92ZSBtZXRob2RzIHRvIHByb3RvdHlwZVxuICovXG5mdW5jdGlvbiBOYXJyb3dwaGFzZSh3b3JsZCl7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBzdG9yYWdlIG9mIHBvb2xlZCBjb250YWN0IHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBjb250YWN0UG9pbnRQb29sXG4gICAgICovXG4gICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gW107XG5cbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sID0gW107XG5cbiAgICB0aGlzLnJlc3VsdCA9IFtdO1xuICAgIHRoaXMuZnJpY3Rpb25SZXN1bHQgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFBvb2xlZCB2ZWN0b3JzLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM1Bvb2x9IHYzcG9vbFxuICAgICAqL1xuICAgIHRoaXMudjNwb29sID0gbmV3IFZlYzNQb29sKCk7XG5cbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uID0gZmFsc2U7XG59XG5cbi8qKlxuICogTWFrZSBhIGNvbnRhY3Qgb2JqZWN0LCBieSB1c2luZyB0aGUgaW50ZXJuYWwgcG9vbCBvciBjcmVhdGluZyBhIG5ldyBvbmUuXG4gKiBAbWV0aG9kIGNyZWF0ZUNvbnRhY3RFcXVhdGlvblxuICogQHBhcmFtIHtCb2R5fSBiaVxuICogQHBhcmFtIHtCb2R5fSBialxuICogQHBhcmFtIHtTaGFwZX0gc2lcbiAqIEBwYXJhbSB7U2hhcGV9IHNqXG4gKiBAcGFyYW0ge1NoYXBlfSBvdmVycmlkZVNoYXBlQVxuICogQHBhcmFtIHtTaGFwZX0gb3ZlcnJpZGVTaGFwZUJcbiAqIEByZXR1cm4ge0NvbnRhY3RFcXVhdGlvbn1cbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbiA9IGZ1bmN0aW9uKGJpLCBiaiwgc2ksIHNqLCBvdmVycmlkZVNoYXBlQSwgb3ZlcnJpZGVTaGFwZUIpe1xuICAgIHZhciBjO1xuICAgIGlmKHRoaXMuY29udGFjdFBvaW50UG9vbC5sZW5ndGgpe1xuICAgICAgICBjID0gdGhpcy5jb250YWN0UG9pbnRQb29sLnBvcCgpO1xuICAgICAgICBjLmJpID0gYmk7XG4gICAgICAgIGMuYmogPSBiajtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjID0gbmV3IENvbnRhY3RFcXVhdGlvbihiaSwgYmopO1xuICAgIH1cblxuICAgIGMuZW5hYmxlZCA9IGJpLmNvbGxpc2lvblJlc3BvbnNlICYmIGJqLmNvbGxpc2lvblJlc3BvbnNlICYmIHNpLmNvbGxpc2lvblJlc3BvbnNlICYmIHNqLmNvbGxpc2lvblJlc3BvbnNlO1xuXG4gICAgdmFyIGNtID0gdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsO1xuXG4gICAgYy5yZXN0aXR1dGlvbiA9IGNtLnJlc3RpdHV0aW9uO1xuXG4gICAgYy5zZXRTcG9va1BhcmFtcyhcbiAgICAgICAgY20uY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzLFxuICAgICAgICBjbS5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uLFxuICAgICAgICB0aGlzLndvcmxkLmR0XG4gICAgKTtcblxuICAgIHZhciBtYXRBID0gc2kubWF0ZXJpYWwgfHwgYmkubWF0ZXJpYWw7XG4gICAgdmFyIG1hdEIgPSBzai5tYXRlcmlhbCB8fCBiai5tYXRlcmlhbDtcbiAgICBpZihtYXRBICYmIG1hdEIgJiYgbWF0QS5yZXN0aXR1dGlvbiA+PSAwICYmIG1hdEIucmVzdGl0dXRpb24gPj0gMCl7XG4gICAgICAgIGMucmVzdGl0dXRpb24gPSBtYXRBLnJlc3RpdHV0aW9uICogbWF0Qi5yZXN0aXR1dGlvbjtcbiAgICB9XG5cbiAgICBjLnNpID0gb3ZlcnJpZGVTaGFwZUEgfHwgc2k7XG4gICAgYy5zaiA9IG92ZXJyaWRlU2hhcGVCIHx8IHNqO1xuXG4gICAgcmV0dXJuIGM7XG59O1xuXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3RFcXVhdGlvbiwgb3V0QXJyYXkpe1xuICAgIHZhciBib2R5QSA9IGNvbnRhY3RFcXVhdGlvbi5iaTtcbiAgICB2YXIgYm9keUIgPSBjb250YWN0RXF1YXRpb24uYmo7XG4gICAgdmFyIHNoYXBlQSA9IGNvbnRhY3RFcXVhdGlvbi5zaTtcbiAgICB2YXIgc2hhcGVCID0gY29udGFjdEVxdWF0aW9uLnNqO1xuXG4gICAgdmFyIHdvcmxkID0gdGhpcy53b3JsZDtcbiAgICB2YXIgY20gPSB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7XG5cbiAgICAvLyBJZiBmcmljdGlvbiBvciByZXN0aXR1dGlvbiB3ZXJlIHNwZWNpZmllZCBpbiB0aGUgbWF0ZXJpYWwsIHVzZSB0aGVtXG4gICAgdmFyIGZyaWN0aW9uID0gY20uZnJpY3Rpb247XG4gICAgdmFyIG1hdEEgPSBzaGFwZUEubWF0ZXJpYWwgfHwgYm9keUEubWF0ZXJpYWw7XG4gICAgdmFyIG1hdEIgPSBzaGFwZUIubWF0ZXJpYWwgfHwgYm9keUIubWF0ZXJpYWw7XG4gICAgaWYobWF0QSAmJiBtYXRCICYmIG1hdEEuZnJpY3Rpb24gPj0gMCAmJiBtYXRCLmZyaWN0aW9uID49IDApe1xuICAgICAgICBmcmljdGlvbiA9IG1hdEEuZnJpY3Rpb24gKiBtYXRCLmZyaWN0aW9uO1xuICAgIH1cblxuICAgIGlmKGZyaWN0aW9uID4gMCl7XG5cbiAgICAgICAgLy8gQ3JlYXRlIDIgdGFuZ2VudCBlcXVhdGlvbnNcbiAgICAgICAgdmFyIG11ZyA9IGZyaWN0aW9uICogd29ybGQuZ3Jhdml0eS5sZW5ndGgoKTtcbiAgICAgICAgdmFyIHJlZHVjZWRNYXNzID0gKGJvZHlBLmludk1hc3MgKyBib2R5Qi5pbnZNYXNzKTtcbiAgICAgICAgaWYocmVkdWNlZE1hc3MgPiAwKXtcbiAgICAgICAgICAgIHJlZHVjZWRNYXNzID0gMS9yZWR1Y2VkTWFzcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9vbCA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2w7XG4gICAgICAgIHZhciBjMSA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLGJvZHlCLG11ZypyZWR1Y2VkTWFzcyk7XG4gICAgICAgIHZhciBjMiA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLGJvZHlCLG11ZypyZWR1Y2VkTWFzcyk7XG5cbiAgICAgICAgYzEuYmkgPSBjMi5iaSA9IGJvZHlBO1xuICAgICAgICBjMS5iaiA9IGMyLmJqID0gYm9keUI7XG4gICAgICAgIGMxLm1pbkZvcmNlID0gYzIubWluRm9yY2UgPSAtbXVnKnJlZHVjZWRNYXNzO1xuICAgICAgICBjMS5tYXhGb3JjZSA9IGMyLm1heEZvcmNlID0gbXVnKnJlZHVjZWRNYXNzO1xuXG4gICAgICAgIC8vIENvcHkgb3ZlciB0aGUgcmVsYXRpdmUgdmVjdG9yc1xuICAgICAgICBjMS5yaS5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaSk7XG4gICAgICAgIGMxLnJqLmNvcHkoY29udGFjdEVxdWF0aW9uLnJqKTtcbiAgICAgICAgYzIucmkuY29weShjb250YWN0RXF1YXRpb24ucmkpO1xuICAgICAgICBjMi5yai5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaik7XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IHRhbmdlbnRzXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvbi5uaS50YW5nZW50cyhjMS50LCBjMi50KTtcblxuICAgICAgICAvLyBTZXQgc3Bvb2sgcGFyYW1zXG4gICAgICAgIGMxLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCB3b3JsZC5kdCk7XG4gICAgICAgIGMyLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCB3b3JsZC5kdCk7XG5cbiAgICAgICAgYzEuZW5hYmxlZCA9IGMyLmVuYWJsZWQgPSBjb250YWN0RXF1YXRpb24uZW5hYmxlZDtcblxuICAgICAgICBvdXRBcnJheS5wdXNoKGMxLCBjMik7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGF2ZXJhZ2VOb3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIGF2ZXJhZ2VDb250YWN0UG9pbnRBID0gbmV3IFZlYzMoKTtcbnZhciBhdmVyYWdlQ29udGFjdFBvaW50QiA9IG5ldyBWZWMzKCk7XG5cbi8vIFRha2UgdGhlIGF2ZXJhZ2UgTiBsYXRlc3QgY29udGFjdCBwb2ludCBvbiB0aGUgcGxhbmUuXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZSA9IGZ1bmN0aW9uKG51bUNvbnRhY3RzKXtcbiAgICAvLyBUaGUgbGFzdCBjb250YWN0RXF1YXRpb25cbiAgICB2YXIgYyA9IHRoaXMucmVzdWx0W3RoaXMucmVzdWx0Lmxlbmd0aCAtIDFdO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSByZXN1bHQ6IHR3byBcImF2ZXJhZ2VcIiBmcmljdGlvbiBlcXVhdGlvbnNcbiAgICBpZiAoIXRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChjLCB0aGlzLmZyaWN0aW9uUmVzdWx0KSB8fCBudW1Db250YWN0cyA9PT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGYxID0gdGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aCAtIDJdO1xuICAgIHZhciBmMiA9IHRoaXMuZnJpY3Rpb25SZXN1bHRbdGhpcy5mcmljdGlvblJlc3VsdC5sZW5ndGggLSAxXTtcblxuICAgIGF2ZXJhZ2VOb3JtYWwuc2V0WmVybygpO1xuICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnNldFplcm8oKTtcbiAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi5zZXRaZXJvKCk7XG5cbiAgICB2YXIgYm9keUEgPSBjLmJpO1xuICAgIHZhciBib2R5QiA9IGMuYmo7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1udW1Db250YWN0czsgaSsrKXtcbiAgICAgICAgYyA9IHRoaXMucmVzdWx0W3RoaXMucmVzdWx0Lmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgaWYoYy5ib2R5QSAhPT0gYm9keUEpe1xuICAgICAgICAgICAgYXZlcmFnZU5vcm1hbC52YWRkKGMubmksIGF2ZXJhZ2VOb3JtYWwpOyAvLyB2ZWMyLmFkZChlcS50LCBlcS50LCBjLm5vcm1hbEEpO1xuICAgICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEEudmFkZChjLnJpLCBhdmVyYWdlQ29udGFjdFBvaW50QSk7IC8vIHZlYzIuYWRkKGVxLmNvbnRhY3RQb2ludEEsIGVxLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSk7XG4gICAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi52YWRkKGMucmosIGF2ZXJhZ2VDb250YWN0UG9pbnRCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF2ZXJhZ2VOb3JtYWwudnN1YihjLm5pLCBhdmVyYWdlTm9ybWFsKTsgLy8gdmVjMi5zdWIoZXEudCwgZXEudCwgYy5ub3JtYWxBKTtcbiAgICAgICAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnZhZGQoYy5yaiwgYXZlcmFnZUNvbnRhY3RQb2ludEEpOyAvLyB2ZWMyLmFkZChlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEpO1xuICAgICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEIudmFkZChjLnJpLCBhdmVyYWdlQ29udGFjdFBvaW50Qik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaW52TnVtQ29udGFjdHMgPSAxIC8gbnVtQ29udGFjdHM7XG4gICAgYXZlcmFnZUNvbnRhY3RQb2ludEEuc2NhbGUoaW52TnVtQ29udGFjdHMsIGYxLnJpKTsgLy8gdmVjMi5zY2FsZShlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBpbnZOdW1Db250YWN0cyk7XG4gICAgYXZlcmFnZUNvbnRhY3RQb2ludEIuc2NhbGUoaW52TnVtQ29udGFjdHMsIGYxLnJqKTsgLy8gdmVjMi5zY2FsZShlcS5jb250YWN0UG9pbnRCLCBlcS5jb250YWN0UG9pbnRCLCBpbnZOdW1Db250YWN0cyk7XG4gICAgZjIucmkuY29weShmMS5yaSk7IC8vIFNob3VsZCBiZSB0aGUgc2FtZVxuICAgIGYyLnJqLmNvcHkoZjEucmopO1xuICAgIGF2ZXJhZ2VOb3JtYWwubm9ybWFsaXplKCk7XG4gICAgYXZlcmFnZU5vcm1hbC50YW5nZW50cyhmMS50LCBmMi50KTtcbiAgICAvLyByZXR1cm4gZXE7XG59O1xuXG5cbnZhciB0bXBWZWMxID0gbmV3IFZlYzMoKTtcbnZhciB0bXBWZWMyID0gbmV3IFZlYzMoKTtcbnZhciB0bXBRdWF0MSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG52YXIgdG1wUXVhdDIgPSBuZXcgUXVhdGVybmlvbigpO1xuXG4vKipcbiAqIEdlbmVyYXRlIGFsbCBjb250YWN0cyBiZXR3ZWVuIGEgbGlzdCBvZiBib2R5IHBhaXJzXG4gKiBAbWV0aG9kIGdldENvbnRhY3RzXG4gKiBAcGFyYW0ge2FycmF5fSBwMSBBcnJheSBvZiBib2R5IGluZGljZXNcbiAqIEBwYXJhbSB7YXJyYXl9IHAyIEFycmF5IG9mIGJvZHkgaW5kaWNlc1xuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBcnJheSB0byBzdG9yZSBnZW5lcmF0ZWQgY29udGFjdHNcbiAqIEBwYXJhbSB7YXJyYXl9IG9sZGNvbnRhY3RzIE9wdGlvbmFsLiBBcnJheSBvZiByZXVzYWJsZSBjb250YWN0IG9iamVjdHNcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmdldENvbnRhY3RzID0gZnVuY3Rpb24ocDEsIHAyLCB3b3JsZCwgcmVzdWx0LCBvbGRjb250YWN0cywgZnJpY3Rpb25SZXN1bHQsIGZyaWN0aW9uUG9vbCl7XG4gICAgLy8gU2F2ZSBvbGQgY29udGFjdCBvYmplY3RzXG4gICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gb2xkY29udGFjdHM7XG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbCA9IGZyaWN0aW9uUG9vbDtcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB0aGlzLmZyaWN0aW9uUmVzdWx0ID0gZnJpY3Rpb25SZXN1bHQ7XG5cbiAgICB2YXIgcWkgPSB0bXBRdWF0MTtcbiAgICB2YXIgcWogPSB0bXBRdWF0MjtcbiAgICB2YXIgeGkgPSB0bXBWZWMxO1xuICAgIHZhciB4aiA9IHRtcFZlYzI7XG5cbiAgICBmb3IodmFyIGs9MCwgTj1wMS5sZW5ndGg7IGshPT1OOyBrKyspe1xuXG4gICAgICAgIC8vIEdldCBjdXJyZW50IGNvbGxpc2lvbiBib2RpZXNcbiAgICAgICAgdmFyIGJpID0gcDFba10sXG4gICAgICAgICAgICBiaiA9IHAyW2tdO1xuXG4gICAgICAgIC8vIEdldCBjb250YWN0IG1hdGVyaWFsXG4gICAgICAgIHZhciBib2R5Q29udGFjdE1hdGVyaWFsID0gbnVsbDtcbiAgICAgICAgaWYoYmkubWF0ZXJpYWwgJiYgYmoubWF0ZXJpYWwpe1xuICAgICAgICAgICAgYm9keUNvbnRhY3RNYXRlcmlhbCA9IHdvcmxkLmdldENvbnRhY3RNYXRlcmlhbChiaS5tYXRlcmlhbCxiai5tYXRlcmlhbCkgfHwgbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmkuc2hhcGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBiaS5xdWF0ZXJuaW9uLm11bHQoYmkuc2hhcGVPcmllbnRhdGlvbnNbaV0sIHFpKTtcbiAgICAgICAgICAgIGJpLnF1YXRlcm5pb24udm11bHQoYmkuc2hhcGVPZmZzZXRzW2ldLCB4aSk7XG4gICAgICAgICAgICB4aS52YWRkKGJpLnBvc2l0aW9uLCB4aSk7XG4gICAgICAgICAgICB2YXIgc2kgPSBiaS5zaGFwZXNbaV07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmouc2hhcGVzLmxlbmd0aDsgaisrKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHdvcmxkIHRyYW5zZm9ybSBvZiBzaGFwZXNcbiAgICAgICAgICAgICAgICBiai5xdWF0ZXJuaW9uLm11bHQoYmouc2hhcGVPcmllbnRhdGlvbnNbal0sIHFqKTtcbiAgICAgICAgICAgICAgICBiai5xdWF0ZXJuaW9uLnZtdWx0KGJqLnNoYXBlT2Zmc2V0c1tqXSwgeGopO1xuICAgICAgICAgICAgICAgIHhqLnZhZGQoYmoucG9zaXRpb24sIHhqKTtcbiAgICAgICAgICAgICAgICB2YXIgc2ogPSBiai5zaGFwZXNbal07XG5cbiAgICAgICAgICAgICAgICBpZih4aS5kaXN0YW5jZVRvKHhqKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpe1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgY29sbGlzaW9uIG1hdGVyaWFsXG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlQ29udGFjdE1hdGVyaWFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZihzaS5tYXRlcmlhbCAmJiBzai5tYXRlcmlhbCl7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlQ29udGFjdE1hdGVyaWFsID0gd29ybGQuZ2V0Q29udGFjdE1hdGVyaWFsKHNpLm1hdGVyaWFsLHNqLm1hdGVyaWFsKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IHNoYXBlQ29udGFjdE1hdGVyaWFsIHx8IGJvZHlDb250YWN0TWF0ZXJpYWwgfHwgd29ybGQuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBjb250YWN0c1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlciA9IHRoaXNbc2kudHlwZSB8IHNqLnR5cGVdO1xuICAgICAgICAgICAgICAgIGlmKHJlc29sdmVyKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpLnR5cGUgPCBzai50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlci5jYWxsKHRoaXMsIHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgc2ksIHNqKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyLmNhbGwodGhpcywgc2osIHNpLCB4aiwgeGksIHFqLCBxaSwgYmosIGJpLCBzaSwgc2opO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIG51bVdhcm5pbmdzID0gMDtcbnZhciBtYXhXYXJuaW5ncyA9IDEwO1xuXG5mdW5jdGlvbiB3YXJuKG1zZyl7XG4gICAgaWYobnVtV2FybmluZ3MgPiBtYXhXYXJuaW5ncyl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBudW1XYXJuaW5ncysrO1xuXG4gICAgY29uc29sZS53YXJuKG1zZyk7XG59XG5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5CT1hdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5ib3hCb3ggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiail7XG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7XG4gICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2oubWF0ZXJpYWw7XG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7XG4gICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2ouY29sbGlzaW9uUmVzcG9uc2U7XG4gICAgdGhpcy5jb252ZXhDb252ZXgoc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbix4aSx4aixxaSxxaixiaSxiaixzaSxzaik7XG59O1xuXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmJveENvbnZleCA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqKXtcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzaS5tYXRlcmlhbDtcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTtcbiAgICB0aGlzLmNvbnZleENvbnZleChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sc2oseGkseGoscWkscWosYmksYmosc2ksc2opO1xufTtcblxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLkJPWCB8IFNoYXBlLnR5cGVzLlBBUlRJQ0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuYm94UGFydGljbGUgPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiail7XG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7XG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7XG4gICAgdGhpcy5jb252ZXhQYXJ0aWNsZShzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sc2oseGkseGoscWkscWosYmksYmosc2ksc2opO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNwaGVyZVNwaGVyZVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVTcGhlcmUgPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqKXtcbiAgICAvLyBXZSB3aWxsIGhhdmUgb25seSBvbmUgY29udGFjdCBpbiB0aGlzIGNhc2VcbiAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xuXG4gICAgLy8gQ29udGFjdCBub3JtYWxcbiAgICB4ai52c3ViKHhpLCByLm5pKTtcbiAgICByLm5pLm5vcm1hbGl6ZSgpO1xuXG4gICAgLy8gQ29udGFjdCBwb2ludCBsb2NhdGlvbnNcbiAgICByLnJpLmNvcHkoci5uaSk7XG4gICAgci5yai5jb3B5KHIubmkpO1xuICAgIHIucmkubXVsdChzaS5yYWRpdXMsIHIucmkpO1xuICAgIHIucmoubXVsdCgtc2oucmFkaXVzLCByLnJqKTtcblxuICAgIHIucmkudmFkZCh4aSwgci5yaSk7XG4gICAgci5yaS52c3ViKGJpLnBvc2l0aW9uLCByLnJpKTtcblxuICAgIHIucmoudmFkZCh4aiwgci5yaik7XG4gICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcblxuICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG5cbiAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcGxhbmVUcmltZXNoXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xudmFyIHBsYW5lVHJpbWVzaF9ub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIHBsYW5lVHJpbWVzaF9yZWxwb3MgPSBuZXcgVmVjMygpO1xudmFyIHBsYW5lVHJpbWVzaF9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpO1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuVFJJTUVTSF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lVHJpbWVzaCA9IGZ1bmN0aW9uKFxuICAgIHBsYW5lU2hhcGUsXG4gICAgdHJpbWVzaFNoYXBlLFxuICAgIHBsYW5lUG9zLFxuICAgIHRyaW1lc2hQb3MsXG4gICAgcGxhbmVRdWF0LFxuICAgIHRyaW1lc2hRdWF0LFxuICAgIHBsYW5lQm9keSxcbiAgICB0cmltZXNoQm9keSxcbiAgICByc2ksXG4gICAgcnNqXG4pe1xuICAgIC8vIE1ha2UgY29udGFjdHMhXG4gICAgdmFyIHYgPSBuZXcgVmVjMygpO1xuXG4gICAgdmFyIG5vcm1hbCA9IHBsYW5lVHJpbWVzaF9ub3JtYWw7XG4gICAgbm9ybWFsLnNldCgwLDAsMSk7XG4gICAgcGxhbmVRdWF0LnZtdWx0KG5vcm1hbCxub3JtYWwpOyAvLyBUdXJuIG5vcm1hbCBhY2NvcmRpbmcgdG8gcGxhbmVcblxuICAgIGZvcih2YXIgaT0wOyBpPHRyaW1lc2hTaGFwZS52ZXJ0aWNlcy5sZW5ndGggLyAzOyBpKyspe1xuXG4gICAgICAgIC8vIEdldCB3b3JsZCB2ZXJ0ZXggZnJvbSB0cmltZXNoXG4gICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgoaSwgdik7XG5cbiAgICAgICAgLy8gU2FmZSB1cFxuICAgICAgICB2YXIgdjIgPSBuZXcgVmVjMygpO1xuICAgICAgICB2Mi5jb3B5KHYpO1xuICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodHJpbWVzaFBvcywgdHJpbWVzaFF1YXQsIHYyLCB2KTtcblxuICAgICAgICAvLyBDaGVjayBwbGFuZSBzaWRlXG4gICAgICAgIHZhciByZWxwb3MgPSBwbGFuZVRyaW1lc2hfcmVscG9zO1xuICAgICAgICB2LnZzdWIocGxhbmVQb3MsIHJlbHBvcyk7XG4gICAgICAgIHZhciBkb3QgPSBub3JtYWwuZG90KHJlbHBvcyk7XG5cbiAgICAgICAgaWYoZG90IDw9IDAuMCl7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSx0cmltZXNoQm9keSxwbGFuZVNoYXBlLHRyaW1lc2hTaGFwZSxyc2kscnNqKTtcblxuICAgICAgICAgICAgci5uaS5jb3B5KG5vcm1hbCk7IC8vIENvbnRhY3Qgbm9ybWFsIGlzIHRoZSBwbGFuZSBub3JtYWxcblxuICAgICAgICAgICAgLy8gR2V0IHZlcnRleCBwb3NpdGlvbiBwcm9qZWN0ZWQgb24gcGxhbmVcbiAgICAgICAgICAgIHZhciBwcm9qZWN0ZWQgPSBwbGFuZVRyaW1lc2hfcHJvamVjdGVkO1xuICAgICAgICAgICAgbm9ybWFsLnNjYWxlKHJlbHBvcy5kb3Qobm9ybWFsKSwgcHJvamVjdGVkKTtcbiAgICAgICAgICAgIHYudnN1Yihwcm9qZWN0ZWQscHJvamVjdGVkKTtcblxuICAgICAgICAgICAgLy8gcmkgaXMgdGhlIHByb2plY3RlZCB3b3JsZCBwb3NpdGlvbiBtaW51cyBwbGFuZSBwb3NpdGlvblxuICAgICAgICAgICAgci5yaS5jb3B5KHByb2plY3RlZCk7XG4gICAgICAgICAgICByLnJpLnZzdWIocGxhbmVCb2R5LnBvc2l0aW9uLCByLnJpKTtcblxuICAgICAgICAgICAgci5yai5jb3B5KHYpO1xuICAgICAgICAgICAgci5yai52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgLy8gU3RvcmUgcmVzdWx0XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNwaGVyZVRyaW1lc2hcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNwaGVyZVNoYXBlXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICB0cmltZXNoU2hhcGVcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHNwaGVyZVBvc1xuICogQHBhcmFtICB7VmVjM30gICAgICAgdHJpbWVzaFBvc1xuICogQHBhcmFtICB7UXVhdGVybmlvbn0gc3BoZXJlUXVhdFxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gdHJpbWVzaFF1YXRcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHNwaGVyZUJvZHlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIHRyaW1lc2hCb2R5XG4gKi9cbnZhciBzcGhlcmVUcmltZXNoX25vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlVHJpbWVzaF9yZWxwb3MgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfcHJvamVjdGVkID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3YgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfdjIgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfZWRnZVZlcnRleEEgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfZWRnZVZlcnRleEIgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvciA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlVHJpbWVzaF9lZGdlVmVjdG9yVW5pdCA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZVBvcyA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlVHJpbWVzaF90bXAgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfdmEgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfdmIgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfdmMgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVBQUJCID0gbmV3IEFBQkIoKTtcbnZhciBzcGhlcmVUcmltZXNoX3RyaWFuZ2xlcyA9IFtdO1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLlRSSU1FU0hdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVUcmltZXNoID0gZnVuY3Rpb24gKFxuICAgIHNwaGVyZVNoYXBlLFxuICAgIHRyaW1lc2hTaGFwZSxcbiAgICBzcGhlcmVQb3MsXG4gICAgdHJpbWVzaFBvcyxcbiAgICBzcGhlcmVRdWF0LFxuICAgIHRyaW1lc2hRdWF0LFxuICAgIHNwaGVyZUJvZHksXG4gICAgdHJpbWVzaEJvZHksXG4gICAgcnNpLFxuICAgIHJzalxuKSB7XG5cbiAgICB2YXIgZWRnZVZlcnRleEEgPSBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhBO1xuICAgIHZhciBlZGdlVmVydGV4QiA9IHNwaGVyZVRyaW1lc2hfZWRnZVZlcnRleEI7XG4gICAgdmFyIGVkZ2VWZWN0b3IgPSBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3I7XG4gICAgdmFyIGVkZ2VWZWN0b3JVbml0ID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVjdG9yVW5pdDtcbiAgICB2YXIgbG9jYWxTcGhlcmVQb3MgPSBzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlUG9zO1xuICAgIHZhciB0bXAgPSBzcGhlcmVUcmltZXNoX3RtcDtcbiAgICB2YXIgbG9jYWxTcGhlcmVBQUJCID0gc3BoZXJlVHJpbWVzaF9sb2NhbFNwaGVyZUFBQkI7XG4gICAgdmFyIHYyID0gc3BoZXJlVHJpbWVzaF92MjtcbiAgICB2YXIgcmVscG9zID0gc3BoZXJlVHJpbWVzaF9yZWxwb3M7XG4gICAgdmFyIHRyaWFuZ2xlcyA9IHNwaGVyZVRyaW1lc2hfdHJpYW5nbGVzO1xuXG4gICAgLy8gQ29udmVydCBzcGhlcmUgcG9zaXRpb24gdG8gbG9jYWwgaW4gdGhlIHRyaW1lc2hcbiAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUodHJpbWVzaFBvcywgdHJpbWVzaFF1YXQsIHNwaGVyZVBvcywgbG9jYWxTcGhlcmVQb3MpO1xuXG4gICAgLy8gR2V0IHRoZSBhYWJiIG9mIHRoZSBzcGhlcmUgbG9jYWxseSBpbiB0aGUgdHJpbWVzaFxuICAgIHZhciBzcGhlcmVSYWRpdXMgPSBzcGhlcmVTaGFwZS5yYWRpdXM7XG4gICAgbG9jYWxTcGhlcmVBQUJCLmxvd2VyQm91bmQuc2V0KFxuICAgICAgICBsb2NhbFNwaGVyZVBvcy54IC0gc3BoZXJlUmFkaXVzLFxuICAgICAgICBsb2NhbFNwaGVyZVBvcy55IC0gc3BoZXJlUmFkaXVzLFxuICAgICAgICBsb2NhbFNwaGVyZVBvcy56IC0gc3BoZXJlUmFkaXVzXG4gICAgKTtcbiAgICBsb2NhbFNwaGVyZUFBQkIudXBwZXJCb3VuZC5zZXQoXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnggKyBzcGhlcmVSYWRpdXMsXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnkgKyBzcGhlcmVSYWRpdXMsXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnogKyBzcGhlcmVSYWRpdXNcbiAgICApO1xuXG4gICAgdHJpbWVzaFNoYXBlLmdldFRyaWFuZ2xlc0luQUFCQihsb2NhbFNwaGVyZUFBQkIsIHRyaWFuZ2xlcyk7XG4gICAgLy9mb3IgKHZhciBpID0gMDsgaSA8IHRyaW1lc2hTaGFwZS5pbmRpY2VzLmxlbmd0aCAvIDM7IGkrKykgdHJpYW5nbGVzLnB1c2goaSk7IC8vIEFsbFxuXG4gICAgLy8gVmVydGljZXNcbiAgICB2YXIgdiA9IHNwaGVyZVRyaW1lc2hfdjtcbiAgICB2YXIgcmFkaXVzU3F1YXJlZCA9IHNwaGVyZVNoYXBlLnJhZGl1cyAqIHNwaGVyZVNoYXBlLnJhZGl1cztcbiAgICBmb3IodmFyIGk9MDsgaTx0cmlhbmdsZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGorKykge1xuXG4gICAgICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KHRyaW1lc2hTaGFwZS5pbmRpY2VzW3RyaWFuZ2xlc1tpXSAqIDMgKyBqXSwgdik7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHZlcnRleCBvdmVybGFwIGluIHNwaGVyZVxuICAgICAgICAgICAgdi52c3ViKGxvY2FsU3BoZXJlUG9zLCByZWxwb3MpO1xuXG4gICAgICAgICAgICBpZihyZWxwb3Mubm9ybTIoKSA8PSByYWRpdXNTcXVhcmVkKXtcblxuICAgICAgICAgICAgICAgIC8vIFNhZmUgdXBcbiAgICAgICAgICAgICAgICB2Mi5jb3B5KHYpO1xuICAgICAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdjIsIHYpO1xuXG4gICAgICAgICAgICAgICAgdi52c3ViKHNwaGVyZVBvcywgcmVscG9zKTtcblxuICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSx0cmltZXNoQm9keSxzcGhlcmVTaGFwZSx0cmltZXNoU2hhcGUscnNpLHJzaik7XG4gICAgICAgICAgICAgICAgci5uaS5jb3B5KHJlbHBvcyk7XG4gICAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgIC8vIHJpIGlzIHRoZSB2ZWN0b3IgZnJvbSBzcGhlcmUgY2VudGVyIHRvIHRoZSBzcGhlcmUgc3VyZmFjZVxuICAgICAgICAgICAgICAgIHIucmkuY29weShyLm5pKTtcbiAgICAgICAgICAgICAgICByLnJpLnNjYWxlKHNwaGVyZVNoYXBlLnJhZGl1cywgci5yaSk7XG4gICAgICAgICAgICAgICAgci5yaS52YWRkKHNwaGVyZVBvcywgci5yaSk7XG4gICAgICAgICAgICAgICAgci5yaS52c3ViKHNwaGVyZUJvZHkucG9zaXRpb24sIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgci5yai5jb3B5KHYpO1xuICAgICAgICAgICAgICAgIHIucmoudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSByZXN1bHRcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGFsbCBlZGdlc1xuICAgIGZvcih2YXIgaT0wOyBpPHRyaWFuZ2xlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG5cbiAgICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgodHJpbWVzaFNoYXBlLmluZGljZXNbdHJpYW5nbGVzW2ldICogMyArIGpdLCBlZGdlVmVydGV4QSk7XG4gICAgICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KHRyaW1lc2hTaGFwZS5pbmRpY2VzW3RyaWFuZ2xlc1tpXSAqIDMgKyAoKGorMSklMyldLCBlZGdlVmVydGV4Qik7XG4gICAgICAgICAgICBlZGdlVmVydGV4Qi52c3ViKGVkZ2VWZXJ0ZXhBLCBlZGdlVmVjdG9yKTtcblxuICAgICAgICAgICAgLy8gUHJvamVjdCBzcGhlcmUgcG9zaXRpb24gdG8gdGhlIGVkZ2VcbiAgICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEIsIHRtcCk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25BbG9uZ0VkZ2VCID0gdG1wLmRvdChlZGdlVmVjdG9yKTtcblxuICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkFsb25nRWRnZUEgPSB0bXAuZG90KGVkZ2VWZWN0b3IpO1xuXG4gICAgICAgICAgICBpZihwb3NpdGlvbkFsb25nRWRnZUEgPiAwICYmIHBvc2l0aW9uQWxvbmdFZGdlQiA8IDApe1xuXG4gICAgICAgICAgICAgICAgLy8gTm93IGNoZWNrIHRoZSBvcnRob2dvbmFsIGRpc3RhbmNlIGZyb20gZWRnZSB0byBzcGhlcmUgY2VudGVyXG4gICAgICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTtcblxuICAgICAgICAgICAgICAgIGVkZ2VWZWN0b3JVbml0LmNvcHkoZWRnZVZlY3Rvcik7XG4gICAgICAgICAgICAgICAgZWRnZVZlY3RvclVuaXQubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25BbG9uZ0VkZ2VBID0gdG1wLmRvdChlZGdlVmVjdG9yVW5pdCk7XG5cbiAgICAgICAgICAgICAgICBlZGdlVmVjdG9yVW5pdC5zY2FsZShwb3NpdGlvbkFsb25nRWRnZUEsIHRtcCk7XG4gICAgICAgICAgICAgICAgdG1wLnZhZGQoZWRnZVZlcnRleEEsIHRtcCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0bXAgaXMgbm93IHRoZSBzcGhlcmUgY2VudGVyIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgZWRnZSwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSB0cmltZXNoIGZyYW1lXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSB0bXAuZGlzdGFuY2VUbyhsb2NhbFNwaGVyZVBvcyk7XG4gICAgICAgICAgICAgICAgaWYoZGlzdCA8IHNwaGVyZVNoYXBlLnJhZGl1cyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSwgdHJpbWVzaEJvZHksIHNwaGVyZVNoYXBlLCB0cmltZXNoU2hhcGUscnNpLHJzaik7XG5cbiAgICAgICAgICAgICAgICAgICAgdG1wLnZzdWIobG9jYWxTcGhlcmVQb3MsIHIubmkpO1xuICAgICAgICAgICAgICAgICAgICByLm5pLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICByLm5pLnNjYWxlKHNwaGVyZVNoYXBlLnJhZGl1cywgci5yaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB0bXAsIHRtcCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcC52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHRyaW1lc2hRdWF0LCByLm5pLCByLm5pKTtcbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZSh0cmltZXNoUXVhdCwgci5yaSwgci5yaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyaWFuZ2xlIGZhY2VzXG4gICAgdmFyIHZhID0gc3BoZXJlVHJpbWVzaF92YTtcbiAgICB2YXIgdmIgPSBzcGhlcmVUcmltZXNoX3ZiO1xuICAgIHZhciB2YyA9IHNwaGVyZVRyaW1lc2hfdmM7XG4gICAgdmFyIG5vcm1hbCA9IHNwaGVyZVRyaW1lc2hfbm9ybWFsO1xuICAgIGZvcih2YXIgaT0wLCBOID0gdHJpYW5nbGVzLmxlbmd0aDsgaSAhPT0gTjsgaSsrKXtcbiAgICAgICAgdHJpbWVzaFNoYXBlLmdldFRyaWFuZ2xlVmVydGljZXModHJpYW5nbGVzW2ldLCB2YSwgdmIsIHZjKTtcbiAgICAgICAgdHJpbWVzaFNoYXBlLmdldE5vcm1hbCh0cmlhbmdsZXNbaV0sIG5vcm1hbCk7XG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIodmEsIHRtcCk7XG4gICAgICAgIHZhciBkaXN0ID0gdG1wLmRvdChub3JtYWwpO1xuICAgICAgICBub3JtYWwuc2NhbGUoZGlzdCwgdG1wKTtcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1Yih0bXAsIHRtcCk7XG5cbiAgICAgICAgLy8gdG1wIGlzIG5vdyB0aGUgc3BoZXJlIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgdHJpYW5nbGUgcGxhbmVcbiAgICAgICAgZGlzdCA9IHRtcC5kaXN0YW5jZVRvKGxvY2FsU3BoZXJlUG9zKTtcbiAgICAgICAgaWYoUmF5LnBvaW50SW5UcmlhbmdsZSh0bXAsIHZhLCB2YiwgdmMpICYmIGRpc3QgPCBzcGhlcmVTaGFwZS5yYWRpdXMpe1xuICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgc3BoZXJlU2hhcGUsIHRyaW1lc2hTaGFwZSxyc2kscnNqKTtcblxuICAgICAgICAgICAgdG1wLnZzdWIobG9jYWxTcGhlcmVQb3MsIHIubmkpO1xuICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHIubmkuc2NhbGUoc3BoZXJlU2hhcGUucmFkaXVzLCByLnJpKTtcblxuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB0bXAsIHRtcCk7XG4gICAgICAgICAgICB0bXAudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIubmksIHIubmkpO1xuICAgICAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZSh0cmltZXNoUXVhdCwgci5yaSwgci5yaSk7XG5cbiAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0cmlhbmdsZXMubGVuZ3RoID0gMDtcbn07XG5cbnZhciBwb2ludF9vbl9wbGFuZV90b19zcGhlcmUgPSBuZXcgVmVjMygpO1xudmFyIHBsYW5lX3RvX3NwaGVyZV9vcnRobyA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBzcGhlcmVQbGFuZVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5QTEFORV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZVBsYW5lID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmoscnNpLHJzail7XG4gICAgLy8gV2Ugd2lsbCBoYXZlIG9uZSBjb250YWN0IGluIHRoaXMgY2FzZVxuICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaik7XG5cbiAgICAvLyBDb250YWN0IG5vcm1hbFxuICAgIHIubmkuc2V0KDAsMCwxKTtcbiAgICBxai52bXVsdChyLm5pLCByLm5pKTtcbiAgICByLm5pLm5lZ2F0ZShyLm5pKTsgLy8gYm9keSBpIGlzIHRoZSBzcGhlcmUsIGZsaXAgbm9ybWFsXG4gICAgci5uaS5ub3JtYWxpemUoKTsgLy8gTmVlZGVkP1xuXG4gICAgLy8gVmVjdG9yIGZyb20gc3BoZXJlIGNlbnRlciB0byBjb250YWN0IHBvaW50XG4gICAgci5uaS5tdWx0KHNpLnJhZGl1cywgci5yaSk7XG5cbiAgICAvLyBQcm9qZWN0IGRvd24gc3BoZXJlIG9uIHBsYW5lXG4gICAgeGkudnN1Yih4aiwgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlKTtcbiAgICByLm5pLm11bHQoci5uaS5kb3QocG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlKSwgcGxhbmVfdG9fc3BoZXJlX29ydGhvKTtcbiAgICBwb2ludF9vbl9wbGFuZV90b19zcGhlcmUudnN1YihwbGFuZV90b19zcGhlcmVfb3J0aG8sci5yaik7IC8vIFRoZSBzcGhlcmUgcG9zaXRpb24gcHJvamVjdGVkIHRvIHBsYW5lXG5cbiAgICBpZigtcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlLmRvdChyLm5pKSA8PSBzaS5yYWRpdXMpe1xuXG4gICAgICAgIC8vIE1ha2UgaXQgcmVsYXRpdmUgdG8gdGhlIGJvZHlcbiAgICAgICAgdmFyIHJpID0gci5yaTtcbiAgICAgICAgdmFyIHJqID0gci5yajtcbiAgICAgICAgcmkudmFkZCh4aSwgcmkpO1xuICAgICAgICByaS52c3ViKGJpLnBvc2l0aW9uLCByaSk7XG4gICAgICAgIHJqLnZhZGQoeGosIHJqKTtcbiAgICAgICAgcmoudnN1Yihiai5wb3NpdGlvbiwgcmopO1xuXG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICB9XG59O1xuXG4vLyBTZWUgaHR0cDovL2J1bGxldHBoeXNpY3MuY29tL0J1bGxldC9CdWxsZXRGdWxsL1NwaGVyZVRyaWFuZ2xlRGV0ZWN0b3JfOGNwcF9zb3VyY2UuaHRtbFxudmFyIHBvaW50SW5Qb2x5Z29uX2VkZ2UgPSBuZXcgVmVjMygpO1xudmFyIHBvaW50SW5Qb2x5Z29uX2VkZ2VfeF9ub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIHBvaW50SW5Qb2x5Z29uX3Z0cCA9IG5ldyBWZWMzKCk7XG5mdW5jdGlvbiBwb2ludEluUG9seWdvbih2ZXJ0cywgbm9ybWFsLCBwKXtcbiAgICB2YXIgcG9zaXRpdmVSZXN1bHQgPSBudWxsO1xuICAgIHZhciBOID0gdmVydHMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcblxuICAgICAgICAvLyBHZXQgZWRnZSB0byB0aGUgbmV4dCB2ZXJ0ZXhcbiAgICAgICAgdmFyIGVkZ2UgPSBwb2ludEluUG9seWdvbl9lZGdlO1xuICAgICAgICB2ZXJ0c1soaSsxKSAlIChOKV0udnN1Yih2LGVkZ2UpO1xuXG4gICAgICAgIC8vIEdldCBjcm9zcyBwcm9kdWN0IGJldHdlZW4gcG9seWdvbiBub3JtYWwgYW5kIHRoZSBlZGdlXG4gICAgICAgIHZhciBlZGdlX3hfbm9ybWFsID0gcG9pbnRJblBvbHlnb25fZWRnZV94X25vcm1hbDtcbiAgICAgICAgLy92YXIgZWRnZV94X25vcm1hbCA9IG5ldyBWZWMzKCk7XG4gICAgICAgIGVkZ2UuY3Jvc3Mobm9ybWFsLGVkZ2VfeF9ub3JtYWwpO1xuXG4gICAgICAgIC8vIEdldCB2ZWN0b3IgYmV0d2VlbiBwb2ludCBhbmQgY3VycmVudCB2ZXJ0ZXhcbiAgICAgICAgdmFyIHZlcnRleF90b19wID0gcG9pbnRJblBvbHlnb25fdnRwO1xuICAgICAgICBwLnZzdWIodix2ZXJ0ZXhfdG9fcCk7XG5cbiAgICAgICAgLy8gVGhpcyBkb3QgcHJvZHVjdCBkZXRlcm1pbmVzIHdoaWNoIHNpZGUgb2YgdGhlIGVkZ2UgdGhlIHBvaW50IGlzXG4gICAgICAgIHZhciByID0gZWRnZV94X25vcm1hbC5kb3QodmVydGV4X3RvX3ApO1xuXG4gICAgICAgIC8vIElmIGFsbCBzdWNoIGRvdCBwcm9kdWN0cyBoYXZlIHNhbWUgc2lnbiwgd2UgYXJlIGluc2lkZSB0aGUgcG9seWdvbi5cbiAgICAgICAgaWYocG9zaXRpdmVSZXN1bHQ9PT1udWxsIHx8IChyPjAgJiYgcG9zaXRpdmVSZXN1bHQ9PT10cnVlKSB8fCAocjw9MCAmJiBwb3NpdGl2ZVJlc3VsdD09PWZhbHNlKSl7XG4gICAgICAgICAgICBpZihwb3NpdGl2ZVJlc3VsdD09PW51bGwpe1xuICAgICAgICAgICAgICAgIHBvc2l0aXZlUmVzdWx0ID0gcj4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEVuY291bnRlcmVkIHNvbWUgb3RoZXIgc2lnbi4gRXhpdC5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGdvdCBoZXJlLCBhbGwgZG90IHByb2R1Y3RzIHdlcmUgb2YgdGhlIHNhbWUgc2lnbi5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGJveF90b19zcGhlcmUgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUJveF9ucyA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQm94X25zMSA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQm94X25zMiA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQm94X3NpZGVzID0gW25ldyBWZWMzKCksbmV3IFZlYzMoKSxuZXcgVmVjMygpLG5ldyBWZWMzKCksbmV3IFZlYzMoKSxuZXcgVmVjMygpXTtcbnZhciBzcGhlcmVCb3hfc3BoZXJlX3RvX2Nvcm5lciA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQm94X3NpZGVfbnMgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUJveF9zaWRlX25zMSA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQm94X3NpZGVfbnMyID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHNwaGVyZUJveFxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5CT1hdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVCb3ggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqKXtcbiAgICB2YXIgdjNwb29sID0gdGhpcy52M3Bvb2w7XG5cbiAgICAvLyB3ZSByZWZlciB0byB0aGUgYm94IGFzIGJvZHkgalxuICAgIHZhciBzaWRlcyA9IHNwaGVyZUJveF9zaWRlcztcbiAgICB4aS52c3ViKHhqLGJveF90b19zcGhlcmUpO1xuICAgIHNqLmdldFNpZGVOb3JtYWxzKHNpZGVzLHFqKTtcbiAgICB2YXIgUiA9ICAgICBzaS5yYWRpdXM7XG4gICAgdmFyIHBlbmV0cmF0aW5nX3NpZGVzID0gW107XG5cbiAgICAvLyBDaGVjayBzaWRlIChwbGFuZSkgaW50ZXJzZWN0aW9uc1xuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuXG4gICAgLy8gU3RvcmUgdGhlIHJlc3VsdGluZyBzaWRlIHBlbmV0cmF0aW9uIGluZm9cbiAgICB2YXIgc2lkZV9ucyA9IHNwaGVyZUJveF9zaWRlX25zO1xuICAgIHZhciBzaWRlX25zMSA9IHNwaGVyZUJveF9zaWRlX25zMTtcbiAgICB2YXIgc2lkZV9uczIgPSBzcGhlcmVCb3hfc2lkZV9uczI7XG4gICAgdmFyIHNpZGVfaCA9IG51bGw7XG4gICAgdmFyIHNpZGVfcGVuZXRyYXRpb25zID0gMDtcbiAgICB2YXIgc2lkZV9kb3QxID0gMDtcbiAgICB2YXIgc2lkZV9kb3QyID0gMDtcbiAgICB2YXIgc2lkZV9kaXN0YW5jZSA9IG51bGw7XG4gICAgZm9yKHZhciBpZHg9MCxuc2lkZXM9c2lkZXMubGVuZ3RoOyBpZHghPT1uc2lkZXMgJiYgZm91bmQ9PT1mYWxzZTsgaWR4Kyspe1xuICAgICAgICAvLyBHZXQgdGhlIHBsYW5lIHNpZGUgbm9ybWFsIChucylcbiAgICAgICAgdmFyIG5zID0gc3BoZXJlQm94X25zO1xuICAgICAgICBucy5jb3B5KHNpZGVzW2lkeF0pO1xuXG4gICAgICAgIHZhciBoID0gbnMubm9ybSgpO1xuICAgICAgICBucy5ub3JtYWxpemUoKTtcblxuICAgICAgICAvLyBUaGUgbm9ybWFsL2Rpc3RhbmNlIGRvdCBwcm9kdWN0IHRlbGxzIHdoaWNoIHNpZGUgb2YgdGhlIHBsYW5lIHdlIGFyZVxuICAgICAgICB2YXIgZG90ID0gYm94X3RvX3NwaGVyZS5kb3QobnMpO1xuXG4gICAgICAgIGlmKGRvdDxoK1IgJiYgZG90PjApe1xuICAgICAgICAgICAgLy8gSW50ZXJzZWN0cyBwbGFuZS4gTm93IGNoZWNrIHRoZSBvdGhlciB0d28gZGltZW5zaW9uc1xuICAgICAgICAgICAgdmFyIG5zMSA9IHNwaGVyZUJveF9uczE7XG4gICAgICAgICAgICB2YXIgbnMyID0gc3BoZXJlQm94X25zMjtcbiAgICAgICAgICAgIG5zMS5jb3B5KHNpZGVzWyhpZHgrMSklM10pO1xuICAgICAgICAgICAgbnMyLmNvcHkoc2lkZXNbKGlkeCsyKSUzXSk7XG4gICAgICAgICAgICB2YXIgaDEgPSBuczEubm9ybSgpO1xuICAgICAgICAgICAgdmFyIGgyID0gbnMyLm5vcm0oKTtcbiAgICAgICAgICAgIG5zMS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIG5zMi5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHZhciBkb3QxID0gYm94X3RvX3NwaGVyZS5kb3QobnMxKTtcbiAgICAgICAgICAgIHZhciBkb3QyID0gYm94X3RvX3NwaGVyZS5kb3QobnMyKTtcbiAgICAgICAgICAgIGlmKGRvdDE8aDEgJiYgZG90MT4taDEgJiYgZG90MjxoMiAmJiBkb3QyPi1oMil7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBNYXRoLmFicyhkb3QtaC1SKTtcbiAgICAgICAgICAgICAgICBpZihzaWRlX2Rpc3RhbmNlPT09bnVsbCB8fCBkaXN0IDwgc2lkZV9kaXN0YW5jZSl7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVfZGlzdGFuY2UgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICBzaWRlX2RvdDEgPSBkb3QxO1xuICAgICAgICAgICAgICAgICAgICBzaWRlX2RvdDIgPSBkb3QyO1xuICAgICAgICAgICAgICAgICAgICBzaWRlX2ggPSBoO1xuICAgICAgICAgICAgICAgICAgICBzaWRlX25zLmNvcHkobnMpO1xuICAgICAgICAgICAgICAgICAgICBzaWRlX25zMS5jb3B5KG5zMSk7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVfbnMyLmNvcHkobnMyKTtcbiAgICAgICAgICAgICAgICAgICAgc2lkZV9wZW5ldHJhdGlvbnMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYoc2lkZV9wZW5ldHJhdGlvbnMpe1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaik7XG4gICAgICAgIHNpZGVfbnMubXVsdCgtUixyLnJpKTsgLy8gU3BoZXJlIHJcbiAgICAgICAgci5uaS5jb3B5KHNpZGVfbnMpO1xuICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTsgLy8gTm9ybWFsIHNob3VsZCBiZSBvdXQgb2Ygc3BoZXJlXG4gICAgICAgIHNpZGVfbnMubXVsdChzaWRlX2gsc2lkZV9ucyk7XG4gICAgICAgIHNpZGVfbnMxLm11bHQoc2lkZV9kb3QxLHNpZGVfbnMxKTtcbiAgICAgICAgc2lkZV9ucy52YWRkKHNpZGVfbnMxLHNpZGVfbnMpO1xuICAgICAgICBzaWRlX25zMi5tdWx0KHNpZGVfZG90MixzaWRlX25zMik7XG4gICAgICAgIHNpZGVfbnMudmFkZChzaWRlX25zMixyLnJqKTtcblxuICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xuICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xuICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xuICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xuICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBjb3JuZXJzXG4gICAgdmFyIHJqID0gdjNwb29sLmdldCgpO1xuICAgIHZhciBzcGhlcmVfdG9fY29ybmVyID0gc3BoZXJlQm94X3NwaGVyZV90b19jb3JuZXI7XG4gICAgZm9yKHZhciBqPTA7IGohPT0yICYmICFmb3VuZDsgaisrKXtcbiAgICAgICAgZm9yKHZhciBrPTA7IGshPT0yICYmICFmb3VuZDsgaysrKXtcbiAgICAgICAgICAgIGZvcih2YXIgbD0wOyBsIT09MiAmJiAhZm91bmQ7IGwrKyl7XG4gICAgICAgICAgICAgICAgcmouc2V0KDAsMCwwKTtcbiAgICAgICAgICAgICAgICBpZihqKXtcbiAgICAgICAgICAgICAgICAgICAgcmoudmFkZChzaWRlc1swXSxyaik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmoudnN1YihzaWRlc1swXSxyaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGspe1xuICAgICAgICAgICAgICAgICAgICByai52YWRkKHNpZGVzWzFdLHJqKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByai52c3ViKHNpZGVzWzFdLHJqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYobCl7XG4gICAgICAgICAgICAgICAgICAgIHJqLnZhZGQoc2lkZXNbMl0scmopO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJqLnZzdWIoc2lkZXNbMl0scmopO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIGNvcm5lclxuICAgICAgICAgICAgICAgIHhqLnZhZGQocmosc3BoZXJlX3RvX2Nvcm5lcik7XG4gICAgICAgICAgICAgICAgc3BoZXJlX3RvX2Nvcm5lci52c3ViKHhpLHNwaGVyZV90b19jb3JuZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYoc3BoZXJlX3RvX2Nvcm5lci5ub3JtMigpIDwgUipSKXtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xuICAgICAgICAgICAgICAgICAgICByLnJpLmNvcHkoc3BoZXJlX3RvX2Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIHIucmkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIHIubmkuY29weShyLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgci5yaS5tdWx0KFIsci5yaSk7XG4gICAgICAgICAgICAgICAgICAgIHIucmouY29weShyaik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXNcbiAgICAgICAgICAgICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgci5yaS52c3ViKGJpLnBvc2l0aW9uLCByLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgci5yai52YWRkKHhqLCByLnJqKTtcbiAgICAgICAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHYzcG9vbC5yZWxlYXNlKHJqKTtcbiAgICByaiA9IG51bGw7XG5cbiAgICAvLyBDaGVjayBlZGdlc1xuICAgIHZhciBlZGdlVGFuZ2VudCA9IHYzcG9vbC5nZXQoKTtcbiAgICB2YXIgZWRnZUNlbnRlciA9IHYzcG9vbC5nZXQoKTtcbiAgICB2YXIgciA9IHYzcG9vbC5nZXQoKTsgLy8gciA9IGVkZ2UgY2VudGVyIHRvIHNwaGVyZSBjZW50ZXJcbiAgICB2YXIgb3J0aG9nb25hbCA9IHYzcG9vbC5nZXQoKTtcbiAgICB2YXIgZGlzdCA9IHYzcG9vbC5nZXQoKTtcbiAgICB2YXIgTnNpZGVzID0gc2lkZXMubGVuZ3RoO1xuICAgIGZvcih2YXIgaj0wOyBqIT09TnNpZGVzICYmICFmb3VuZDsgaisrKXtcbiAgICAgICAgZm9yKHZhciBrPTA7IGshPT1Oc2lkZXMgJiYgIWZvdW5kOyBrKyspe1xuICAgICAgICAgICAgaWYoaiUzICE9PSBrJTMpe1xuICAgICAgICAgICAgICAgIC8vIEdldCBlZGdlIHRhbmdlbnRcbiAgICAgICAgICAgICAgICBzaWRlc1trXS5jcm9zcyhzaWRlc1tqXSxlZGdlVGFuZ2VudCk7XG4gICAgICAgICAgICAgICAgZWRnZVRhbmdlbnQubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgc2lkZXNbal0udmFkZChzaWRlc1trXSwgZWRnZUNlbnRlcik7XG4gICAgICAgICAgICAgICAgci5jb3B5KHhpKTtcbiAgICAgICAgICAgICAgICByLnZzdWIoZWRnZUNlbnRlcixyKTtcbiAgICAgICAgICAgICAgICByLnZzdWIoeGoscik7XG4gICAgICAgICAgICAgICAgdmFyIG9ydGhvbm9ybSA9IHIuZG90KGVkZ2VUYW5nZW50KTsgLy8gZGlzdGFuY2UgZnJvbSBlZGdlIGNlbnRlciB0byBzcGhlcmUgY2VudGVyIGluIHRoZSB0YW5nZW50IGRpcmVjdGlvblxuICAgICAgICAgICAgICAgIGVkZ2VUYW5nZW50Lm11bHQob3J0aG9ub3JtLG9ydGhvZ29uYWwpOyAvLyBWZWN0b3IgZnJvbSBlZGdlIGNlbnRlciB0byBzcGhlcmUgY2VudGVyIGluIHRoZSB0YW5nZW50IGRpcmVjdGlvblxuXG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgdGhpcmQgc2lkZSBvcnRob2dvbmFsIHRvIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgdmFyIGwgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlKGw9PT1qJTMgfHwgbD09PWslMyl7XG4gICAgICAgICAgICAgICAgICAgIGwrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB2ZWMgZnJvbSBlZGdlIGNlbnRlciB0byBzcGhlcmUgcHJvamVjdGVkIHRvIHRoZSBwbGFuZSBvcnRob2dvbmFsIHRvIHRoZSBlZGdlIHRhbmdlbnRcbiAgICAgICAgICAgICAgICBkaXN0LmNvcHkoeGkpO1xuICAgICAgICAgICAgICAgIGRpc3QudnN1YihvcnRob2dvbmFsLGRpc3QpO1xuICAgICAgICAgICAgICAgIGRpc3QudnN1YihlZGdlQ2VudGVyLGRpc3QpO1xuICAgICAgICAgICAgICAgIGRpc3QudnN1Yih4aixkaXN0KTtcblxuICAgICAgICAgICAgICAgIC8vIERpc3RhbmNlcyBpbiB0YW5nZW50IGRpcmVjdGlvbiBhbmQgZGlzdGFuY2UgaW4gdGhlIHBsYW5lIG9ydGhvZ29uYWwgdG8gaXRcbiAgICAgICAgICAgICAgICB2YXIgdGRpc3QgPSBNYXRoLmFicyhvcnRob25vcm0pO1xuICAgICAgICAgICAgICAgIHZhciBuZGlzdCA9IGRpc3Qubm9ybSgpO1xuXG4gICAgICAgICAgICAgICAgaWYodGRpc3QgPCBzaWRlc1tsXS5ub3JtKCkgJiYgbmRpc3Q8Uil7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xuICAgICAgICAgICAgICAgICAgICBlZGdlQ2VudGVyLnZhZGQob3J0aG9nb25hbCxyZXMucmopOyAvLyBib3ggcmpcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJqLmNvcHkocmVzLnJqKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzdC5uZWdhdGUocmVzLm5pKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLm5pLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcy5yaS5jb3B5KHJlcy5yaik7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5yaS52YWRkKHhqLHJlcy5yaSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5yaS52c3ViKHhpLHJlcy5yaSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5yaS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLm11bHQoUixyZXMucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXG4gICAgICAgICAgICAgICAgICAgIHJlcy5yaS52YWRkKHhpLCByZXMucmkpO1xuICAgICAgICAgICAgICAgICAgICByZXMucmkudnN1YihiaS5wb3NpdGlvbiwgcmVzLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJqLnZhZGQoeGosIHJlcy5yaik7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5yai52c3ViKGJqLnBvc2l0aW9uLCByZXMucmopO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHJlcywgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHYzcG9vbC5yZWxlYXNlKGVkZ2VUYW5nZW50LGVkZ2VDZW50ZXIscixvcnRob2dvbmFsLGRpc3QpO1xufTtcblxudmFyIGNvbnZleF90b19zcGhlcmUgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF9lZGdlID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVDb252ZXhfZWRnZVVuaXQgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF9zcGhlcmVUb0Nvcm5lciA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQ29udmV4X3dvcmxkQ29ybmVyID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVDb252ZXhfd29ybGROb3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF93b3JsZFBvaW50ID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVDb252ZXhfd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVDb252ZXhfcGVuZXRyYXRpb25WZWMgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF9zcGhlcmVUb1dvcmxkUG9pbnQgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBtZXRob2Qgc3BoZXJlQ29udmV4XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST05dID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVDb252ZXggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqKXtcbiAgICB2YXIgdjNwb29sID0gdGhpcy52M3Bvb2w7XG4gICAgeGkudnN1Yih4aixjb252ZXhfdG9fc3BoZXJlKTtcbiAgICB2YXIgbm9ybWFscyA9IHNqLmZhY2VOb3JtYWxzO1xuICAgIHZhciBmYWNlcyA9IHNqLmZhY2VzO1xuICAgIHZhciB2ZXJ0cyA9IHNqLnZlcnRpY2VzO1xuICAgIHZhciBSID0gICAgIHNpLnJhZGl1cztcbiAgICB2YXIgcGVuZXRyYXRpbmdfc2lkZXMgPSBbXTtcblxuICAgIC8vIGlmKGNvbnZleF90b19zcGhlcmUubm9ybTIoKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpe1xuICAgIC8vICAgICByZXR1cm47XG4gICAgLy8gfVxuXG4gICAgLy8gQ2hlY2sgY29ybmVyc1xuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xuXG4gICAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIGNvcm5lclxuICAgICAgICB2YXIgd29ybGRDb3JuZXIgPSBzcGhlcmVDb252ZXhfd29ybGRDb3JuZXI7XG4gICAgICAgIHFqLnZtdWx0KHYsd29ybGRDb3JuZXIpO1xuICAgICAgICB4ai52YWRkKHdvcmxkQ29ybmVyLHdvcmxkQ29ybmVyKTtcbiAgICAgICAgdmFyIHNwaGVyZV90b19jb3JuZXIgPSBzcGhlcmVDb252ZXhfc3BoZXJlVG9Db3JuZXI7XG4gICAgICAgIHdvcmxkQ29ybmVyLnZzdWIoeGksIHNwaGVyZV90b19jb3JuZXIpO1xuICAgICAgICBpZihzcGhlcmVfdG9fY29ybmVyLm5vcm0yKCkgPCBSICogUil7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xuICAgICAgICAgICAgci5yaS5jb3B5KHNwaGVyZV90b19jb3JuZXIpO1xuICAgICAgICAgICAgci5yaS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgIHIubmkuY29weShyLnJpKTtcbiAgICAgICAgICAgIHIucmkubXVsdChSLHIucmkpO1xuICAgICAgICAgICAgd29ybGRDb3JuZXIudnN1Yih4aixyLnJqKTtcblxuICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxuICAgICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTtcbiAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XG5cbiAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cbiAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XG4gICAgICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgc2lkZSAocGxhbmUpIGludGVyc2VjdGlvbnNcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBmb3IodmFyIGk9MCwgbmZhY2VzPWZhY2VzLmxlbmd0aDsgaSE9PW5mYWNlcyAmJiBmb3VuZD09PWZhbHNlOyBpKyspe1xuICAgICAgICB2YXIgbm9ybWFsID0gbm9ybWFsc1tpXTtcbiAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1tpXTtcblxuICAgICAgICAvLyBHZXQgd29ybGQtdHJhbnNmb3JtZWQgbm9ybWFsIG9mIHRoZSBmYWNlXG4gICAgICAgIHZhciB3b3JsZE5vcm1hbCA9IHNwaGVyZUNvbnZleF93b3JsZE5vcm1hbDtcbiAgICAgICAgcWoudm11bHQobm9ybWFsLHdvcmxkTm9ybWFsKTtcblxuICAgICAgICAvLyBHZXQgYSB3b3JsZCB2ZXJ0ZXggZnJvbSB0aGUgZmFjZVxuICAgICAgICB2YXIgd29ybGRQb2ludCA9IHNwaGVyZUNvbnZleF93b3JsZFBvaW50O1xuICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlWzBdXSx3b3JsZFBvaW50KTtcbiAgICAgICAgd29ybGRQb2ludC52YWRkKHhqLHdvcmxkUG9pbnQpO1xuXG4gICAgICAgIC8vIEdldCBhIHBvaW50IG9uIHRoZSBzcGhlcmUsIGNsb3Nlc3QgdG8gdGhlIGZhY2Ugbm9ybWFsXG4gICAgICAgIHZhciB3b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUgPSBzcGhlcmVDb252ZXhfd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lO1xuICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KC1SLCB3b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUpO1xuICAgICAgICB4aS52YWRkKHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSwgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lKTtcblxuICAgICAgICAvLyBWZWN0b3IgZnJvbSBhIGZhY2UgcG9pbnQgdG8gdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNwaGVyZVxuICAgICAgICB2YXIgcGVuZXRyYXRpb25WZWMgPSBzcGhlcmVDb252ZXhfcGVuZXRyYXRpb25WZWM7XG4gICAgICAgIHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZS52c3ViKHdvcmxkUG9pbnQscGVuZXRyYXRpb25WZWMpO1xuXG4gICAgICAgIC8vIFRoZSBwZW5ldHJhdGlvbi4gTmVnYXRpdmUgdmFsdWUgbWVhbnMgb3ZlcmxhcC5cbiAgICAgICAgdmFyIHBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb25WZWMuZG90KHdvcmxkTm9ybWFsKTtcblxuICAgICAgICB2YXIgd29ybGRQb2ludFRvU3BoZXJlID0gc3BoZXJlQ29udmV4X3NwaGVyZVRvV29ybGRQb2ludDtcbiAgICAgICAgeGkudnN1Yih3b3JsZFBvaW50LCB3b3JsZFBvaW50VG9TcGhlcmUpO1xuXG4gICAgICAgIGlmKHBlbmV0cmF0aW9uIDwgMCAmJiB3b3JsZFBvaW50VG9TcGhlcmUuZG90KHdvcmxkTm9ybWFsKT4wKXtcbiAgICAgICAgICAgIC8vIEludGVyc2VjdHMgcGxhbmUuIE5vdyBjaGVjayBpZiB0aGUgc3BoZXJlIGlzIGluc2lkZSB0aGUgZmFjZSBwb2x5Z29uXG4gICAgICAgICAgICB2YXIgZmFjZVZlcnRzID0gW107IC8vIEZhY2UgdmVydGljZXMsIGluIHdvcmxkIGNvb3Jkc1xuICAgICAgICAgICAgZm9yKHZhciBqPTAsIE52ZXJ0cz1mYWNlLmxlbmd0aDsgaiE9PU52ZXJ0czsgaisrKXtcbiAgICAgICAgICAgICAgICB2YXIgd29ybGRWZXJ0ZXggPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICAgICAgcWoudm11bHQodmVydHNbZmFjZVtqXV0sIHdvcmxkVmVydGV4KTtcbiAgICAgICAgICAgICAgICB4ai52YWRkKHdvcmxkVmVydGV4LHdvcmxkVmVydGV4KTtcbiAgICAgICAgICAgICAgICBmYWNlVmVydHMucHVzaCh3b3JsZFZlcnRleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHBvaW50SW5Qb2x5Z29uKGZhY2VWZXJ0cyx3b3JsZE5vcm1hbCx4aSkpeyAvLyBJcyB0aGUgc3BoZXJlIGNlbnRlciBpbiB0aGUgZmFjZSBwb2x5Z29uP1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xuXG4gICAgICAgICAgICAgICAgd29ybGROb3JtYWwubXVsdCgtUiwgci5yaSk7IC8vIENvbnRhY3Qgb2Zmc2V0LCBmcm9tIHNwaGVyZSBjZW50ZXIgdG8gY29udGFjdFxuICAgICAgICAgICAgICAgIHdvcmxkTm9ybWFsLm5lZ2F0ZShyLm5pKTsgLy8gTm9ybWFsIHBvaW50aW5nIG91dCBvZiBzcGhlcmVcblxuICAgICAgICAgICAgICAgIHZhciBwZW5ldHJhdGlvblZlYzIgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICAgICAgd29ybGROb3JtYWwubXVsdCgtcGVuZXRyYXRpb24sIHBlbmV0cmF0aW9uVmVjMik7XG4gICAgICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uU3BoZXJlUG9pbnQgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICAgICAgd29ybGROb3JtYWwubXVsdCgtUiwgcGVuZXRyYXRpb25TcGhlcmVQb2ludCk7XG5cbiAgICAgICAgICAgICAgICAvL3hpLnZzdWIoeGopLnZhZGQocGVuZXRyYXRpb25TcGhlcmVQb2ludCkudmFkZChwZW5ldHJhdGlvblZlYzIgLCByLnJqKTtcbiAgICAgICAgICAgICAgICB4aS52c3ViKHhqLHIucmopO1xuICAgICAgICAgICAgICAgIHIucmoudmFkZChwZW5ldHJhdGlvblNwaGVyZVBvaW50LHIucmopO1xuICAgICAgICAgICAgICAgIHIucmoudmFkZChwZW5ldHJhdGlvblZlYzIgLCByLnJqKTtcblxuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cbiAgICAgICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xuICAgICAgICAgICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTtcbiAgICAgICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UocGVuZXRyYXRpb25WZWMyKTtcbiAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShwZW5ldHJhdGlvblNwaGVyZVBvaW50KTtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVsZWFzZSB3b3JsZCB2ZXJ0aWNlc1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaj0wLCBOZmFjZXZlcnRzPWZhY2VWZXJ0cy5sZW5ndGg7IGohPT1OZmFjZXZlcnRzOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShmYWNlVmVydHNbal0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gV2Ugb25seSBleHBlY3QgKm9uZSogZmFjZSBjb250YWN0XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVkZ2U/XG4gICAgICAgICAgICAgICAgZm9yKHZhciBqPTA7IGohPT1mYWNlLmxlbmd0aDsgaisrKXtcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdHdvIHdvcmxkIHRyYW5zZm9ybWVkIHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgICAgIHZhciB2MSA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYyID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlWyhqKzEpJWZhY2UubGVuZ3RoXV0sIHYxKTtcbiAgICAgICAgICAgICAgICAgICAgcWoudm11bHQodmVydHNbZmFjZVsoaisyKSVmYWNlLmxlbmd0aF1dLCB2Mik7XG4gICAgICAgICAgICAgICAgICAgIHhqLnZhZGQodjEsIHYxKTtcbiAgICAgICAgICAgICAgICAgICAgeGoudmFkZCh2MiwgdjIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCBlZGdlIHZlY3RvclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZSA9IHNwaGVyZUNvbnZleF9lZGdlO1xuICAgICAgICAgICAgICAgICAgICB2Mi52c3ViKHYxLGVkZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgc2FtZSB2ZWN0b3IsIGJ1dCBub3JtYWxpemVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGdlVW5pdCA9IHNwaGVyZUNvbnZleF9lZGdlVW5pdDtcbiAgICAgICAgICAgICAgICAgICAgZWRnZS51bml0KGVkZ2VVbml0KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBwIGlzIHhpIHByb2plY3RlZCBvbnRvIHRoZSBlZGdlXG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdjFfdG9feGkgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHhpLnZzdWIodjEsIHYxX3RvX3hpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvdCA9IHYxX3RvX3hpLmRvdChlZGdlVW5pdCk7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VVbml0Lm11bHQoZG90LCBwKTtcbiAgICAgICAgICAgICAgICAgICAgcC52YWRkKHYxLCBwKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGEgdmVjdG9yIGZyb20gcCB0byB0aGUgY2VudGVyIG9mIHRoZSBzcGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhpX3RvX3AgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAudnN1Yih4aSwgeGlfdG9fcCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGlzaW9uIGlmIHRoZSBlZGdlLXNwaGVyZSBkaXN0YW5jZSBpcyBsZXNzIHRoYW4gdGhlIHJhZGl1c1xuICAgICAgICAgICAgICAgICAgICAvLyBBTkQgaWYgcCBpcyBpbiBiZXR3ZWVuIHYxIGFuZCB2MlxuICAgICAgICAgICAgICAgICAgICBpZihkb3QgPiAwICYmIGRvdCpkb3Q8ZWRnZS5ub3JtMigpICYmIHhpX3RvX3Aubm9ybTIoKSA8IFIqUil7IC8vIENvbGxpc2lvbiBpZiB0aGUgZWRnZS1zcGhlcmUgZGlzdGFuY2UgaXMgbGVzcyB0aGFuIHRoZSByYWRpdXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVkZ2UgY29udGFjdCFcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLnZzdWIoeGosci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHAudnN1Yih4aSxyLm5pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHIubmkubXVsdChSLHIucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICAgICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxuICAgICAgICAgICAgICAgICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaj0wLCBOZmFjZXZlcnRzPWZhY2VWZXJ0cy5sZW5ndGg7IGohPT1OZmFjZXZlcnRzOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoeGlfdG9fcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2MV90b194aSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxKTtcbiAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjIpO1xuICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShwKTtcbiAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoeGlfdG9fcCk7XG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxX3RvX3hpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXNcbiAgICAgICAgICAgIGZvcih2YXIgaj0wLCBOZmFjZXZlcnRzPWZhY2VWZXJ0cy5sZW5ndGg7IGohPT1OZmFjZXZlcnRzOyBqKyspe1xuICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgcGxhbmVCb3hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBwbGFuZV90b19jb3JuZXIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBtZXRob2QgcGxhbmVCb3hcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHJlc3VsdFxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLkJPWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQm94ID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmope1xuICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNqLm1hdGVyaWFsO1xuICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNqLmNvbGxpc2lvblJlc3BvbnNlO1xuICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5pZCA9IHNqLmlkO1xuICAgIHRoaXMucGxhbmVDb252ZXgoc2ksc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLHhpLHhqLHFpLHFqLGJpLGJqLHNpLHNqKTtcbn07XG5cbnZhciBwbGFuZUNvbnZleF92ID0gbmV3IFZlYzMoKTtcbnZhciBwbGFuZUNvbnZleF9ub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIHBsYW5lQ29udmV4X3JlbHBvcyA9IG5ldyBWZWMzKCk7XG52YXIgcGxhbmVDb252ZXhfcHJvamVjdGVkID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHBsYW5lQ29udmV4XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQ29udmV4ID0gZnVuY3Rpb24oXG4gICAgcGxhbmVTaGFwZSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBwbGFuZVBvc2l0aW9uLFxuICAgIGNvbnZleFBvc2l0aW9uLFxuICAgIHBsYW5lUXVhdCxcbiAgICBjb252ZXhRdWF0LFxuICAgIHBsYW5lQm9keSxcbiAgICBjb252ZXhCb2R5LFxuICAgIHNpLFxuICAgIHNqXG4pe1xuICAgIC8vIFNpbXBseSByZXR1cm4gdGhlIHBvaW50cyBiZWhpbmQgdGhlIHBsYW5lLlxuICAgIHZhciB3b3JsZFZlcnRleCA9IHBsYW5lQ29udmV4X3YsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gcGxhbmVDb252ZXhfbm9ybWFsO1xuICAgIHdvcmxkTm9ybWFsLnNldCgwLDAsMSk7XG4gICAgcGxhbmVRdWF0LnZtdWx0KHdvcmxkTm9ybWFsLHdvcmxkTm9ybWFsKTsgLy8gVHVybiBub3JtYWwgYWNjb3JkaW5nIHRvIHBsYW5lIG9yaWVudGF0aW9uXG5cbiAgICB2YXIgbnVtQ29udGFjdHMgPSAwO1xuICAgIHZhciByZWxwb3MgPSBwbGFuZUNvbnZleF9yZWxwb3M7XG4gICAgZm9yKHZhciBpID0gMDsgaSAhPT0gY29udmV4U2hhcGUudmVydGljZXMubGVuZ3RoOyBpKyspe1xuXG4gICAgICAgIC8vIEdldCB3b3JsZCBjb252ZXggdmVydGV4XG4gICAgICAgIHdvcmxkVmVydGV4LmNvcHkoY29udmV4U2hhcGUudmVydGljZXNbaV0pO1xuICAgICAgICBjb252ZXhRdWF0LnZtdWx0KHdvcmxkVmVydGV4LCB3b3JsZFZlcnRleCk7XG4gICAgICAgIGNvbnZleFBvc2l0aW9uLnZhZGQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4KTtcbiAgICAgICAgd29ybGRWZXJ0ZXgudnN1YihwbGFuZVBvc2l0aW9uLCByZWxwb3MpO1xuXG4gICAgICAgIHZhciBkb3QgPSB3b3JsZE5vcm1hbC5kb3QocmVscG9zKTtcbiAgICAgICAgaWYoZG90IDw9IDAuMCl7XG5cbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LCBjb252ZXhCb2R5LCBwbGFuZVNoYXBlLCBjb252ZXhTaGFwZSwgc2ksIHNqKTtcblxuICAgICAgICAgICAgLy8gR2V0IHZlcnRleCBwb3NpdGlvbiBwcm9qZWN0ZWQgb24gcGxhbmVcbiAgICAgICAgICAgIHZhciBwcm9qZWN0ZWQgPSBwbGFuZUNvbnZleF9wcm9qZWN0ZWQ7XG4gICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KHdvcmxkTm9ybWFsLmRvdChyZWxwb3MpLHByb2plY3RlZCk7XG4gICAgICAgICAgICB3b3JsZFZlcnRleC52c3ViKHByb2plY3RlZCwgcHJvamVjdGVkKTtcbiAgICAgICAgICAgIHByb2plY3RlZC52c3ViKHBsYW5lUG9zaXRpb24sIHIucmkpOyAvLyBGcm9tIHBsYW5lIHRvIHZlcnRleCBwcm9qZWN0ZWQgb24gcGxhbmVcblxuICAgICAgICAgICAgci5uaS5jb3B5KHdvcmxkTm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWwgaXMgdGhlIHBsYW5lIG5vcm1hbCBvdXQgZnJvbSBwbGFuZVxuXG4gICAgICAgICAgICAvLyByaiBpcyBub3cganVzdCB0aGUgdmVjdG9yIGZyb20gdGhlIGNvbnZleCBjZW50ZXIgdG8gdGhlIHZlcnRleFxuICAgICAgICAgICAgd29ybGRWZXJ0ZXgudnN1Yihjb252ZXhQb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgIC8vIE1ha2UgaXQgcmVsYXRpdmUgdG8gdGhlIGJvZHlcbiAgICAgICAgICAgIHIucmkudmFkZChwbGFuZVBvc2l0aW9uLCByLnJpKTtcbiAgICAgICAgICAgIHIucmkudnN1YihwbGFuZUJvZHkucG9zaXRpb24sIHIucmkpO1xuICAgICAgICAgICAgci5yai52YWRkKGNvbnZleFBvc2l0aW9uLCByLnJqKTtcbiAgICAgICAgICAgIHIucmoudnN1Yihjb252ZXhCb2R5LnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgIG51bUNvbnRhY3RzKys7XG4gICAgICAgICAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiAmJiBudW1Db250YWN0cyl7XG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cyk7XG4gICAgfVxufTtcblxudmFyIGNvbnZleENvbnZleF9zZXBBeGlzID0gbmV3IFZlYzMoKTtcbnZhciBjb252ZXhDb252ZXhfcSA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjb252ZXhDb252ZXhcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleENvbnZleCA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHJzaSxyc2osZmFjZUxpc3RBLGZhY2VMaXN0Qil7XG4gICAgdmFyIHNlcEF4aXMgPSBjb252ZXhDb252ZXhfc2VwQXhpcztcblxuICAgIGlmKHhpLmRpc3RhbmNlVG8oeGopID4gc2kuYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzai5ib3VuZGluZ1NwaGVyZVJhZGl1cyl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZihzaS5maW5kU2VwYXJhdGluZ0F4aXMoc2oseGkscWkseGoscWosc2VwQXhpcyxmYWNlTGlzdEEsZmFjZUxpc3RCKSl7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgdmFyIHEgPSBjb252ZXhDb252ZXhfcTtcbiAgICAgICAgc2kuY2xpcEFnYWluc3RIdWxsKHhpLHFpLHNqLHhqLHFqLHNlcEF4aXMsLTEwMCwxMDAscmVzKTtcbiAgICAgICAgdmFyIG51bUNvbnRhY3RzID0gMDtcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiAhPT0gcmVzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaiksXG4gICAgICAgICAgICAgICAgcmkgPSByLnJpLFxuICAgICAgICAgICAgICAgIHJqID0gci5yajtcbiAgICAgICAgICAgIHNlcEF4aXMubmVnYXRlKHIubmkpO1xuICAgICAgICAgICAgcmVzW2pdLm5vcm1hbC5uZWdhdGUocSk7XG4gICAgICAgICAgICBxLm11bHQocmVzW2pdLmRlcHRoLCBxKTtcbiAgICAgICAgICAgIHJlc1tqXS5wb2ludC52YWRkKHEsIHJpKTtcbiAgICAgICAgICAgIHJqLmNvcHkocmVzW2pdLnBvaW50KTtcblxuICAgICAgICAgICAgLy8gQ29udGFjdCBwb2ludHMgYXJlIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBUcmFuc2Zvcm0gYmFjayB0byByZWxhdGl2ZVxuICAgICAgICAgICAgcmkudnN1Yih4aSxyaSk7XG4gICAgICAgICAgICByai52c3ViKHhqLHJqKTtcblxuICAgICAgICAgICAgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXNcbiAgICAgICAgICAgIHJpLnZhZGQoeGksIHJpKTtcbiAgICAgICAgICAgIHJpLnZzdWIoYmkucG9zaXRpb24sIHJpKTtcbiAgICAgICAgICAgIHJqLnZhZGQoeGosIHJqKTtcbiAgICAgICAgICAgIHJqLnZzdWIoYmoucG9zaXRpb24sIHJqKTtcblxuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgIG51bUNvbnRhY3RzKys7XG4gICAgICAgICAgICBpZighdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbil7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gJiYgbnVtQ29udGFjdHMpe1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkZyb21BdmVyYWdlKG51bUNvbnRhY3RzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyoqXG4gKiBAbWV0aG9kIGNvbnZleFRyaW1lc2hcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHJlc3VsdFxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKi9cbi8vIE5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OIHwgU2hhcGUudHlwZXMuVFJJTUVTSF0gPVxuLy8gTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleFRyaW1lc2ggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqLGZhY2VMaXN0QSxmYWNlTGlzdEIpe1xuLy8gICAgIHZhciBzZXBBeGlzID0gY29udmV4Q29udmV4X3NlcEF4aXM7XG5cbi8vICAgICBpZih4aS5kaXN0YW5jZVRvKHhqKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpe1xuLy8gICAgICAgICByZXR1cm47XG4vLyAgICAgfVxuXG4vLyAgICAgLy8gQ29uc3RydWN0IGEgdGVtcCBodWxsIGZvciBlYWNoIHRyaWFuZ2xlXG4vLyAgICAgdmFyIGh1bGxCID0gbmV3IENvbnZleFBvbHloZWRyb24oKTtcblxuLy8gICAgIGh1bGxCLmZhY2VzID0gW1swLDEsMl1dO1xuLy8gICAgIHZhciB2YSA9IG5ldyBWZWMzKCk7XG4vLyAgICAgdmFyIHZiID0gbmV3IFZlYzMoKTtcbi8vICAgICB2YXIgdmMgPSBuZXcgVmVjMygpO1xuLy8gICAgIGh1bGxCLnZlcnRpY2VzID0gW1xuLy8gICAgICAgICB2YSxcbi8vICAgICAgICAgdmIsXG4vLyAgICAgICAgIHZjXG4vLyAgICAgXTtcblxuLy8gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2ouaW5kaWNlcy5sZW5ndGggLyAzOyBpKyspIHtcblxuLy8gICAgICAgICB2YXIgdHJpYW5nbGVOb3JtYWwgPSBuZXcgVmVjMygpO1xuLy8gICAgICAgICBzai5nZXROb3JtYWwoaSwgdHJpYW5nbGVOb3JtYWwpO1xuLy8gICAgICAgICBodWxsQi5mYWNlTm9ybWFscyA9IFt0cmlhbmdsZU5vcm1hbF07XG5cbi8vICAgICAgICAgc2ouZ2V0VHJpYW5nbGVWZXJ0aWNlcyhpLCB2YSwgdmIsIHZjKTtcblxuLy8gICAgICAgICB2YXIgZCA9IHNpLnRlc3RTZXBBeGlzKHRyaWFuZ2xlTm9ybWFsLCBodWxsQiwgeGksIHFpLCB4aiwgcWopO1xuLy8gICAgICAgICBpZighZCl7XG4vLyAgICAgICAgICAgICB0cmlhbmdsZU5vcm1hbC5zY2FsZSgtMSwgdHJpYW5nbGVOb3JtYWwpO1xuLy8gICAgICAgICAgICAgZCA9IHNpLnRlc3RTZXBBeGlzKHRyaWFuZ2xlTm9ybWFsLCBodWxsQiwgeGksIHFpLCB4aiwgcWopO1xuXG4vLyAgICAgICAgICAgICBpZighZCl7XG4vLyAgICAgICAgICAgICAgICAgY29udGludWU7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH1cblxuLy8gICAgICAgICB2YXIgcmVzID0gW107XG4vLyAgICAgICAgIHZhciBxID0gY29udmV4Q29udmV4X3E7XG4vLyAgICAgICAgIHNpLmNsaXBBZ2FpbnN0SHVsbCh4aSxxaSxodWxsQix4aixxaix0cmlhbmdsZU5vcm1hbCwtMTAwLDEwMCxyZXMpO1xuLy8gICAgICAgICBmb3IodmFyIGogPSAwOyBqICE9PSByZXMubGVuZ3RoOyBqKyspe1xuLy8gICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKSxcbi8vICAgICAgICAgICAgICAgICByaSA9IHIucmksXG4vLyAgICAgICAgICAgICAgICAgcmogPSByLnJqO1xuLy8gICAgICAgICAgICAgci5uaS5jb3B5KHRyaWFuZ2xlTm9ybWFsKTtcbi8vICAgICAgICAgICAgIHIubmkubmVnYXRlKHIubmkpO1xuLy8gICAgICAgICAgICAgcmVzW2pdLm5vcm1hbC5uZWdhdGUocSk7XG4vLyAgICAgICAgICAgICBxLm11bHQocmVzW2pdLmRlcHRoLCBxKTtcbi8vICAgICAgICAgICAgIHJlc1tqXS5wb2ludC52YWRkKHEsIHJpKTtcbi8vICAgICAgICAgICAgIHJqLmNvcHkocmVzW2pdLnBvaW50KTtcblxuLy8gICAgICAgICAgICAgLy8gQ29udGFjdCBwb2ludHMgYXJlIGluIHdvcmxkIGNvb3JkaW5hdGVzLiBUcmFuc2Zvcm0gYmFjayB0byByZWxhdGl2ZVxuLy8gICAgICAgICAgICAgcmkudnN1Yih4aSxyaSk7XG4vLyAgICAgICAgICAgICByai52c3ViKHhqLHJqKTtcblxuLy8gICAgICAgICAgICAgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXNcbi8vICAgICAgICAgICAgIHJpLnZhZGQoeGksIHJpKTtcbi8vICAgICAgICAgICAgIHJpLnZzdWIoYmkucG9zaXRpb24sIHJpKTtcbi8vICAgICAgICAgICAgIHJqLnZhZGQoeGosIHJqKTtcbi8vICAgICAgICAgICAgIHJqLnZzdWIoYmoucG9zaXRpb24sIHJqKTtcblxuLy8gICAgICAgICAgICAgcmVzdWx0LnB1c2gocik7XG4vLyAgICAgICAgIH1cbi8vICAgICB9XG4vLyB9O1xuXG52YXIgcGFydGljbGVQbGFuZV9ub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIHBhcnRpY2xlUGxhbmVfcmVscG9zID0gbmV3IFZlYzMoKTtcbnZhciBwYXJ0aWNsZVBsYW5lX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBwYXJ0aWNsZVBsYW5lXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICByZXN1bHRcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuUExBTkUgfCBTaGFwZS50eXBlcy5QQVJUSUNMRV0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lUGFydGljbGUgPSBmdW5jdGlvbihzaixzaSx4aix4aSxxaixxaSxiaixiaSxyc2kscnNqKXtcbiAgICB2YXIgbm9ybWFsID0gcGFydGljbGVQbGFuZV9ub3JtYWw7XG4gICAgbm9ybWFsLnNldCgwLDAsMSk7XG4gICAgYmoucXVhdGVybmlvbi52bXVsdChub3JtYWwsbm9ybWFsKTsgLy8gVHVybiBub3JtYWwgYWNjb3JkaW5nIHRvIHBsYW5lIG9yaWVudGF0aW9uXG4gICAgdmFyIHJlbHBvcyA9IHBhcnRpY2xlUGxhbmVfcmVscG9zO1xuICAgIHhpLnZzdWIoYmoucG9zaXRpb24scmVscG9zKTtcbiAgICB2YXIgZG90ID0gbm9ybWFsLmRvdChyZWxwb3MpO1xuICAgIGlmKGRvdCA8PSAwLjApe1xuICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opO1xuICAgICAgICByLm5pLmNvcHkobm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWwgaXMgdGhlIHBsYW5lIG5vcm1hbFxuICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTtcbiAgICAgICAgci5yaS5zZXQoMCwwLDApOyAvLyBDZW50ZXIgb2YgcGFydGljbGVcblxuICAgICAgICAvLyBHZXQgcGFydGljbGUgcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lXG4gICAgICAgIHZhciBwcm9qZWN0ZWQgPSBwYXJ0aWNsZVBsYW5lX3Byb2plY3RlZDtcbiAgICAgICAgbm9ybWFsLm11bHQobm9ybWFsLmRvdCh4aSkscHJvamVjdGVkKTtcbiAgICAgICAgeGkudnN1Yihwcm9qZWN0ZWQscHJvamVjdGVkKTtcbiAgICAgICAgLy9wcm9qZWN0ZWQudmFkZChiai5wb3NpdGlvbixwcm9qZWN0ZWQpO1xuXG4gICAgICAgIC8vIHJqIGlzIG5vdyB0aGUgcHJvamVjdGVkIHdvcmxkIHBvc2l0aW9uIG1pbnVzIHBsYW5lIHBvc2l0aW9uXG4gICAgICAgIHIucmouY29weShwcm9qZWN0ZWQpO1xuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgfVxufTtcblxudmFyIHBhcnRpY2xlU3BoZXJlX25vcm1hbCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBwYXJ0aWNsZVNwaGVyZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuU1BIRVJFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlUGFydGljbGUgPSBmdW5jdGlvbihzaixzaSx4aix4aSxxaixxaSxiaixiaSxyc2kscnNqKXtcbiAgICAvLyBUaGUgbm9ybWFsIGlzIHRoZSB1bml0IHZlY3RvciBmcm9tIHNwaGVyZSBjZW50ZXIgdG8gcGFydGljbGUgY2VudGVyXG4gICAgdmFyIG5vcm1hbCA9IHBhcnRpY2xlU3BoZXJlX25vcm1hbDtcbiAgICBub3JtYWwuc2V0KDAsMCwxKTtcbiAgICB4aS52c3ViKHhqLG5vcm1hbCk7XG4gICAgdmFyIGxlbmd0aFNxdWFyZWQgPSBub3JtYWwubm9ybTIoKTtcblxuICAgIGlmKGxlbmd0aFNxdWFyZWQgPD0gc2oucmFkaXVzICogc2oucmFkaXVzKXtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaixyc2kscnNqKTtcbiAgICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICByLnJqLmNvcHkobm9ybWFsKTtcbiAgICAgICAgci5yai5tdWx0KHNqLnJhZGl1cyxyLnJqKTtcbiAgICAgICAgci5uaS5jb3B5KG5vcm1hbCk7IC8vIENvbnRhY3Qgbm9ybWFsXG4gICAgICAgIHIubmkubmVnYXRlKHIubmkpO1xuICAgICAgICByLnJpLnNldCgwLDAsMCk7IC8vIENlbnRlciBvZiBwYXJ0aWNsZVxuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgfVxufTtcblxuLy8gV0lQXG52YXIgY3FqID0gbmV3IFF1YXRlcm5pb24oKTtcbnZhciBjb252ZXhQYXJ0aWNsZV9sb2NhbCA9IG5ldyBWZWMzKCk7XG52YXIgY29udmV4UGFydGljbGVfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBjb252ZXhQYXJ0aWNsZV9wZW5ldHJhdGVkRmFjZU5vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSA9IG5ldyBWZWMzKCk7XG52YXIgY29udmV4UGFydGljbGVfd29ybGRQZW5ldHJhdGlvblZlYyA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjb252ZXhQYXJ0aWNsZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleFBhcnRpY2xlID0gZnVuY3Rpb24oc2osc2kseGoseGkscWoscWksYmosYmkscnNpLHJzail7XG4gICAgdmFyIHBlbmV0cmF0ZWRGYWNlSW5kZXggPSAtMTtcbiAgICB2YXIgcGVuZXRyYXRlZEZhY2VOb3JtYWwgPSBjb252ZXhQYXJ0aWNsZV9wZW5ldHJhdGVkRmFjZU5vcm1hbDtcbiAgICB2YXIgd29ybGRQZW5ldHJhdGlvblZlYyA9IGNvbnZleFBhcnRpY2xlX3dvcmxkUGVuZXRyYXRpb25WZWM7XG4gICAgdmFyIG1pblBlbmV0cmF0aW9uID0gbnVsbDtcbiAgICB2YXIgbnVtRGV0ZWN0ZWRGYWNlcyA9IDA7XG5cbiAgICAvLyBDb252ZXJ0IHBhcnRpY2xlIHBvc2l0aW9uIHhpIHRvIGxvY2FsIGNvb3JkcyBpbiB0aGUgY29udmV4XG4gICAgdmFyIGxvY2FsID0gY29udmV4UGFydGljbGVfbG9jYWw7XG4gICAgbG9jYWwuY29weSh4aSk7XG4gICAgbG9jYWwudnN1Yih4aixsb2NhbCk7IC8vIENvbnZlcnQgcG9zaXRpb24gdG8gcmVsYXRpdmUgdGhlIGNvbnZleCBvcmlnaW5cbiAgICBxai5jb25qdWdhdGUoY3FqKTtcbiAgICBjcWoudm11bHQobG9jYWwsbG9jYWwpO1xuXG4gICAgaWYoc2oucG9pbnRJc0luc2lkZShsb2NhbCkpe1xuXG4gICAgICAgIGlmKHNqLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBzai5jb21wdXRlV29ybGRWZXJ0aWNlcyh4aixxaik7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2oud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIHNqLmNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzKHFqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBlYWNoIHdvcmxkIHBvbHlnb24gaW4gdGhlIHBvbHloZWRyYVxuICAgICAgICBmb3IodmFyIGk9MCxuZmFjZXM9c2ouZmFjZXMubGVuZ3RoOyBpIT09bmZhY2VzOyBpKyspe1xuXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3Qgd29ybGQgZmFjZSB2ZXJ0aWNlc1xuICAgICAgICAgICAgdmFyIHZlcnRzID0gWyBzai53b3JsZFZlcnRpY2VzWyBzai5mYWNlc1tpXVswXSBdIF07XG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gc2oud29ybGRGYWNlTm9ybWFsc1tpXTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaG93IG11Y2ggdGhlIHBhcnRpY2xlIHBlbmV0cmF0ZXMgdGhlIHBvbHlnb24gcGxhbmUuXG4gICAgICAgICAgICB4aS52c3ViKHZlcnRzWzBdLGNvbnZleFBhcnRpY2xlX3ZlcnRleFRvUGFydGljbGUpO1xuICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uID0gLW5vcm1hbC5kb3QoY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSk7XG4gICAgICAgICAgICBpZihtaW5QZW5ldHJhdGlvbj09PW51bGwgfHwgTWF0aC5hYnMocGVuZXRyYXRpb24pPE1hdGguYWJzKG1pblBlbmV0cmF0aW9uKSl7XG4gICAgICAgICAgICAgICAgbWluUGVuZXRyYXRpb24gPSBwZW5ldHJhdGlvbjtcbiAgICAgICAgICAgICAgICBwZW5ldHJhdGVkRmFjZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5jb3B5KG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgbnVtRGV0ZWN0ZWRGYWNlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYocGVuZXRyYXRlZEZhY2VJbmRleCE9PS0xKXtcbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhY3RcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaik7XG4gICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5tdWx0KG1pblBlbmV0cmF0aW9uLCB3b3JsZFBlbmV0cmF0aW9uVmVjKTtcblxuICAgICAgICAgICAgLy8gcmogaXMgdGhlIHBhcnRpY2xlIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgZmFjZVxuICAgICAgICAgICAgd29ybGRQZW5ldHJhdGlvblZlYy52YWRkKHhpLHdvcmxkUGVuZXRyYXRpb25WZWMpO1xuICAgICAgICAgICAgd29ybGRQZW5ldHJhdGlvblZlYy52c3ViKHhqLHdvcmxkUGVuZXRyYXRpb25WZWMpO1xuICAgICAgICAgICAgci5yai5jb3B5KHdvcmxkUGVuZXRyYXRpb25WZWMpO1xuICAgICAgICAgICAgLy92YXIgcHJvamVjdGVkVG9GYWNlID0geGkudnN1Yih4aikudmFkZCh3b3JsZFBlbmV0cmF0aW9uVmVjKTtcbiAgICAgICAgICAgIC8vcHJvamVjdGVkVG9GYWNlLmNvcHkoci5yaik7XG5cbiAgICAgICAgICAgIC8vcWoudm11bHQoci5yaixyLnJqKTtcbiAgICAgICAgICAgIHBlbmV0cmF0ZWRGYWNlTm9ybWFsLm5lZ2F0ZSggci5uaSApOyAvLyBDb250YWN0IG5vcm1hbFxuICAgICAgICAgICAgci5yaS5zZXQoMCwwLDApOyAvLyBDZW50ZXIgb2YgcGFydGljbGVcblxuICAgICAgICAgICAgdmFyIHJpID0gci5yaSxcbiAgICAgICAgICAgICAgICByaiA9IHIucmo7XG5cbiAgICAgICAgICAgIC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXG4gICAgICAgICAgICByaS52YWRkKHhpLCByaSk7XG4gICAgICAgICAgICByaS52c3ViKGJpLnBvc2l0aW9uLCByaSk7XG4gICAgICAgICAgICByai52YWRkKHhqLCByaik7XG4gICAgICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XG5cbiAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJQb2ludCBmb3VuZCBpbnNpZGUgY29udmV4LCBidXQgZGlkIG5vdCBmaW5kIHBlbmV0cmF0aW5nIGZhY2UhXCIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLkJPWCB8IFNoYXBlLnR5cGVzLkhFSUdIVEZJRUxEXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuYm94SGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiAoc2ksc2oseGkseGoscWkscWosYmksYmope1xuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNpLm1hdGVyaWFsO1xuICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNpLmNvbGxpc2lvblJlc3BvbnNlO1xuICAgIHRoaXMuY29udmV4SGVpZ2h0ZmllbGQoc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLHNqLHhpLHhqLHFpLHFqLGJpLGJqLHNpLHNqKTtcbn07XG5cbnZhciBjb252ZXhIZWlnaHRmaWVsZF90bXAxID0gbmV3IFZlYzMoKTtcbnZhciBjb252ZXhIZWlnaHRmaWVsZF90bXAyID0gbmV3IFZlYzMoKTtcbnZhciBjb252ZXhIZWlnaHRmaWVsZF9mYWNlTGlzdCA9IFswXTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbnZleEhlaWdodGZpZWxkXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTERdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uIChcbiAgICBjb252ZXhTaGFwZSxcbiAgICBoZlNoYXBlLFxuICAgIGNvbnZleFBvcyxcbiAgICBoZlBvcyxcbiAgICBjb252ZXhRdWF0LFxuICAgIGhmUXVhdCxcbiAgICBjb252ZXhCb2R5LFxuICAgIGhmQm9keVxuKXtcbiAgICB2YXIgZGF0YSA9IGhmU2hhcGUuZGF0YSxcbiAgICAgICAgdyA9IGhmU2hhcGUuZWxlbWVudFNpemUsXG4gICAgICAgIHJhZGl1cyA9IGNvbnZleFNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzLFxuICAgICAgICB3b3JsZFBpbGxhck9mZnNldCA9IGNvbnZleEhlaWdodGZpZWxkX3RtcDIsXG4gICAgICAgIGZhY2VMaXN0ID0gY29udmV4SGVpZ2h0ZmllbGRfZmFjZUxpc3Q7XG5cbiAgICAvLyBHZXQgc3BoZXJlIHBvc2l0aW9uIHRvIGhlaWdodGZpZWxkIGxvY2FsIVxuICAgIHZhciBsb2NhbENvbnZleFBvcyA9IGNvbnZleEhlaWdodGZpZWxkX3RtcDE7XG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKGhmUG9zLCBoZlF1YXQsIGNvbnZleFBvcywgbG9jYWxDb252ZXhQb3MpO1xuXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIGlNaW5YID0gTWF0aC5mbG9vcigobG9jYWxDb252ZXhQb3MueCAtIHJhZGl1cykgLyB3KSAtIDEsXG4gICAgICAgIGlNYXhYID0gTWF0aC5jZWlsKChsb2NhbENvbnZleFBvcy54ICsgcmFkaXVzKSAvIHcpICsgMSxcbiAgICAgICAgaU1pblkgPSBNYXRoLmZsb29yKChsb2NhbENvbnZleFBvcy55IC0gcmFkaXVzKSAvIHcpIC0gMSxcbiAgICAgICAgaU1heFkgPSBNYXRoLmNlaWwoKGxvY2FsQ29udmV4UG9zLnkgKyByYWRpdXMpIC8gdykgKyAxO1xuXG4gICAgLy8gQmFpbCBvdXQgaWYgd2UgYXJlIG91dCBvZiB0aGUgdGVycmFpblxuICAgIGlmKGlNYXhYIDwgMCB8fCBpTWF4WSA8IDAgfHwgaU1pblggPiBkYXRhLmxlbmd0aCB8fCBpTWluWSA+IGRhdGFbMF0ubGVuZ3RoKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzXG4gICAgaWYoaU1pblggPCAwKXsgaU1pblggPSAwOyB9XG4gICAgaWYoaU1heFggPCAwKXsgaU1heFggPSAwOyB9XG4gICAgaWYoaU1pblkgPCAwKXsgaU1pblkgPSAwOyB9XG4gICAgaWYoaU1heFkgPCAwKXsgaU1heFkgPSAwOyB9XG4gICAgaWYoaU1pblggPj0gZGF0YS5sZW5ndGgpeyBpTWluWCA9IGRhdGEubGVuZ3RoIC0gMTsgfVxuICAgIGlmKGlNYXhYID49IGRhdGEubGVuZ3RoKXsgaU1heFggPSBkYXRhLmxlbmd0aCAtIDE7IH1cbiAgICBpZihpTWF4WSA+PSBkYXRhWzBdLmxlbmd0aCl7IGlNYXhZID0gZGF0YVswXS5sZW5ndGggLSAxOyB9XG4gICAgaWYoaU1pblkgPj0gZGF0YVswXS5sZW5ndGgpeyBpTWluWSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsgfVxuXG4gICAgdmFyIG1pbk1heCA9IFtdO1xuICAgIGhmU2hhcGUuZ2V0UmVjdE1pbk1heChpTWluWCwgaU1pblksIGlNYXhYLCBpTWF4WSwgbWluTWF4KTtcbiAgICB2YXIgbWluID0gbWluTWF4WzBdO1xuICAgIHZhciBtYXggPSBtaW5NYXhbMV07XG5cbiAgICAvLyBCYWlsIG91dCBpZiB3ZSdyZSBjYW50IHRvdWNoIHRoZSBib3VuZGluZyBoZWlnaHQgYm94XG4gICAgaWYobG9jYWxDb252ZXhQb3MueiAtIHJhZGl1cyA+IG1heCB8fCBsb2NhbENvbnZleFBvcy56ICsgcmFkaXVzIDwgbWluKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvcih2YXIgaSA9IGlNaW5YOyBpIDwgaU1heFg7IGkrKyl7XG4gICAgICAgIGZvcih2YXIgaiA9IGlNaW5ZOyBqIDwgaU1heFk7IGorKyl7XG5cbiAgICAgICAgICAgIC8vIExvd2VyIHRyaWFuZ2xlXG4gICAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGNvbnZleFBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnZleENvbnZleChjb252ZXhTaGFwZSwgaGZTaGFwZS5waWxsYXJDb252ZXgsIGNvbnZleFBvcywgd29ybGRQaWxsYXJPZmZzZXQsIGNvbnZleFF1YXQsIGhmUXVhdCwgY29udmV4Qm9keSwgaGZCb2R5LCBudWxsLCBudWxsLCBmYWNlTGlzdCwgbnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwcGVyIHRyaWFuZ2xlXG4gICAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIHRydWUpO1xuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XG4gICAgICAgICAgICBpZiAoY29udmV4UG9zLmRpc3RhbmNlVG8od29ybGRQaWxsYXJPZmZzZXQpIDwgaGZTaGFwZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBjb252ZXhTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udmV4Q29udmV4KGNvbnZleFNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgY29udmV4UG9zLCB3b3JsZFBpbGxhck9mZnNldCwgY29udmV4UXVhdCwgaGZRdWF0LCBjb252ZXhCb2R5LCBoZkJvZHksIG51bGwsIG51bGwsIGZhY2VMaXN0LCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBzcGhlcmVIZWlnaHRmaWVsZF90bXAxID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVIZWlnaHRmaWVsZF90bXAyID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHNwaGVyZUhlaWdodGZpZWxkXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5IRUlHSFRGSUVMRF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZUhlaWdodGZpZWxkID0gZnVuY3Rpb24gKFxuICAgIHNwaGVyZVNoYXBlLFxuICAgIGhmU2hhcGUsXG4gICAgc3BoZXJlUG9zLFxuICAgIGhmUG9zLFxuICAgIHNwaGVyZVF1YXQsXG4gICAgaGZRdWF0LFxuICAgIHNwaGVyZUJvZHksXG4gICAgaGZCb2R5XG4pe1xuICAgIHZhciBkYXRhID0gaGZTaGFwZS5kYXRhLFxuICAgICAgICByYWRpdXMgPSBzcGhlcmVTaGFwZS5yYWRpdXMsXG4gICAgICAgIHcgPSBoZlNoYXBlLmVsZW1lbnRTaXplLFxuICAgICAgICB3b3JsZFBpbGxhck9mZnNldCA9IHNwaGVyZUhlaWdodGZpZWxkX3RtcDI7XG5cbiAgICAvLyBHZXQgc3BoZXJlIHBvc2l0aW9uIHRvIGhlaWdodGZpZWxkIGxvY2FsIVxuICAgIHZhciBsb2NhbFNwaGVyZVBvcyA9IHNwaGVyZUhlaWdodGZpZWxkX3RtcDE7XG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKGhmUG9zLCBoZlF1YXQsIHNwaGVyZVBvcywgbG9jYWxTcGhlcmVQb3MpO1xuXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIGlNaW5YID0gTWF0aC5mbG9vcigobG9jYWxTcGhlcmVQb3MueCAtIHJhZGl1cykgLyB3KSAtIDEsXG4gICAgICAgIGlNYXhYID0gTWF0aC5jZWlsKChsb2NhbFNwaGVyZVBvcy54ICsgcmFkaXVzKSAvIHcpICsgMSxcbiAgICAgICAgaU1pblkgPSBNYXRoLmZsb29yKChsb2NhbFNwaGVyZVBvcy55IC0gcmFkaXVzKSAvIHcpIC0gMSxcbiAgICAgICAgaU1heFkgPSBNYXRoLmNlaWwoKGxvY2FsU3BoZXJlUG9zLnkgKyByYWRpdXMpIC8gdykgKyAxO1xuXG4gICAgLy8gQmFpbCBvdXQgaWYgd2UgYXJlIG91dCBvZiB0aGUgdGVycmFpblxuICAgIGlmKGlNYXhYIDwgMCB8fCBpTWF4WSA8IDAgfHwgaU1pblggPiBkYXRhLmxlbmd0aCB8fCBpTWF4WSA+IGRhdGFbMF0ubGVuZ3RoKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzXG4gICAgaWYoaU1pblggPCAwKXsgaU1pblggPSAwOyB9XG4gICAgaWYoaU1heFggPCAwKXsgaU1heFggPSAwOyB9XG4gICAgaWYoaU1pblkgPCAwKXsgaU1pblkgPSAwOyB9XG4gICAgaWYoaU1heFkgPCAwKXsgaU1heFkgPSAwOyB9XG4gICAgaWYoaU1pblggPj0gZGF0YS5sZW5ndGgpeyBpTWluWCA9IGRhdGEubGVuZ3RoIC0gMTsgfVxuICAgIGlmKGlNYXhYID49IGRhdGEubGVuZ3RoKXsgaU1heFggPSBkYXRhLmxlbmd0aCAtIDE7IH1cbiAgICBpZihpTWF4WSA+PSBkYXRhWzBdLmxlbmd0aCl7IGlNYXhZID0gZGF0YVswXS5sZW5ndGggLSAxOyB9XG4gICAgaWYoaU1pblkgPj0gZGF0YVswXS5sZW5ndGgpeyBpTWluWSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsgfVxuXG4gICAgdmFyIG1pbk1heCA9IFtdO1xuICAgIGhmU2hhcGUuZ2V0UmVjdE1pbk1heChpTWluWCwgaU1pblksIGlNYXhYLCBpTWF4WSwgbWluTWF4KTtcbiAgICB2YXIgbWluID0gbWluTWF4WzBdO1xuICAgIHZhciBtYXggPSBtaW5NYXhbMV07XG5cbiAgICAvLyBCYWlsIG91dCBpZiB3ZSdyZSBjYW50IHRvdWNoIHRoZSBib3VuZGluZyBoZWlnaHQgYm94XG4gICAgaWYobG9jYWxTcGhlcmVQb3MueiAtIHJhZGl1cyA+IG1heCB8fCBsb2NhbFNwaGVyZVBvcy56ICsgcmFkaXVzIDwgbWluKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcbiAgICBmb3IodmFyIGkgPSBpTWluWDsgaSA8IGlNYXhYOyBpKyspe1xuICAgICAgICBmb3IodmFyIGogPSBpTWluWTsgaiA8IGlNYXhZOyBqKyspe1xuXG4gICAgICAgICAgICB2YXIgbnVtQ29udGFjdHNCZWZvcmUgPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBMb3dlciB0cmlhbmdsZVxuICAgICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCBmYWxzZSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUoaGZQb3MsIGhmUXVhdCwgaGZTaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChzcGhlcmVQb3MuZGlzdGFuY2VUbyh3b3JsZFBpbGxhck9mZnNldCkgPCBoZlNoYXBlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNwaGVyZVNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGhlcmVDb252ZXgoc3BoZXJlU2hhcGUsIGhmU2hhcGUucGlsbGFyQ29udmV4LCBzcGhlcmVQb3MsIHdvcmxkUGlsbGFyT2Zmc2V0LCBzcGhlcmVRdWF0LCBoZlF1YXQsIHNwaGVyZUJvZHksIGhmQm9keSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwcGVyIHRyaWFuZ2xlXG4gICAgICAgICAgICBoZlNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIHRydWUpO1xuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XG4gICAgICAgICAgICBpZiAoc3BoZXJlUG9zLmRpc3RhbmNlVG8od29ybGRQaWxsYXJPZmZzZXQpIDwgaGZTaGFwZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzcGhlcmVTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3BoZXJlQ29udmV4KHNwaGVyZVNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgc3BoZXJlUG9zLCB3b3JsZFBpbGxhck9mZnNldCwgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbnVtQ29udGFjdHMgPSByZXN1bHQubGVuZ3RoIC0gbnVtQ29udGFjdHNCZWZvcmU7XG5cbiAgICAgICAgICAgIGlmKG51bUNvbnRhY3RzID4gMil7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIC8vIFNraXAgYWxsIGJ1dCAxXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG51bUNvbnRhY3RzIC0gMTsgaysrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIvKiBnbG9iYWwgcGVyZm9ybWFuY2UgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXb3JsZDtcblxudmFyIFNoYXBlID0gcmVxdWlyZSgnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgVmVjMyA9IHJlcXVpcmUoJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSByZXF1aXJlKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBHU1NvbHZlciA9IHJlcXVpcmUoJy4uL3NvbHZlci9HU1NvbHZlcicpO1xudmFyIENvbnRhY3RFcXVhdGlvbiA9IHJlcXVpcmUoJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcbnZhciBGcmljdGlvbkVxdWF0aW9uID0gcmVxdWlyZSgnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcbnZhciBOYXJyb3dwaGFzZSA9IHJlcXVpcmUoJy4vTmFycm93cGhhc2UnKTtcbnZhciBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4uL3V0aWxzL0V2ZW50VGFyZ2V0Jyk7XG52YXIgQXJyYXlDb2xsaXNpb25NYXRyaXggPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQXJyYXlDb2xsaXNpb25NYXRyaXgnKTtcbnZhciBNYXRlcmlhbCA9IHJlcXVpcmUoJy4uL21hdGVyaWFsL01hdGVyaWFsJyk7XG52YXIgQ29udGFjdE1hdGVyaWFsID0gcmVxdWlyZSgnLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJyk7XG52YXIgQm9keSA9IHJlcXVpcmUoJy4uL29iamVjdHMvQm9keScpO1xudmFyIFR1cGxlRGljdGlvbmFyeSA9IHJlcXVpcmUoJy4uL3V0aWxzL1R1cGxlRGljdGlvbmFyeScpO1xudmFyIFJheWNhc3RSZXN1bHQgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xudmFyIEFBQkIgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vQUFCQicpO1xudmFyIFJheSA9IHJlcXVpcmUoJy4uL2NvbGxpc2lvbi9SYXknKTtcbnZhciBOYWl2ZUJyb2FkcGhhc2UgPSByZXF1aXJlKCcuLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyk7XG5cbi8qKlxuICogVGhlIHBoeXNpY3Mgd29ybGRcbiAqIEBjbGFzcyBXb3JsZFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5ncmF2aXR5XVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hbGxvd1NsZWVwXVxuICogQHBhcmFtIHtCcm9hZHBoYXNlfSBbb3B0aW9ucy5icm9hZHBoYXNlXVxuICogQHBhcmFtIHtTb2x2ZXJ9IFtvcHRpb25zLnNvbHZlcl1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucXVhdE5vcm1hbGl6ZUZhc3RdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucXVhdE5vcm1hbGl6ZVNraXBdXG4gKi9cbmZ1bmN0aW9uIFdvcmxkKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIEV2ZW50VGFyZ2V0LmFwcGx5KHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudGx5IC8gbGFzdCB1c2VkIHRpbWVzdGVwLiBJcyBzZXQgdG8gLTEgaWYgbm90IGF2YWlsYWJsZS4gVGhpcyB2YWx1ZSBpcyB1cGRhdGVkIGJlZm9yZSBlYWNoIGludGVybmFsIHN0ZXAsIHdoaWNoIG1lYW5zIHRoYXQgaXQgaXMgXCJmcmVzaFwiIGluc2lkZSBldmVudCBjYWxsYmFja3MuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGR0XG4gICAgICovXG4gICAgdGhpcy5kdCA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogTWFrZXMgYm9kaWVzIGdvIHRvIHNsZWVwIHdoZW4gdGhleSd2ZSBiZWVuIGluYWN0aXZlXG4gICAgICogQHByb3BlcnR5IGFsbG93U2xlZXBcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHRoaXMuYWxsb3dTbGVlcCA9ICEhb3B0aW9ucy5hbGxvd1NsZWVwO1xuXG4gICAgLyoqXG4gICAgICogQWxsIHRoZSBjdXJyZW50IGNvbnRhY3RzIChpbnN0YW5jZXMgb2YgQ29udGFjdEVxdWF0aW9uKSBpbiB0aGUgd29ybGQuXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdHMgPSBbXTtcbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBIb3cgb2Z0ZW4gdG8gbm9ybWFsaXplIHF1YXRlcm5pb25zLiBTZXQgdG8gMCBmb3IgZXZlcnkgc3RlcCwgMSBmb3IgZXZlcnkgc2Vjb25kIGV0Yy4uIEEgbGFyZ2VyIHZhbHVlIGluY3JlYXNlcyBwZXJmb3JtYW5jZS4gSWYgYm9kaWVzIHRlbmQgdG8gZXhwbG9kZSwgc2V0IHRvIGEgc21hbGxlciB2YWx1ZSAoemVybyB0byBiZSBzdXJlIG5vdGhpbmcgY2FuIGdvIHdyb25nKS5cbiAgICAgKiBAcHJvcGVydHkgcXVhdE5vcm1hbGl6ZVNraXBcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnF1YXROb3JtYWxpemVTa2lwID0gb3B0aW9ucy5xdWF0Tm9ybWFsaXplU2tpcCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5xdWF0Tm9ybWFsaXplU2tpcCA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byB1c2UgZmFzdCBxdWF0ZXJuaW9uIG5vcm1hbGl6YXRpb24uIEl0IGlzIG9mdGVuIGVub3VnaCBhY2N1cmF0ZSB0byB1c2UuIElmIGJvZGllcyB0ZW5kIHRvIGV4cGxvZGUsIHNldCB0byBmYWxzZS5cbiAgICAgKiBAcHJvcGVydHkgcXVhdE5vcm1hbGl6ZUZhc3RcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIFF1YXRlcm5pb24ubm9ybWFsaXplRmFzdFxuICAgICAqIEBzZWUgUXVhdGVybmlvbi5ub3JtYWxpemVcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHRoaXMucXVhdE5vcm1hbGl6ZUZhc3QgPSBvcHRpb25zLnF1YXROb3JtYWxpemVGYXN0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnF1YXROb3JtYWxpemVGYXN0IDogZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgd2FsbC1jbG9jayB0aW1lIHNpbmNlIHNpbXVsYXRpb24gc3RhcnRcbiAgICAgKiBAcHJvcGVydHkgdGltZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy50aW1lID0gMC4wO1xuXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHRpbWVzdGVwcyB0YWtlbiBzaW5jZSBzdGFydFxuICAgICAqIEBwcm9wZXJ0eSBzdGVwbnVtYmVyXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0ZXBudW1iZXIgPSAwO1xuXG4gICAgLy8vIERlZmF1bHQgYW5kIGxhc3QgdGltZXN0ZXAgc2l6ZXNcbiAgICB0aGlzLmRlZmF1bHRfZHQgPSAxLzYwO1xuXG4gICAgdGhpcy5uZXh0SWQgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBncmF2aXR5XG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5ncmF2aXR5ID0gbmV3IFZlYzMoKTtcbiAgICBpZihvcHRpb25zLmdyYXZpdHkpe1xuICAgICAgICB0aGlzLmdyYXZpdHkuY29weShvcHRpb25zLmdyYXZpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBicm9hZHBoYXNlIGFsZ29yaXRobSB0byB1c2UuIERlZmF1bHQgaXMgTmFpdmVCcm9hZHBoYXNlXG4gICAgICogQHByb3BlcnR5IGJyb2FkcGhhc2VcbiAgICAgKiBAdHlwZSB7QnJvYWRwaGFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmJyb2FkcGhhc2UgPSBvcHRpb25zLmJyb2FkcGhhc2UgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYnJvYWRwaGFzZSA6IG5ldyBOYWl2ZUJyb2FkcGhhc2UoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBib2RpZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5ib2RpZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzb2x2ZXIgYWxnb3JpdGhtIHRvIHVzZS4gRGVmYXVsdCBpcyBHU1NvbHZlclxuICAgICAqIEBwcm9wZXJ0eSBzb2x2ZXJcbiAgICAgKiBAdHlwZSB7U29sdmVyfVxuICAgICAqL1xuICAgIHRoaXMuc29sdmVyID0gb3B0aW9ucy5zb2x2ZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc29sdmVyIDogbmV3IEdTU29sdmVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgY29uc3RyYWludHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb25zdHJhaW50cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IG5hcnJvd3BoYXNlXG4gICAgICogQHR5cGUge05hcnJvd3BoYXNlfVxuICAgICAqL1xuICAgIHRoaXMubmFycm93cGhhc2UgPSBuZXcgTmFycm93cGhhc2UodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0FycmF5Q29sbGlzaW9uTWF0cml4fSBjb2xsaXNpb25NYXRyaXhcblx0ICogQHR5cGUge0FycmF5Q29sbGlzaW9uTWF0cml4fVxuXHQgKi9cblx0dGhpcy5jb2xsaXNpb25NYXRyaXggPSBuZXcgQXJyYXlDb2xsaXNpb25NYXRyaXgoKTtcblxuICAgIC8qKlxuICAgICAqIENvbGxpc2lvbk1hdHJpeCBmcm9tIHRoZSBwcmV2aW91cyBzdGVwLlxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXlDb2xsaXNpb25NYXRyaXh9IGNvbGxpc2lvbk1hdHJpeFByZXZpb3VzXG5cdCAqIEB0eXBlIHtBcnJheUNvbGxpc2lvbk1hdHJpeH1cblx0ICovXG5cdHRoaXMuY29sbGlzaW9uTWF0cml4UHJldmlvdXMgPSBuZXcgQXJyYXlDb2xsaXNpb25NYXRyaXgoKTtcblxuICAgIC8qKlxuICAgICAqIEFsbCBhZGRlZCBtYXRlcmlhbHNcbiAgICAgKiBAcHJvcGVydHkgbWF0ZXJpYWxzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubWF0ZXJpYWxzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgY29udGFjdG1hdGVyaWFsc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RtYXRlcmlhbHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gbG9vayB1cCBhIENvbnRhY3RNYXRlcmlhbCBnaXZlbiB0d28gaW5zdGFuY2VzIG9mIE1hdGVyaWFsLlxuICAgICAqIEBwcm9wZXJ0eSB7VHVwbGVEaWN0aW9uYXJ5fSBjb250YWN0TWF0ZXJpYWxUYWJsZVxuICAgICAqL1xuICAgIHRoaXMuY29udGFjdE1hdGVyaWFsVGFibGUgPSBuZXcgVHVwbGVEaWN0aW9uYXJ5KCk7XG5cbiAgICB0aGlzLmRlZmF1bHRNYXRlcmlhbCA9IG5ldyBNYXRlcmlhbChcImRlZmF1bHRcIik7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbnRhY3QgbWF0ZXJpYWwgaXMgdXNlZCBpZiBubyBzdWl0YWJsZSBjb250YWN0bWF0ZXJpYWwgaXMgZm91bmQgZm9yIGEgY29udGFjdC5cbiAgICAgKiBAcHJvcGVydHkgZGVmYXVsdENvbnRhY3RNYXRlcmlhbFxuICAgICAqIEB0eXBlIHtDb250YWN0TWF0ZXJpYWx9XG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsID0gbmV3IENvbnRhY3RNYXRlcmlhbCh0aGlzLmRlZmF1bHRNYXRlcmlhbCwgdGhpcy5kZWZhdWx0TWF0ZXJpYWwsIHsgZnJpY3Rpb246IDAuMywgcmVzdGl0dXRpb246IDAuMCB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBkb1Byb2ZpbGluZ1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuZG9Qcm9maWxpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBwcm9maWxlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnByb2ZpbGUgPSB7XG4gICAgICAgIHNvbHZlOjAsXG4gICAgICAgIG1ha2VDb250YWN0Q29uc3RyYWludHM6MCxcbiAgICAgICAgYnJvYWRwaGFzZTowLFxuICAgICAgICBpbnRlZ3JhdGU6MCxcbiAgICAgICAgbmFycm93cGhhc2U6MCxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGltZSBhY2N1bXVsYXRvciBmb3IgaW50ZXJwb2xhdGlvbi4gU2VlIGh0dHA6Ly9nYWZmZXJvbmdhbWVzLmNvbS9nYW1lLXBoeXNpY3MvZml4LXlvdXItdGltZXN0ZXAvXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGFjY3VtdWxhdG9yXG4gICAgICovXG4gICAgdGhpcy5hY2N1bXVsYXRvciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgc3Vic3lzdGVtc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnN1YnN5c3RlbXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBiZWVuIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKiBAZXZlbnQgYWRkQm9keVxuICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keSBUaGUgYm9keSB0aGF0IGhhcyBiZWVuIGFkZGVkIHRvIHRoZSB3b3JsZC5cbiAgICAgKi9cbiAgICB0aGlzLmFkZEJvZHlFdmVudCA9IHtcbiAgICAgICAgdHlwZTpcImFkZEJvZHlcIixcbiAgICAgICAgYm9keSA6IG51bGwsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZWQgYWZ0ZXIgYSBib2R5IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgd29ybGQuXG4gICAgICogQGV2ZW50IHJlbW92ZUJvZHlcbiAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHkgVGhlIGJvZHkgdGhhdCBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHdvcmxkLlxuICAgICAqL1xuICAgIHRoaXMucmVtb3ZlQm9keUV2ZW50ID0ge1xuICAgICAgICB0eXBlOlwicmVtb3ZlQm9keVwiLFxuICAgICAgICBib2R5IDogbnVsbCxcbiAgICB9O1xuXG4gICAgdGhpcy5icm9hZHBoYXNlLnNldFdvcmxkKHRoaXMpO1xufVxuV29ybGQucHJvdG90eXBlID0gbmV3IEV2ZW50VGFyZ2V0KCk7XG5cbi8vIFRlbXAgc3R1ZmZcbnZhciB0bXBBQUJCMSA9IG5ldyBBQUJCKCk7XG52YXIgdG1wQXJyYXkxID0gW107XG52YXIgdG1wUmF5ID0gbmV3IFJheSgpO1xuXG4vKipcbiAqIEdldCB0aGUgY29udGFjdCBtYXRlcmlhbCBiZXR3ZWVuIG1hdGVyaWFscyBtMSBhbmQgbTJcbiAqIEBtZXRob2QgZ2V0Q29udGFjdE1hdGVyaWFsXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtMVxuICogQHBhcmFtIHtNYXRlcmlhbH0gbTJcbiAqIEByZXR1cm4ge0NvbnRhY3RNYXRlcmlhbH0gVGhlIGNvbnRhY3QgbWF0ZXJpYWwgaWYgaXQgd2FzIGZvdW5kLlxuICovXG5Xb3JsZC5wcm90b3R5cGUuZ2V0Q29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24obTEsbTIpe1xuICAgIHJldHVybiB0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlLmdldChtMS5pZCxtMi5pZCk7IC8vdGhpcy5jb250YWN0bWF0ZXJpYWxzW3RoaXMubWF0czJjbWF0W2kraip0aGlzLm1hdGVyaWFscy5sZW5ndGhdXTtcbn07XG5cbi8qKlxuICogR2V0IG51bWJlciBvZiBvYmplY3RzIGluIHRoZSB3b3JsZC5cbiAqIEBtZXRob2QgbnVtT2JqZWN0c1xuICogQHJldHVybiB7TnVtYmVyfVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuV29ybGQucHJvdG90eXBlLm51bU9iamVjdHMgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmJvZGllcy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIFN0b3JlIG9sZCBjb2xsaXNpb24gc3RhdGUgaW5mb1xuICogQG1ldGhvZCBjb2xsaXNpb25NYXRyaXhUaWNrXG4gKi9cbldvcmxkLnByb3RvdHlwZS5jb2xsaXNpb25NYXRyaXhUaWNrID0gZnVuY3Rpb24oKXtcblx0dmFyIHRlbXAgPSB0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzO1xuXHR0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzID0gdGhpcy5jb2xsaXNpb25NYXRyaXg7XG5cdHRoaXMuY29sbGlzaW9uTWF0cml4ID0gdGVtcDtcblx0dGhpcy5jb2xsaXNpb25NYXRyaXgucmVzZXQoKTtcbn07XG5cbi8qKlxuICogQWRkIGEgcmlnaWQgYm9keSB0byB0aGUgc2ltdWxhdGlvbi5cbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqIEB0b2RvIElmIHRoZSBzaW11bGF0aW9uIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHdoeSByZWNyZXRlIGFuZCBjb3B5IGFycmF5cyBmb3IgZWFjaCBib2R5PyBBY2N1bXVsYXRlIGluIGR5bmFtaWMgYXJyYXlzIGluIHRoaXMgY2FzZS5cbiAqIEB0b2RvIEFkZGluZyBhbiBhcnJheSBvZiBib2RpZXMgc2hvdWxkIGJlIHBvc3NpYmxlLiBUaGlzIHdvdWxkIHNhdmUgc29tZSBsb29wcyB0b29cbiAqIEBkZXByZWNhdGVkIFVzZSAuYWRkQm9keSBpbnN0ZWFkXG4gKi9cbldvcmxkLnByb3RvdHlwZS5hZGQgPSBXb3JsZC5wcm90b3R5cGUuYWRkQm9keSA9IGZ1bmN0aW9uKGJvZHkpe1xuICAgIGlmKHRoaXMuYm9kaWVzLmluZGV4T2YoYm9keSkgIT09IC0xKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBib2R5LmluZGV4ID0gdGhpcy5ib2RpZXMubGVuZ3RoO1xuICAgIHRoaXMuYm9kaWVzLnB1c2goYm9keSk7XG4gICAgYm9keS53b3JsZCA9IHRoaXM7XG4gICAgYm9keS5pbml0UG9zaXRpb24uY29weShib2R5LnBvc2l0aW9uKTtcbiAgICBib2R5LmluaXRWZWxvY2l0eS5jb3B5KGJvZHkudmVsb2NpdHkpO1xuICAgIGJvZHkudGltZUxhc3RTbGVlcHkgPSB0aGlzLnRpbWU7XG4gICAgaWYoYm9keSBpbnN0YW5jZW9mIEJvZHkpe1xuICAgICAgICBib2R5LmluaXRBbmd1bGFyVmVsb2NpdHkuY29weShib2R5LmFuZ3VsYXJWZWxvY2l0eSk7XG4gICAgICAgIGJvZHkuaW5pdFF1YXRlcm5pb24uY29weShib2R5LnF1YXRlcm5pb24pO1xuICAgIH1cblx0dGhpcy5jb2xsaXNpb25NYXRyaXguc2V0TnVtT2JqZWN0cyh0aGlzLmJvZGllcy5sZW5ndGgpO1xuICAgIHRoaXMuYWRkQm9keUV2ZW50LmJvZHkgPSBib2R5O1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLmFkZEJvZHlFdmVudCk7XG59O1xuXG4vKipcbiAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHNpbXVsYXRpb24uXG4gKiBAbWV0aG9kIGFkZENvbnN0cmFpbnRcbiAqIEBwYXJhbSB7Q29uc3RyYWludH0gY1xuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkQ29uc3RyYWludCA9IGZ1bmN0aW9uKGMpe1xuICAgIHRoaXMuY29uc3RyYWludHMucHVzaChjKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGNvbnN0cmFpbnRcbiAqIEBtZXRob2QgcmVtb3ZlQ29uc3RyYWludFxuICogQHBhcmFtIHtDb25zdHJhaW50fSBjXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yZW1vdmVDb25zdHJhaW50ID0gZnVuY3Rpb24oYyl7XG4gICAgdmFyIGlkeCA9IHRoaXMuY29uc3RyYWludHMuaW5kZXhPZihjKTtcbiAgICBpZihpZHghPT0tMSl7XG4gICAgICAgIHRoaXMuY29uc3RyYWludHMuc3BsaWNlKGlkeCwxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJheWNhc3QgdGVzdFxuICogQG1ldGhvZCByYXlUZXN0XG4gKiBAcGFyYW0ge1ZlYzN9IGZyb21cbiAqIEBwYXJhbSB7VmVjM30gdG9cbiAqIEBwYXJhbSB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gKiBAZGVwcmVjYXRlZCBVc2UgLnJheWNhc3RBbGwsIC5yYXljYXN0Q2xvc2VzdCBvciAucmF5Y2FzdEFueSBpbnN0ZWFkLlxuICovXG5Xb3JsZC5wcm90b3R5cGUucmF5VGVzdCA9IGZ1bmN0aW9uKGZyb20sIHRvLCByZXN1bHQpe1xuICAgIGlmKHJlc3VsdCBpbnN0YW5jZW9mIFJheWNhc3RSZXN1bHQpe1xuICAgICAgICAvLyBEbyByYXljYXN0Y2xvc2VzdFxuICAgICAgICB0aGlzLnJheWNhc3RDbG9zZXN0KGZyb20sIHRvLCB7XG4gICAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlXG4gICAgICAgIH0sIHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRG8gcmF5Y2FzdEFsbFxuICAgICAgICB0aGlzLnJheWNhc3RBbGwoZnJvbSwgdG8sIHtcbiAgICAgICAgICAgIHNraXBCYWNrZmFjZXM6IHRydWVcbiAgICAgICAgfSwgcmVzdWx0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJheSBjYXN0IGFnYWluc3QgYWxsIGJvZGllcy4gVGhlIHByb3ZpZGVkIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2ggaGl0IHdpdGggYSBSYXljYXN0UmVzdWx0IGFzIHNpbmdsZSBhcmd1bWVudC5cbiAqIEBtZXRob2QgcmF5Y2FzdEFsbFxuICogQHBhcmFtICB7VmVjM30gZnJvbVxuICogQHBhcmFtICB7VmVjM30gdG9cbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrPS0xXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cD0tMV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnJheWNhc3RBbGwgPSBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucywgY2FsbGJhY2spe1xuICAgIG9wdGlvbnMubW9kZSA9IFJheS5BTEw7XG4gICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcbiAgICBvcHRpb25zLnRvID0gdG87XG4gICAgb3B0aW9ucy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHJldHVybiB0bXBSYXkuaW50ZXJzZWN0V29ybGQodGhpcywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJheSBjYXN0LCBhbmQgc3RvcCBhdCB0aGUgZmlyc3QgcmVzdWx0LiBOb3RlIHRoYXQgdGhlIG9yZGVyIGlzIHJhbmRvbSAtIGJ1dCB0aGUgbWV0aG9kIGlzIGZhc3QuXG4gKiBAbWV0aG9kIHJheWNhc3RBbnlcbiAqIEBwYXJhbSAge1ZlYzN9IGZyb21cbiAqIEBwYXJhbSAge1ZlYzN9IHRvXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaz0tMV1cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXA9LTFdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT10cnVlXVxuICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yYXljYXN0QW55ID0gZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMsIHJlc3VsdCl7XG4gICAgb3B0aW9ucy5tb2RlID0gUmF5LkFOWTtcbiAgICBvcHRpb25zLmZyb20gPSBmcm9tO1xuICAgIG9wdGlvbnMudG8gPSB0bztcbiAgICBvcHRpb25zLnJlc3VsdCA9IHJlc3VsdDtcbiAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSYXkgY2FzdCwgYW5kIHJldHVybiBpbmZvcm1hdGlvbiBvZiB0aGUgY2xvc2VzdCBoaXQuXG4gKiBAbWV0aG9kIHJheWNhc3RDbG9zZXN0XG4gKiBAcGFyYW0gIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0gIHtWZWMzfSB0b1xuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2s9LTFdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwPS0xXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEJhY2tmYWNlcz1mYWxzZV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cbiAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxuICovXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdENsb3Nlc3QgPSBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucywgcmVzdWx0KXtcbiAgICBvcHRpb25zLm1vZGUgPSBSYXkuQ0xPU0VTVDtcbiAgICBvcHRpb25zLmZyb20gPSBmcm9tO1xuICAgIG9wdGlvbnMudG8gPSB0bztcbiAgICBvcHRpb25zLnJlc3VsdCA9IHJlc3VsdDtcbiAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSByaWdpZCBib2R5IGZyb20gdGhlIHNpbXVsYXRpb24uXG4gKiBAbWV0aG9kIHJlbW92ZVxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKiBAZGVwcmVjYXRlZCBVc2UgLnJlbW92ZUJvZHkgaW5zdGVhZFxuICovXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oYm9keSl7XG4gICAgYm9keS53b3JsZCA9IG51bGw7XG4gICAgdmFyIG4gPSB0aGlzLmJvZGllcy5sZW5ndGggLSAxLFxuICAgICAgICBib2RpZXMgPSB0aGlzLmJvZGllcyxcbiAgICAgICAgaWR4ID0gYm9kaWVzLmluZGV4T2YoYm9keSk7XG4gICAgaWYoaWR4ICE9PSAtMSl7XG4gICAgICAgIGJvZGllcy5zcGxpY2UoaWR4LCAxKTsgLy8gVG9kbzogc2hvdWxkIHVzZSBhIGdhcmJhZ2UgZnJlZSBtZXRob2RcblxuICAgICAgICAvLyBSZWNvbXB1dGUgaW5kZXhcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1ib2RpZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgYm9kaWVzW2ldLmluZGV4ID0gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29sbGlzaW9uTWF0cml4LnNldE51bU9iamVjdHMobik7XG4gICAgICAgIHRoaXMucmVtb3ZlQm9keUV2ZW50LmJvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5yZW1vdmVCb2R5RXZlbnQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgcmlnaWQgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLlxuICogQG1ldGhvZCByZW1vdmVCb2R5XG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZUJvZHkgPSBXb3JsZC5wcm90b3R5cGUucmVtb3ZlO1xuXG4vKipcbiAqIEFkZHMgYSBtYXRlcmlhbCB0byB0aGUgV29ybGQuXG4gKiBAbWV0aG9kIGFkZE1hdGVyaWFsXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtXG4gKiBAdG9kbyBOZWNlc3Nhcnk/XG4gKi9cbldvcmxkLnByb3RvdHlwZS5hZGRNYXRlcmlhbCA9IGZ1bmN0aW9uKG0pe1xuICAgIHRoaXMubWF0ZXJpYWxzLnB1c2gobSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjb250YWN0IG1hdGVyaWFsIHRvIHRoZSBXb3JsZFxuICogQG1ldGhvZCBhZGRDb250YWN0TWF0ZXJpYWxcbiAqIEBwYXJhbSB7Q29udGFjdE1hdGVyaWFsfSBjbWF0XG4gKi9cbldvcmxkLnByb3RvdHlwZS5hZGRDb250YWN0TWF0ZXJpYWwgPSBmdW5jdGlvbihjbWF0KSB7XG5cbiAgICAvLyBBZGQgY29udGFjdCBtYXRlcmlhbFxuICAgIHRoaXMuY29udGFjdG1hdGVyaWFscy5wdXNoKGNtYXQpO1xuXG4gICAgLy8gQWRkIGN1cnJlbnQgY29udGFjdCBtYXRlcmlhbCB0byB0aGUgbWF0ZXJpYWwgdGFibGVcbiAgICB0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlLnNldChjbWF0Lm1hdGVyaWFsc1swXS5pZCxjbWF0Lm1hdGVyaWFsc1sxXS5pZCxjbWF0KTtcbn07XG5cbi8vIHBlcmZvcm1hbmNlLm5vdygpXG5pZih0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnKXtcbiAgICBwZXJmb3JtYW5jZSA9IHt9O1xufVxuaWYoIXBlcmZvcm1hbmNlLm5vdyl7XG4gICAgdmFyIG5vd09mZnNldCA9IERhdGUubm93KCk7XG4gICAgaWYgKHBlcmZvcm1hbmNlLnRpbWluZyAmJiBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0KXtcbiAgICAgICAgbm93T2Zmc2V0ID0gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDtcbiAgICB9XG4gICAgcGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBub3dPZmZzZXQ7XG4gICAgfTtcbn1cblxudmFyIHN0ZXBfdG1wMSA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogU3RlcCB0aGUgcGh5c2ljcyB3b3JsZCBmb3J3YXJkIGluIHRpbWUuXG4gKlxuICogVGhlcmUgYXJlIHR3byBtb2Rlcy4gVGhlIHNpbXBsZSBtb2RlIGlzIGZpeGVkIHRpbWVzdGVwcGluZyB3aXRob3V0IGludGVycG9sYXRpb24uIEluIHRoaXMgY2FzZSB5b3Ugb25seSB1c2UgdGhlIGZpcnN0IGFyZ3VtZW50LiBUaGUgc2Vjb25kIGNhc2UgdXNlcyBpbnRlcnBvbGF0aW9uLiBJbiB0aGF0IHlvdSBhbHNvIHByb3ZpZGUgdGhlIHRpbWUgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IHVzZWQsIGFzIHdlbGwgYXMgdGhlIG1heGltdW0gZml4ZWQgdGltZXN0ZXBzIHRvIHRha2UuXG4gKlxuICogQG1ldGhvZCBzdGVwXG4gKiBAcGFyYW0ge051bWJlcn0gZHQgICAgICAgICAgICAgICAgICAgICAgIFRoZSBmaXhlZCB0aW1lIHN0ZXAgc2l6ZSB0byB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gW3RpbWVTaW5jZUxhc3RDYWxsZWRdICAgIFRoZSB0aW1lIGVsYXBzZWQgc2luY2UgdGhlIGZ1bmN0aW9uIHdhcyBsYXN0IGNhbGxlZC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4U3ViU3RlcHM9MTBdICAgICAgICAgTWF4aW11bSBudW1iZXIgb2YgZml4ZWQgc3RlcHMgdG8gdGFrZSBwZXIgZnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIGZpeGVkIHRpbWVzdGVwcGluZyB3aXRob3V0IGludGVycG9sYXRpb25cbiAqICAgICB3b3JsZC5zdGVwKDEvNjApO1xuICpcbiAqIEBzZWUgaHR0cDovL2J1bGxldHBoeXNpY3Mub3JnL21lZGlhd2lraS0xLjUuOC9pbmRleC5waHAvU3RlcHBpbmdfVGhlX1dvcmxkXG4gKi9cbldvcmxkLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24oZHQsIHRpbWVTaW5jZUxhc3RDYWxsZWQsIG1heFN1YlN0ZXBzKXtcbiAgICBtYXhTdWJTdGVwcyA9IG1heFN1YlN0ZXBzIHx8IDEwO1xuICAgIHRpbWVTaW5jZUxhc3RDYWxsZWQgPSB0aW1lU2luY2VMYXN0Q2FsbGVkIHx8IDA7XG5cbiAgICBpZih0aW1lU2luY2VMYXN0Q2FsbGVkID09PSAwKXsgLy8gRml4ZWQsIHNpbXBsZSBzdGVwcGluZ1xuXG4gICAgICAgIHRoaXMuaW50ZXJuYWxTdGVwKGR0KTtcblxuICAgICAgICAvLyBJbmNyZW1lbnQgdGltZVxuICAgICAgICB0aGlzLnRpbWUgKz0gZHQ7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRoaXMuYWNjdW11bGF0b3IgKz0gdGltZVNpbmNlTGFzdENhbGxlZDtcbiAgICAgICAgdmFyIHN1YnN0ZXBzID0gMDtcbiAgICAgICAgd2hpbGUgKHRoaXMuYWNjdW11bGF0b3IgPj0gZHQgJiYgc3Vic3RlcHMgPCBtYXhTdWJTdGVwcykge1xuICAgICAgICAgICAgLy8gRG8gZml4ZWQgc3RlcHMgdG8gY2F0Y2ggdXBcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTdGVwKGR0KTtcbiAgICAgICAgICAgIHRoaXMuYWNjdW11bGF0b3IgLT0gZHQ7XG4gICAgICAgICAgICBzdWJzdGVwcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSAodGhpcy5hY2N1bXVsYXRvciAlIGR0KSAvIGR0O1xuICAgICAgICBmb3IodmFyIGo9MDsgaiAhPT0gdGhpcy5ib2RpZXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmJvZGllc1tqXTtcbiAgICAgICAgICAgIGIucHJldmlvdXNQb3NpdGlvbi5sZXJwKGIucG9zaXRpb24sIHQsIGIuaW50ZXJwb2xhdGVkUG9zaXRpb24pO1xuICAgICAgICAgICAgYi5wcmV2aW91c1F1YXRlcm5pb24uc2xlcnAoYi5xdWF0ZXJuaW9uLCB0LCBiLmludGVycG9sYXRlZFF1YXRlcm5pb24pO1xuICAgICAgICAgICAgYi5wcmV2aW91c1F1YXRlcm5pb24ubm9ybWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lICs9IHRpbWVTaW5jZUxhc3RDYWxsZWQ7XG4gICAgfVxufTtcblxudmFyXG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2hlZCBhZnRlciB0aGUgd29ybGQgaGFzIHN0ZXBwZWQgZm9yd2FyZCBpbiB0aW1lLlxuICAgICAqIEBldmVudCBwb3N0U3RlcFxuICAgICAqL1xuICAgIFdvcmxkX3N0ZXBfcG9zdFN0ZXBFdmVudCA9IHt0eXBlOlwicG9zdFN0ZXBcIn0sIC8vIFJldXNhYmxlIGV2ZW50IG9iamVjdHMgdG8gc2F2ZSBtZW1vcnlcbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaGVkIGJlZm9yZSB0aGUgd29ybGQgc3RlcHMgZm9yd2FyZCBpbiB0aW1lLlxuICAgICAqIEBldmVudCBwcmVTdGVwXG4gICAgICovXG4gICAgV29ybGRfc3RlcF9wcmVTdGVwRXZlbnQgPSB7dHlwZTpcInByZVN0ZXBcIn0sXG4gICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQgPSB7dHlwZTpCb2R5LkNPTExJREVfRVZFTlRfTkFNRSwgYm9keTpudWxsLCBjb250YWN0Om51bGwgfSxcbiAgICBXb3JsZF9zdGVwX29sZENvbnRhY3RzID0gW10sIC8vIFBvb2xzIGZvciB1bnVzZWQgb2JqZWN0c1xuICAgIFdvcmxkX3N0ZXBfZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBbXSxcbiAgICBXb3JsZF9zdGVwX3AxID0gW10sIC8vIFJldXNhYmxlIGFycmF5cyBmb3IgY29sbGlzaW9uIHBhaXJzXG4gICAgV29ybGRfc3RlcF9wMiA9IFtdLFxuICAgIFdvcmxkX3N0ZXBfZ3ZlYyA9IG5ldyBWZWMzKCksIC8vIFRlbXBvcmFyeSB2ZWN0b3JzIGFuZCBxdWF0c1xuICAgIFdvcmxkX3N0ZXBfdmkgPSBuZXcgVmVjMygpLFxuICAgIFdvcmxkX3N0ZXBfdmogPSBuZXcgVmVjMygpLFxuICAgIFdvcmxkX3N0ZXBfd2kgPSBuZXcgVmVjMygpLFxuICAgIFdvcmxkX3N0ZXBfd2ogPSBuZXcgVmVjMygpLFxuICAgIFdvcmxkX3N0ZXBfdDEgPSBuZXcgVmVjMygpLFxuICAgIFdvcmxkX3N0ZXBfdDIgPSBuZXcgVmVjMygpLFxuICAgIFdvcmxkX3N0ZXBfcml4biA9IG5ldyBWZWMzKCksXG4gICAgV29ybGRfc3RlcF9yanhuID0gbmV3IFZlYzMoKSxcbiAgICBXb3JsZF9zdGVwX3N0ZXBfcSA9IG5ldyBRdWF0ZXJuaW9uKCksXG4gICAgV29ybGRfc3RlcF9zdGVwX3cgPSBuZXcgUXVhdGVybmlvbigpLFxuICAgIFdvcmxkX3N0ZXBfc3RlcF93cSA9IG5ldyBRdWF0ZXJuaW9uKCksXG4gICAgaW52SV90YXVfZHQgPSBuZXcgVmVjMygpO1xuV29ybGQucHJvdG90eXBlLmludGVybmFsU3RlcCA9IGZ1bmN0aW9uKGR0KXtcbiAgICB0aGlzLmR0ID0gZHQ7XG5cbiAgICB2YXIgd29ybGQgPSB0aGlzLFxuICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgY29udGFjdHMgPSB0aGlzLmNvbnRhY3RzLFxuICAgICAgICBwMSA9IFdvcmxkX3N0ZXBfcDEsXG4gICAgICAgIHAyID0gV29ybGRfc3RlcF9wMixcbiAgICAgICAgTiA9IHRoaXMubnVtT2JqZWN0cygpLFxuICAgICAgICBib2RpZXMgPSB0aGlzLmJvZGllcyxcbiAgICAgICAgc29sdmVyID0gdGhpcy5zb2x2ZXIsXG4gICAgICAgIGdyYXZpdHkgPSB0aGlzLmdyYXZpdHksXG4gICAgICAgIGRvUHJvZmlsaW5nID0gdGhpcy5kb1Byb2ZpbGluZyxcbiAgICAgICAgcHJvZmlsZSA9IHRoaXMucHJvZmlsZSxcbiAgICAgICAgRFlOQU1JQyA9IEJvZHkuRFlOQU1JQyxcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQsXG4gICAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyxcbiAgICAgICAgZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBXb3JsZF9zdGVwX2ZyaWN0aW9uRXF1YXRpb25Qb29sLFxuICAgICAgICBnbm9ybSA9IGdyYXZpdHkubm9ybSgpLFxuICAgICAgICBneCA9IGdyYXZpdHkueCxcbiAgICAgICAgZ3kgPSBncmF2aXR5LnksXG4gICAgICAgIGd6ID0gZ3Jhdml0eS56LFxuICAgICAgICBpPTA7XG5cbiAgICBpZihkb1Byb2ZpbGluZyl7XG4gICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGdyYXZpdHkgdG8gYWxsIG9iamVjdHNcbiAgICBmb3IoaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiaS50eXBlID09PSBEWU5BTUlDKXsgLy8gT25seSBmb3IgZHluYW1pYyBib2RpZXNcbiAgICAgICAgICAgIHZhciBmID0gYmkuZm9yY2UsIG0gPSBiaS5tYXNzO1xuICAgICAgICAgICAgZi54ICs9IG0qZ3g7XG4gICAgICAgICAgICBmLnkgKz0gbSpneTtcbiAgICAgICAgICAgIGYueiArPSBtKmd6O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHN1YnN5c3RlbXNcbiAgICBmb3IodmFyIGk9MCwgTnN1YnN5c3RlbXM9dGhpcy5zdWJzeXN0ZW1zLmxlbmd0aDsgaSE9PU5zdWJzeXN0ZW1zOyBpKyspe1xuICAgICAgICB0aGlzLnN1YnN5c3RlbXNbaV0udXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gQ29sbGlzaW9uIGRldGVjdGlvblxuICAgIGlmKGRvUHJvZmlsaW5nKXsgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTsgfVxuICAgIHAxLmxlbmd0aCA9IDA7IC8vIENsZWFuIHVwIHBhaXIgYXJyYXlzIGZyb20gbGFzdCBzdGVwXG4gICAgcDIubGVuZ3RoID0gMDtcbiAgICB0aGlzLmJyb2FkcGhhc2UuY29sbGlzaW9uUGFpcnModGhpcyxwMSxwMik7XG4gICAgaWYoZG9Qcm9maWxpbmcpeyBwcm9maWxlLmJyb2FkcGhhc2UgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0OyB9XG5cbiAgICAvLyBSZW1vdmUgY29uc3RyYWluZWQgcGFpcnMgd2l0aCBjb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlXG4gICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcbiAgICBmb3IoaT0wOyBpIT09TmNvbnN0cmFpbnRzOyBpKyspe1xuICAgICAgICB2YXIgYyA9IGNvbnN0cmFpbnRzW2ldO1xuICAgICAgICBpZighYy5jb2xsaWRlQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IHAxLmxlbmd0aC0xOyBqPj0wOyBqLT0xKXtcbiAgICAgICAgICAgICAgICBpZiggKGMuYm9keUEgPT09IHAxW2pdICYmIGMuYm9keUIgPT09IHAyW2pdKSB8fFxuICAgICAgICAgICAgICAgICAgICAoYy5ib2R5QiA9PT0gcDFbal0gJiYgYy5ib2R5QSA9PT0gcDJbal0pKXtcbiAgICAgICAgICAgICAgICAgICAgcDEuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICBwMi5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb2xsaXNpb25NYXRyaXhUaWNrKCk7XG5cbiAgICAvLyBHZW5lcmF0ZSBjb250YWN0c1xuICAgIGlmKGRvUHJvZmlsaW5nKXsgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTsgfVxuICAgIHZhciBvbGRjb250YWN0cyA9IFdvcmxkX3N0ZXBfb2xkQ29udGFjdHM7XG4gICAgdmFyIE5vbGRDb250YWN0cyA9IGNvbnRhY3RzLmxlbmd0aDtcblxuICAgIGZvcihpPTA7IGkhPT1Ob2xkQ29udGFjdHM7IGkrKyl7XG4gICAgICAgIG9sZGNvbnRhY3RzLnB1c2goY29udGFjdHNbaV0pO1xuICAgIH1cbiAgICBjb250YWN0cy5sZW5ndGggPSAwO1xuXG4gICAgLy8gVHJhbnNmZXIgRnJpY3Rpb25FcXVhdGlvbiBmcm9tIGN1cnJlbnQgbGlzdCB0byB0aGUgcG9vbCBmb3IgcmV1c2VcbiAgICB2YXIgTm9sZEZyaWN0aW9uRXF1YXRpb25zID0gdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7XG4gICAgZm9yKGk9MDsgaSE9PU5vbGRGcmljdGlvbkVxdWF0aW9uczsgaSsrKXtcbiAgICAgICAgZnJpY3Rpb25FcXVhdGlvblBvb2wucHVzaCh0aGlzLmZyaWN0aW9uRXF1YXRpb25zW2ldKTtcbiAgICB9XG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5uYXJyb3dwaGFzZS5nZXRDb250YWN0cyhcbiAgICAgICAgcDEsXG4gICAgICAgIHAyLFxuICAgICAgICB0aGlzLFxuICAgICAgICBjb250YWN0cyxcbiAgICAgICAgb2xkY29udGFjdHMsIC8vIFRvIGJlIHJldXNlZFxuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLFxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uUG9vbFxuICAgICk7XG5cbiAgICBpZihkb1Byb2ZpbGluZyl7XG4gICAgICAgIHByb2ZpbGUubmFycm93cGhhc2UgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0O1xuICAgIH1cblxuICAgIC8vIExvb3Agb3ZlciBhbGwgY29sbGlzaW9uc1xuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGZyaWN0aW9uIGVxc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb24odGhpcy5mcmljdGlvbkVxdWF0aW9uc1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG5jb250YWN0cyA9IGNvbnRhY3RzLmxlbmd0aDtcbiAgICBmb3IodmFyIGs9MDsgayE9PW5jb250YWN0czsgaysrKXtcblxuICAgICAgICAvLyBDdXJyZW50IGNvbnRhY3RcbiAgICAgICAgdmFyIGMgPSBjb250YWN0c1trXTtcblxuICAgICAgICAvLyBHZXQgY3VycmVudCBjb2xsaXNpb24gaW5kZWNlc1xuICAgICAgICB2YXIgYmkgPSBjLmJpLFxuICAgICAgICAgICAgYmogPSBjLmJqLFxuICAgICAgICAgICAgc2kgPSBjLnNpLFxuICAgICAgICAgICAgc2ogPSBjLnNqO1xuXG4gICAgICAgIC8vIEdldCBjb2xsaXNpb24gcHJvcGVydGllc1xuICAgICAgICB2YXIgY207XG4gICAgICAgIGlmKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKXtcbiAgICAgICAgICAgIGNtID0gdGhpcy5nZXRDb250YWN0TWF0ZXJpYWwoYmkubWF0ZXJpYWwsYmoubWF0ZXJpYWwpIHx8IHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNtID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYy5lbmFibGVkID0gYmkuY29sbGlzaW9uUmVzcG9uc2UgJiYgYmouY29sbGlzaW9uUmVzcG9uc2UgJiYgc2kuY29sbGlzaW9uUmVzcG9uc2UgJiYgc2ouY29sbGlzaW9uUmVzcG9uc2U7XG5cbiAgICAgICAgdmFyIG11ID0gY20uZnJpY3Rpb247XG4gICAgICAgIC8vIGMucmVzdGl0dXRpb24gPSBjbS5yZXN0aXR1dGlvbjtcblxuICAgICAgICAvLyBJZiBmcmljdGlvbiBvciByZXN0aXR1dGlvbiB3ZXJlIHNwZWNpZmllZCBpbiB0aGUgbWF0ZXJpYWwsIHVzZSB0aGVtXG4gICAgICAgIGlmKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKXtcbiAgICAgICAgICAgIGlmKGJpLm1hdGVyaWFsLmZyaWN0aW9uID49IDAgJiYgYmoubWF0ZXJpYWwuZnJpY3Rpb24gPj0gMCl7XG4gICAgICAgICAgICAgICAgbXUgPSBiaS5tYXRlcmlhbC5mcmljdGlvbiAqIGJqLm1hdGVyaWFsLmZyaWN0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihiaS5tYXRlcmlhbC5yZXN0aXR1dGlvbiA+PSAwICYmIGJqLm1hdGVyaWFsLnJlc3RpdHV0aW9uID49IDApe1xuICAgICAgICAgICAgICAgIGMucmVzdGl0dXRpb24gPSBiaS5tYXRlcmlhbC5yZXN0aXR1dGlvbiAqIGJqLm1hdGVyaWFsLnJlc3RpdHV0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblx0XHQvLyBjLnNldFNwb29rUGFyYW1zKFxuICAvLyAgICAgICAgICAgY20uY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzLFxuICAvLyAgICAgICAgICAgY20uY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbixcbiAgLy8gICAgICAgICAgIGR0XG4gIC8vICAgICAgICk7XG5cblx0XHRzb2x2ZXIuYWRkRXF1YXRpb24oYyk7XG5cblx0XHQvLyAvLyBBZGQgZnJpY3Rpb24gY29uc3RyYWludCBlcXVhdGlvblxuXHRcdC8vIGlmKG11ID4gMCl7XG5cblx0XHQvLyBcdC8vIENyZWF0ZSAyIHRhbmdlbnQgZXF1YXRpb25zXG5cdFx0Ly8gXHR2YXIgbXVnID0gbXUgKiBnbm9ybTtcblx0XHQvLyBcdHZhciByZWR1Y2VkTWFzcyA9IChiaS5pbnZNYXNzICsgYmouaW52TWFzcyk7XG5cdFx0Ly8gXHRpZihyZWR1Y2VkTWFzcyA+IDApe1xuXHRcdC8vIFx0XHRyZWR1Y2VkTWFzcyA9IDEvcmVkdWNlZE1hc3M7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gXHR2YXIgcG9vbCA9IGZyaWN0aW9uRXF1YXRpb25Qb29sO1xuXHRcdC8vIFx0dmFyIGMxID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYmksYmosbXVnKnJlZHVjZWRNYXNzKTtcblx0XHQvLyBcdHZhciBjMiA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJpLGJqLG11ZypyZWR1Y2VkTWFzcyk7XG5cdFx0Ly8gXHR0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goYzEsIGMyKTtcblxuXHRcdC8vIFx0YzEuYmkgPSBjMi5iaSA9IGJpO1xuXHRcdC8vIFx0YzEuYmogPSBjMi5iaiA9IGJqO1xuXHRcdC8vIFx0YzEubWluRm9yY2UgPSBjMi5taW5Gb3JjZSA9IC1tdWcqcmVkdWNlZE1hc3M7XG5cdFx0Ly8gXHRjMS5tYXhGb3JjZSA9IGMyLm1heEZvcmNlID0gbXVnKnJlZHVjZWRNYXNzO1xuXG5cdFx0Ly8gXHQvLyBDb3B5IG92ZXIgdGhlIHJlbGF0aXZlIHZlY3RvcnNcblx0XHQvLyBcdGMxLnJpLmNvcHkoYy5yaSk7XG5cdFx0Ly8gXHRjMS5yai5jb3B5KGMucmopO1xuXHRcdC8vIFx0YzIucmkuY29weShjLnJpKTtcblx0XHQvLyBcdGMyLnJqLmNvcHkoYy5yaik7XG5cblx0XHQvLyBcdC8vIENvbnN0cnVjdCB0YW5nZW50c1xuXHRcdC8vIFx0Yy5uaS50YW5nZW50cyhjMS50LCBjMi50KTtcblxuICAvLyAgICAgICAgICAgLy8gU2V0IHNwb29rIHBhcmFtc1xuICAvLyAgICAgICAgICAgYzEuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIGR0KTtcbiAgLy8gICAgICAgICAgIGMyLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCBkdCk7XG5cbiAgLy8gICAgICAgICAgIGMxLmVuYWJsZWQgPSBjMi5lbmFibGVkID0gYy5lbmFibGVkO1xuXG5cdFx0Ly8gXHQvLyBBZGQgZXF1YXRpb25zIHRvIHNvbHZlclxuXHRcdC8vIFx0c29sdmVyLmFkZEVxdWF0aW9uKGMxKTtcblx0XHQvLyBcdHNvbHZlci5hZGRFcXVhdGlvbihjMik7XG5cdFx0Ly8gfVxuXG4gICAgICAgIGlmKCBiaS5hbGxvd1NsZWVwICYmXG4gICAgICAgICAgICBiaS50eXBlID09PSBCb2R5LkRZTkFNSUMgJiZcbiAgICAgICAgICAgIGJpLnNsZWVwU3RhdGUgID09PSBCb2R5LlNMRUVQSU5HICYmXG4gICAgICAgICAgICBiai5zbGVlcFN0YXRlICA9PT0gQm9keS5BV0FLRSAmJlxuICAgICAgICAgICAgYmoudHlwZSAhPT0gQm9keS5TVEFUSUNcbiAgICAgICAgKXtcbiAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRCID0gYmoudmVsb2NpdHkubm9ybTIoKSArIGJqLmFuZ3VsYXJWZWxvY2l0eS5ub3JtMigpO1xuICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQiA9IE1hdGgucG93KGJqLnNsZWVwU3BlZWRMaW1pdCwyKTtcbiAgICAgICAgICAgIGlmKHNwZWVkU3F1YXJlZEIgPj0gc3BlZWRMaW1pdFNxdWFyZWRCKjIpe1xuICAgICAgICAgICAgICAgIGJpLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBiai5hbGxvd1NsZWVwICYmXG4gICAgICAgICAgICBiai50eXBlID09PSBCb2R5LkRZTkFNSUMgJiZcbiAgICAgICAgICAgIGJqLnNsZWVwU3RhdGUgID09PSBCb2R5LlNMRUVQSU5HICYmXG4gICAgICAgICAgICBiaS5zbGVlcFN0YXRlICA9PT0gQm9keS5BV0FLRSAmJlxuICAgICAgICAgICAgYmkudHlwZSAhPT0gQm9keS5TVEFUSUNcbiAgICAgICAgKXtcbiAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRBID0gYmkudmVsb2NpdHkubm9ybTIoKSArIGJpLmFuZ3VsYXJWZWxvY2l0eS5ub3JtMigpO1xuICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQSA9IE1hdGgucG93KGJpLnNsZWVwU3BlZWRMaW1pdCwyKTtcbiAgICAgICAgICAgIGlmKHNwZWVkU3F1YXJlZEEgPj0gc3BlZWRMaW1pdFNxdWFyZWRBKjIpe1xuICAgICAgICAgICAgICAgIGJqLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyB3ZSBrbm93IHRoYXQgaSBhbmQgaiBhcmUgaW4gY29udGFjdC4gU2V0IGNvbGxpc2lvbiBtYXRyaXggc3RhdGVcblx0XHR0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXQoYmksIGJqLCB0cnVlKTtcblxuICAgICAgICBpZiAoIXRoaXMuY29sbGlzaW9uTWF0cml4UHJldmlvdXMuZ2V0KGJpLCBiaikpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNvbnRhY3QhXG4gICAgICAgICAgICAvLyBXZSByZXVzZSB0aGUgY29sbGlkZUV2ZW50IG9iamVjdCwgb3RoZXJ3aXNlIHdlIHdpbGwgZW5kIHVwIGNyZWF0aW5nIG5ldyBvYmplY3RzIGZvciBlYWNoIG5ldyBjb250YWN0LCBldmVuIGlmIHRoZXJlJ3Mgbm8gZXZlbnQgbGlzdGVuZXIgYXR0YWNoZWQuXG4gICAgICAgICAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudC5ib2R5ID0gYmo7XG4gICAgICAgICAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudC5jb250YWN0ID0gYztcbiAgICAgICAgICAgIGJpLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQpO1xuXG4gICAgICAgICAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudC5ib2R5ID0gYmk7XG4gICAgICAgICAgICBiai5kaXNwYXRjaEV2ZW50KFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZihkb1Byb2ZpbGluZyl7XG4gICAgICAgIHByb2ZpbGUubWFrZUNvbnRhY3RDb25zdHJhaW50cyA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7XG4gICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuXG4gICAgLy8gV2FrZSB1cCBib2RpZXNcbiAgICBmb3IoaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiaS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSl7XG4gICAgICAgICAgICBiaS53YWtlVXAoKTtcbiAgICAgICAgICAgIGJpLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgdXNlci1hZGRlZCBjb25zdHJhaW50c1xuICAgIHZhciBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7XG4gICAgZm9yKGk9MDsgaSE9PU5jb25zdHJhaW50czsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSBjb25zdHJhaW50c1tpXTtcbiAgICAgICAgYy51cGRhdGUoKTtcbiAgICAgICAgZm9yKHZhciBqPTAsIE5lcT1jLmVxdWF0aW9ucy5sZW5ndGg7IGohPT1OZXE7IGorKyl7XG4gICAgICAgICAgICB2YXIgZXEgPSBjLmVxdWF0aW9uc1tqXTtcbiAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbihlcSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb2x2ZSB0aGUgY29uc3RyYWluZWQgc3lzdGVtXG4gICAgc29sdmVyLnNvbHZlKGR0LHRoaXMpO1xuXG4gICAgaWYoZG9Qcm9maWxpbmcpe1xuICAgICAgICBwcm9maWxlLnNvbHZlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGNvbnRhY3RzIGZyb20gc29sdmVyXG4gICAgc29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuXG4gICAgLy8gQXBwbHkgZGFtcGluZywgc2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9idWxsZXQvaXNzdWVzL2RldGFpbD9pZD03NCBmb3IgZGV0YWlsc1xuICAgIHZhciBwb3cgPSBNYXRoLnBvdztcbiAgICBmb3IoaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiaS50eXBlICYgRFlOQU1JQyl7IC8vIE9ubHkgZm9yIGR5bmFtaWMgYm9kaWVzXG4gICAgICAgICAgICB2YXIgbGQgPSBwb3coMS4wIC0gYmkubGluZWFyRGFtcGluZyxkdCk7XG4gICAgICAgICAgICB2YXIgdiA9IGJpLnZlbG9jaXR5O1xuICAgICAgICAgICAgdi5tdWx0KGxkLHYpO1xuICAgICAgICAgICAgdmFyIGF2ID0gYmkuYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgICAgaWYoYXYpe1xuICAgICAgICAgICAgICAgIHZhciBhZCA9IHBvdygxLjAgLSBiaS5hbmd1bGFyRGFtcGluZyxkdCk7XG4gICAgICAgICAgICAgICAgYXYubXVsdChhZCxhdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9wcmVTdGVwRXZlbnQpO1xuXG4gICAgLy8gSW52b2tlIHByZS1zdGVwIGNhbGxiYWNrc1xuICAgIGZvcihpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG4gICAgICAgIGlmKGJpLnByZVN0ZXApe1xuICAgICAgICAgICAgYmkucHJlU3RlcC5jYWxsKGJpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIExlYXAgZnJvZ1xuICAgIC8vIHZuZXcgPSB2ICsgaCpmL21cbiAgICAvLyB4bmV3ID0geCArIGgqdm5ld1xuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gICAgdmFyIHN0ZXBudW1iZXIgPSB0aGlzLnN0ZXBudW1iZXI7XG4gICAgdmFyIHF1YXROb3JtYWxpemUgPSBzdGVwbnVtYmVyICUgKHRoaXMucXVhdE5vcm1hbGl6ZVNraXAgKyAxKSA9PT0gMDtcbiAgICB2YXIgcXVhdE5vcm1hbGl6ZUZhc3QgPSB0aGlzLnF1YXROb3JtYWxpemVGYXN0O1xuXG4gICAgZm9yKGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIGJvZGllc1tpXS5pbnRlZ3JhdGUoZHQsIHF1YXROb3JtYWxpemUsIHF1YXROb3JtYWxpemVGYXN0KTtcbiAgICB9XG4gICAgdGhpcy5jbGVhckZvcmNlcygpO1xuXG4gICAgdGhpcy5icm9hZHBoYXNlLmRpcnR5ID0gdHJ1ZTtcblxuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgcHJvZmlsZS5pbnRlZ3JhdGUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0O1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB3b3JsZCB0aW1lXG4gICAgdGhpcy50aW1lICs9IGR0O1xuICAgIHRoaXMuc3RlcG51bWJlciArPSAxO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KFdvcmxkX3N0ZXBfcG9zdFN0ZXBFdmVudCk7XG5cbiAgICAvLyBJbnZva2UgcG9zdC1zdGVwIGNhbGxiYWNrc1xuICAgIGZvcihpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG4gICAgICAgIHZhciBwb3N0U3RlcCA9IGJpLnBvc3RTdGVwO1xuICAgICAgICBpZihwb3N0U3RlcCl7XG4gICAgICAgICAgICBwb3N0U3RlcC5jYWxsKGJpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNsZWVwaW5nIHVwZGF0ZVxuICAgIGlmKHRoaXMuYWxsb3dTbGVlcCl7XG4gICAgICAgIGZvcihpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICAgICAgYm9kaWVzW2ldLnNsZWVwVGljayh0aGlzLnRpbWUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXRzIGFsbCBib2R5IGZvcmNlcyBpbiB0aGUgd29ybGQgdG8gemVyby5cbiAqIEBtZXRob2QgY2xlYXJGb3JjZXNcbiAqL1xuV29ybGQucHJvdG90eXBlLmNsZWFyRm9yY2VzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYm9kaWVzID0gdGhpcy5ib2RpZXM7XG4gICAgdmFyIE4gPSBib2RpZXMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSBOOyBpKyspe1xuICAgICAgICB2YXIgYiA9IGJvZGllc1tpXSxcbiAgICAgICAgICAgIGZvcmNlID0gYi5mb3JjZSxcbiAgICAgICAgICAgIHRhdSA9IGIudG9ycXVlO1xuXG4gICAgICAgIGIuZm9yY2Uuc2V0KDAsMCwwKTtcbiAgICAgICAgYi50b3JxdWUuc2V0KDAsMCwwKTtcbiAgICB9XG59O1xuIl19
